<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式</title>
    <url>/2020/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。<strong>在程序需要进行拓展的时候，不能去修改原有的代码</strong>，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="一、创建型"><a href="#一、创建型" class="headerlink" title="一、创建型"></a>一、创建型</h1><h2 id="1-1-单例模式（Singleton）"><a href="#1-1-单例模式（Singleton）" class="headerlink" title="1.1 单例模式（Singleton）"></a>1.1 单例模式（Singleton）</h2><h3 id="1-1-1-介绍"><a href="#1-1-1-介绍" class="headerlink" title="1.1.1 介绍"></a>1.1.1 介绍</h3><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong> 当想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong> 构造函数是私有的。</p>
<p><strong>应用实例：</strong></p>
<p>1、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 </p>
<p>2、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>
<p><strong>优点：</strong> </p>
<p>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 </p>
<p>2、避免对资源的多重占用（比如写文件操作）。</p>
<p><strong>缺点：</strong> <strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</strong></p>
<p><strong>使用场景：</strong> </p>
<p>1、要求生产唯一序列号。 </p>
<p>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</p>
<p>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等，<strong>数据库连接池</strong>。</p>
<p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h3 id="1-1-2-实现方式"><a href="#1-1-2-实现方式" class="headerlink" title="1.1.2 实现方式"></a>1.1.2 实现方式</h3><p>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。</p>
<p>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。</p>
<p><img src="F:%5Cimages/201919092243-j.png" alt></p>
<p><strong>懒汉式-线程不安全</strong></p>
<p>以下实现中，私有静态变量 uniqueInstance 被延迟实例化（把对象的创建延迟到使用的时候创建，而不是对象实例化的时候创建 ），这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。</p>
<p>这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 uniqueInstance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-09 22:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式-线程安全</strong></p>
<p>线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-09 23:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 饿汉式-线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 uniqueInstance = <span class="keyword">new</span> Singleton2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>懒汉式-线程安全</strong></p>
<p>只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-09 23:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 懒汉式-线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>双重校验锁-线程安全</strong></p>
<p>uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-09 23:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 双重校验锁-线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton4 uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton4<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上述代码中只使用外部一个if语句话，那么就有可能两个线程都进入到if语句内部，这样的话uniqueInstance就会被实例化两次了，因此必须使用双重校验锁。</p>
<blockquote>
<p>==uniqueInstance 采用 volatile 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：==</p>
<ol>
<li>==为 uniqueInstance 分配内存空间==</li>
<li>==初始化 uniqueInstance==</li>
<li>==将 uniqueInstance 指向分配的内存地址==</li>
</ol>
<p>==但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，<strong>但是在多线程环境下会导致一个线程获得还没有初始化的实例</strong>。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。==</p>
<p>==使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。==</p>
</blockquote>
<p><strong>静态内部类实现</strong></p>
<p>当 Singleton5 类加载时，<strong>静态内部类 Singleton5Holder 没有被加载进内存</strong>。只有当调用 <code>getUniqueInstance()</code> 方法从而触发 <code>SingletonHolder5.uniqueInstance</code> 时 Singleton5Holder 才会被加载，此时初始化uniqueInstance 实例，并且 JVM 能确保 uniqueInstance 只被实例化一次。</p>
<p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-09 23:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 静态内部类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton5 uniqueInstance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton5Holder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-JDK"><a href="#1-1-3-JDK" class="headerlink" title="1.1.3 JDK"></a>1.1.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="noopener">java.lang.Runtime#getRuntime()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="noopener">java.awt.Desktop#getDesktop()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="noopener">java.lang.System#getSecurityManager()</a></li>
</ul>
<h3 id="1-1-4-破坏单例模式"><a href="#1-1-4-破坏单例模式" class="headerlink" title="*1.1.4 破坏单例模式"></a>*1.1.4 破坏单例模式</h3><p><strong>1、反射</strong></p>
<p>通过反射获得单例类的构造函数，由于该构造函数是private的，通过setAccessible(true)指示反射的对象在使用时应该取消 Java 语言访问检查,使得私有的构造函数能够被访问，这样使得单例模式失效。</p>
<p><strong>如果要抵御这种攻击，要防止构造函数被成功调用两次。需要在构造函数中对实例化次数进行统计，大于一次就抛出异常。</strong></p>
<p><strong>2、序列化</strong></p>
<p>一是可以实现数据的持久化；二是可以对象数据的远程传输。 如果过该类implements Serializable，那么就会在反序列化的过程中再创一个对象。这个问题的解决办法就是在反序列化时，指定反序化的对象实例。添加如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3979059770681747301L</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> singleton;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、克隆</strong></p>
<p>由克隆我们可以想到原型模式，原型模式就是通过clone方法实现对象的创建的，clone方式是Object方法，每个对象都有，那我使用一个单例模式类的对象，调用clone方法，再创建一个新的对象了，那岂不是上面说的单例模式失效了。</p>
<p>当然答案是否定，某一个对象直接调用clone方法，会抛出异常，即并不能成功克隆一个对象。调用该方法时，必须实现一个Cloneable 接口。这也就是原型模式的实现方式。还有即如果该类实现了Cloneable接口，尽管构造函数是私有的，他也可以创建一个对象。</p>
<p>即clone方法是不会调用构造函数的，他是直接从内存中copy内存区域的。</p>
<p><strong>所以单例模式的类是不可以实现cloneable接口的。</strong></p>
<h2 id="1-2-简单工厂（Simple-Factory）"><a href="#1-2-简单工厂（Simple-Factory）" class="headerlink" title="1.2 简单工厂（Simple Factory）"></a>1.2 简单工厂（Simple Factory）</h2><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无需知道其创建的细节。</p>
<h3 id="1-2-1-介绍"><a href="#1-2-1-介绍" class="headerlink" title="1.2.1 介绍"></a>1.2.1 介绍</h3><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 </p>
<h3 id="1-2-2-实现方式"><a href="#1-2-2-实现方式" class="headerlink" title="1.2.2 实现方式"></a>1.2.2 实现方式</h3><p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。</p>
<p><img src="F:%5Cimages/201919101232-m.png" alt></p>
<p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 11:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 产品接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct3</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 11:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 简单工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client类调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 13:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConcreteFactory concreteFactory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">        concreteFactory.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-工厂模式（Factory-Method）"><a href="#1-3-工厂模式（Factory-Method）" class="headerlink" title="1.3 工厂模式（Factory Method）"></a>1.3 工厂模式（Factory Method）</h2><h3 id="1-3-1-介绍"><a href="#1-3-1-介绍" class="headerlink" title="1.3.1 介绍"></a>1.3.1 介绍</h3><p>定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。 </p>
<p><strong>意图：</strong> 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>主要解决：</strong> 主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong> 明确地计划不同条件下创建不同实例时。</p>
<p><strong>如何解决：</strong> 让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p><strong>关键代码：</strong> 创建过程在其子类执行。</p>
<p><strong>应用实例：</strong> </p>
<p>1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 </p>
<p>2、Hibernate 换数据库只需换方言和驱动就可以。</p>
<p><strong>优点：</strong> </p>
<p>1、一个调用者想创建一个对象，只要知道其名称就可以了。 </p>
<p>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 </p>
<p>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。 </p>
<p><strong>使用场景：</strong> </p>
<p>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </p>
<p>3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p><strong>注意事项：</strong> 作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<p><strong>主要作用：</strong> 将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。 </p>
<p><strong>解决问题：</strong> 之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点</p>
<h3 id="1-3-2-实现方式"><a href="#1-3-2-实现方式" class="headerlink" title="1.3.2 实现方式"></a>1.3.2 实现方式</h3><blockquote>
<p><strong>UML类图</strong></p>
</blockquote>
<p><img src="F:%5Cimages/201919101343-u.png" alt></p>
<p><strong>模式组成</strong></p>
<table>
<thead>
<tr>
<th>组成（角色）</th>
<th>关系</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>产品接口（Product）</td>
<td>具体产品的父类</td>
<td>描述具体产品的公共接口</td>
</tr>
<tr>
<td>具体产品（Concrete Product）</td>
<td>实现产品接口；工厂类创建的目标类</td>
<td>描述生产的具体产品</td>
</tr>
<tr>
<td>抽象工厂（Factory）</td>
<td>具体工厂的父类</td>
<td>描述具体工厂类的公共接口</td>
</tr>
<tr>
<td>具体工厂（Concrete Factory）</td>
<td>抽象工厂的子类；被外界调用</td>
<td>描述具体工厂；实现factoryMethod工厂方法创建产品的实例</td>
</tr>
</tbody></table>
<p><strong>实现步骤</strong></p>
<p><strong>步骤1</strong>：创建产品接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2</strong>：创建具体产品，实现产品接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct3</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3</strong>：创建抽象工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建产品对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤4</strong>：创建具体工厂类，继承抽象工厂，重写factoryMethod方法创建具体的产品实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        factoryMethod().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        factoryMethod().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 12:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory3</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">factoryMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        factoryMethod().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5</strong>：外界调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 13:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteFactory concreteFactory = <span class="keyword">new</span> ConcreteFactory();</span><br><span class="line">        concreteFactory.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-JDK"><a href="#1-3-3-JDK" class="headerlink" title="1.3.3 JDK"></a>1.3.3 JDK</h3><ul>
<li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--" target="_blank" rel="noopener">java.util.Calendar</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance(); <span class="comment">//不是单例模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-" target="_blank" rel="noopener">java.util.ResourceBundle</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--" target="_blank" rel="noopener">java.text.NumberFormat</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-" target="_blank" rel="noopener">java.nio.charset.Charset</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-" target="_blank" rel="noopener">java.net.URLStreamHandlerFactory</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-" target="_blank" rel="noopener">java.util.EnumSet</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--" target="_blank" rel="noopener">javax.xml.bind.JAXBContext</a></p>
</li>
</ul>
<h2 id="1-4-抽象工厂（Abstract-Factory）"><a href="#1-4-抽象工厂（Abstract-Factory）" class="headerlink" title="1.4 抽象工厂（Abstract Factory）"></a>1.4 抽象工厂（Abstract Factory）</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h3 id="1-4-1-介绍"><a href="#1-4-1-介绍" class="headerlink" title="1.4.1 介绍"></a>1.4.1 介绍</h3><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p>
<p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p>
<p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p>
<h3 id="1-4-2-实现方式"><a href="#1-4-2-实现方式" class="headerlink" title="1.4.2 实现方式"></a>1.4.2 实现方式</h3><p><strong>UML类图</strong></p>
<p><img src="F:%5Cimages/201919101541-A.png" alt></p>
<p><strong>实现步骤</strong></p>
<p><strong>步骤1：</strong>创建材料A接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 材料A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientA</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示材料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：</strong>创建实现材料A接口的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体材料A1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientA1Impl</span> <span class="keyword">implements</span> <span class="title">IngredientA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"材料A1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体材料A2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientA2Impl</span> <span class="keyword">implements</span> <span class="title">IngredientA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"材料A2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：</strong>创建材料B接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 材料B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientB</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显示材料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：</strong>创建实现材料B的实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体材料B1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientB1Impl</span> <span class="keyword">implements</span> <span class="title">IngredientB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"材料B1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体材料B2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientB2Impl</span> <span class="keyword">implements</span> <span class="title">IngredientB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"材料B2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：</strong>为材料A和材料B创建抽象工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 原材料工厂，需要材料A,B</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIngredientFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建材料A</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> IngredientA <span class="title">createIngredientA</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建材料B</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> IngredientB <span class="title">createIngredientB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤6：</strong>创建继承了抽象工厂类的子类</p>
<p>用于获得材料A1和材料B1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体工厂1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIngredientFactory1Impl</span> <span class="keyword">extends</span> <span class="title">AbstractIngredientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IngredientA <span class="title">createIngredientA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IngredientA1Impl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IngredientB <span class="title">createIngredientB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IngredientB1Impl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于获得材料A2和材料B2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 具体工厂2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIngredientFactory2Impl</span> <span class="keyword">extends</span> <span class="title">AbstractIngredientFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IngredientA <span class="title">createIngredientA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IngredientA2Impl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IngredientB <span class="title">createIngredientB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IngredientB2Impl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤7：</strong>创建一个工厂创造器/生成器类，通过传递信息来获取工厂。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 15:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 获取工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractIngredientFactory <span class="title">getFactory</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AbstractIngredientFactory1Impl();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AbstractIngredientFactory2Impl();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤8：</strong>使用 FactoryProducer 来获取 AbstractIngredientFactory，通过传递类型信息来获取实体类的对象。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.abstractfactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-10 14:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 获取材料</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractIngredientFactory abstractIngredientFactory = FactoryProducer.getFactory(<span class="number">1</span>);</span><br><span class="line">        abstractIngredientFactory.createIngredientA().show();</span><br><span class="line">        abstractIngredientFactory.createIngredientB().show();</span><br><span class="line"></span><br><span class="line">        AbstractIngredientFactory abstractIngredientFactory2 = FactoryProducer.getFactory(<span class="number">2</span>);</span><br><span class="line">        abstractIngredientFactory2.createIngredientA().show();</span><br><span class="line">        abstractIngredientFactory2.createIngredientB().show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-JDK"><a href="#1-4-3-JDK" class="headerlink" title="1.4.3 JDK"></a>1.4.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html" target="_blank" rel="noopener">javax.xml.parsers.DocumentBuilderFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--" target="_blank" rel="noopener">javax.xml.transform.TransformerFactory</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--" target="_blank" rel="noopener">javax.xml.xpath.XPathFactory</a></li>
</ul>
<h2 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h2><p>总结一下简单工厂、工厂方法（工厂模式）、抽象工厂。</p>
<p><strong>简单工厂模式不是23种设计模式里的一种，其主要作用就是专门生产某一类产品。比如说鼠标工厂，传入参数1生产惠普鼠标，传入参数2生产联想鼠标。</strong></p>
<p><strong>工厂方法就是生产鼠标的工厂是一个父类，它的下边有生产惠普鼠标的子类和生产联想鼠标的子类，然后通过具体的子类生产对应品牌的鼠标。</strong></p>
<p><strong>抽象工厂就是不仅仅要生产鼠标，还要生产键盘。这样就会有一个PC生产厂，它是一个父类，有两个接口，一个用来生产鼠标，一个用来生产键盘。那么惠普工厂就继承这个父类，生产自己的鼠标和键盘；同理联想工厂也继承这个父类，生产自己的鼠标和键盘。所以抽象工厂模式就是提供一个创建一系列相关或者互相依赖对象的接口，而无需指定具体的对象类。</strong></p>
<p><strong>==当产品只有一个的时候，抽象工厂就变成了工厂方法了；当工厂方法中生产的产品不止一个的时候，那么工厂方法就变成了抽象工厂。==</strong></p>
<blockquote>
<p>如果在抽象工厂中增加一个工厂戴尔，那么需要做的就是戴尔工厂继承PC生产厂，然后分别创建戴尔鼠标和戴尔键盘类分别继承鼠标父类和键盘父类。</p>
<p>如果在抽象工厂中增加一个产品，那么此时PC生产厂就有三个接口了：鼠标、键盘、耳麦。那么我们就要创建耳麦父类，以及联想耳麦和惠普耳麦两个子类。然后在PC生产厂增加耳麦接口，惠普工厂和联想工厂分别实现耳麦接口，生产耳麦。</p>
</blockquote>
<h2 id="1-6-建造者（Builder）"><a href="#1-6-建造者（Builder）" class="headerlink" title="1.6 建造者（Builder）"></a>1.6 建造者（Builder）</h2><h3 id="1-6-1-介绍"><a href="#1-6-1-介绍" class="headerlink" title="1.6.1 介绍"></a>1.6.1 介绍</h3><p>封装一个对象的构造过程，并允许按步骤构造。它的主要作用就是将复杂事物创建的过程抽象出来，该抽象的不同实现方式不同，创建出的对象也不同。</p>
<p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
<p><strong>如何解决：</strong>将变与不变分离开。</p>
<p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
<p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
<p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
<p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<h3 id="1-6-2-实现"><a href="#1-6-2-实现" class="headerlink" title="1.6.2 实现"></a>1.6.2 实现</h3><p>user对象包含四个属性：名字、年龄、邮箱、地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 15:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建对象的时候，如果只需要某几个字段的话，要么使用事先定义好的构造器来创建，要么写一大堆set方法。如果使用Builder模式来编写，就可以很好的解决问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 15:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line">        <span class="keyword">private</span> String email;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.email = email;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User2 <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">           User2 user2 = <span class="keyword">new</span> User2();</span><br><span class="line">           user2.name = name;</span><br><span class="line">           user2.age = age;</span><br><span class="line">           user2.address = address;</span><br><span class="line">           user2.email = email;</span><br><span class="line">           <span class="keyword">return</span> user2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User2&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", email='"</span> + email + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 15:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user2 = <span class="keyword">new</span> User2.Builder().setName(<span class="string">"1"</span>).setAge(<span class="number">2</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样创建对象的方式就很优雅。</p>
<h3 id="1-6-3-StringBuilder解析"><a href="#1-6-3-StringBuilder解析" class="headerlink" title="1.6.3 StringBuilder解析"></a>1.6.3 StringBuilder解析</h3><p>StringBuilder的父类AbstractStringBuilder就是采用Builder模式的实现append方法的：</p>
<p><img src="F:%5Cimages/201919111620-W.png" alt></p>
<p>重写一个简单的StringBuilder</p>
<p><strong>父类：MyAbstractStringBuilder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder.stringbuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 15:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAbstractStringBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAbstractStringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyAbstractStringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        ensureCapacityInternal(count + <span class="number">1</span>);</span><br><span class="line">        value[count ++] = c;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//扩容</span></span><br><span class="line">            expandCapacity(minimumCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = minimumCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            &#125;</span><br><span class="line">            newCapacity = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类：MyStringBuilder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder.stringbuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 16:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringBuilder</span> <span class="keyword">extends</span> <span class="title">MyAbstractStringBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStringBuilder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.builder.stringbuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 15:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyStringBuilder stringBuilder = <span class="keyword">new</span> MyStringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            stringBuilder.append((<span class="keyword">char</span>)(<span class="string">'0'</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="F:%5Cimages/201919111625-D.png" alt></p>
<h3 id="1-6-4-JDK"><a href="#1-6-4-JDK" class="headerlink" title="1.6.4 JDK"></a>1.6.4 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="noopener">java.lang.StringBuilder</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-" target="_blank" rel="noopener">java.nio.ByteBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="noopener">java.lang.StringBuffer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html" target="_blank" rel="noopener">java.lang.Appendable</a></li>
</ul>
<blockquote>
<p><strong>知识点：</strong></p>
</blockquote>
<p>字符串拼接的四种方法：</p>
<blockquote>
<p>加号拼接。</p>
</blockquote>
<p>打开编译后的字节码我们可以发现加号拼接字符串jvm底层其实是调用StringBuilder来实现的，也就是说”a” + “b”等效于下面的代码片。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(a).append(<span class="string">"b"</span>);</span><br><span class="line">String str = sb.toString();</span><br></pre></td></tr></table></figure>

<p>但并不是说直接用“+”号拼接就可以达到StringBuilder的效率了，因为用“+”号每拼接一次都会新建一个StringBuilder对象，并且最后toString()方法还会生成一个String对象。在循环拼接十万次的时候，就会生成十万个StringBuilder对象，十万个String对象，这简直就是噩梦。</p>
<blockquote>
<p>concat拼接  </p>
</blockquote>
<p><img src="F:%5Cimages/201919111635-u.png" alt><br>concat其实就是申请一个char类型的buf数组，将需要拼接的字符串都放在这个数组里，最后再转换成String对象。 </p>
<blockquote>
<p>StringBuilder/StringBuffer  </p>
</blockquote>
<p>这两个类实现append的方法都是调用父类AbstractStringBuilder的append方法，只不过StringBuffer的append方法加了sychronized关键字，因此是线程安全的。利用char数组实现。</p>
<h2 id="1-7-原型模式（Prototype）"><a href="#1-7-原型模式（Prototype）" class="headerlink" title="1.7 原型模式（Prototype）"></a>1.7 原型模式（Prototype）</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h3 id="1-7-1-介绍"><a href="#1-7-1-介绍" class="headerlink" title="1.7.1 介绍"></a>1.7.1 介绍</h3><p><strong>意图：</strong> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><strong>主要解决：</strong> 在运行期建立和删除原型。</p>
<p><strong>何时使用：</strong> </p>
<p>1、当一个系统应该独立于它的产品创建，构成和表示时。 </p>
<p>2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 </p>
<p>3、为了避免创建一个与产品类层次平行的工厂类层次时。 </p>
<p>4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
<p><strong>如何解决：</strong> 利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<p><strong>关键代码：</strong>  </p>
<p>1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()</p>
<p>2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p>
<p><strong>应用实例：</strong>  1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p>
<p><strong>优点：</strong>  1、性能提高。 2、逃避构造函数的约束。</p>
<p><strong>缺点：</strong>  1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
<p><strong>使用场景：</strong>  1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、 <strong>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</strong> 原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p>*<em>注意事项： *</em> 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h3 id="1-7-2-实现"><a href="#1-7-2-实现" class="headerlink" title="1.7.2 实现"></a>1.7.2 实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 16:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Prototype <span class="title">myclone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcretePrototype</span><span class="params">(String filed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filed = filed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Prototype <span class="title">myclone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcretePrototype(filed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcretePrototype&#123;"</span> +</span><br><span class="line">                <span class="string">"filed='"</span> + filed + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 16:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype(<span class="string">"123"</span>);</span><br><span class="line">        Prototype prototype1 = prototype.myclone();</span><br><span class="line">        System.out.println(prototype1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-JDK"><a href="#1-7-3-JDK" class="headerlink" title="1.7.3 JDK"></a>1.7.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#clone%28%29" target="_blank" rel="noopener">java.lang.Object#clone()</a></li>
</ul>
<blockquote>
<p><strong>知识点</strong></p>
</blockquote>
<p>当自定义类的字段的类型不是基本数据类型时 ，会出现浅复制，非基本数据类型必须继承Cloneable接口。</p>
<h1 id="二、行为型"><a href="#二、行为型" class="headerlink" title="二、行为型"></a>二、行为型</h1><h2 id="2-1-责任链（Chain-Of-Responsibility）"><a href="#2-1-责任链（Chain-Of-Responsibility）" class="headerlink" title="2.1 责任链（Chain Of Responsibility）"></a>2.1 责任链（Chain Of Responsibility）</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h3 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h3><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p>
<p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p>
<p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<h3 id="2-1-2-实现方式"><a href="#2-1-2-实现方式" class="headerlink" title="2.1.2 实现方式"></a>2.1.2 实现方式</h3><p>创建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息判断消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。 </p>
<p><img src="F:%5Cimages/201919111942-7.png" alt></p>
<p><strong>抽象Logger类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.chainofresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 19:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(AbstractLogger next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.level == level)&#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            String string = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">this</span>.level)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:string=<span class="string">"INFO"</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:string=<span class="string">"DEBUG"</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:string=<span class="string">"ERROR"</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(string + <span class="string">"无法处理消息："</span> + message);</span><br><span class="line">            <span class="comment">//无法处理的消息就向下转发</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            	next.logMessage(level, message);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Logger类的三个子类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.chainofresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 19:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DEBUGLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DEBUGLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DEBUG log:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.chainofresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 19:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ERRORLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ERRORLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ERROR log:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.chainofresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 19:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">INFOLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">INFOLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"INFO log:"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用</strong></p>
<p>构造责任链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.chainofresponsibility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-11 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ERRORLogger(AbstractLogger.ERROR);</span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> DEBUGLogger(AbstractLogger.DEBUG);</span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> INFOLogger(AbstractLogger.INFO);</span><br><span class="line">        errorLogger.setNext(fileLogger);</span><br><span class="line">        fileLogger.setNext(consoleLogger);</span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">"INFO"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG, <span class="string">"DEBUG"</span>);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR, <span class="string">"ERROR"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919111959-1.png" alt></p>
<h3 id="2-1-3-JDK"><a href="#2-1-3-JDK" class="headerlink" title="2.1.3 JDK"></a>2.1.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log%28java.util.logging.Level,%20java.lang.String%29" target="_blank" rel="noopener">java.util.logging.Logger#log()</a></li>
<li><a href="https://commons.apache.org/proper/commons-chain/index.html" target="_blank" rel="noopener">Apache Commons Chain</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/Filter.html#doFilter-javax.servlet.ServletRequest-javax.servlet.ServletResponse-javax.servlet.FilterChain-" target="_blank" rel="noopener">javax.servlet.Filter#doFilter()</a></li>
</ul>
<h2 id="2-2-命令（Command）"><a href="#2-2-命令（Command）" class="headerlink" title="2.2 命令（Command）"></a>2.2 命令（Command）</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 </p>
<h3 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h3><p>*<em>意图： *</em>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p>
<p><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<blockquote>
<p><strong>将命令封装成对象中，具有以下作用：</strong></p>
</blockquote>
<ul>
<li>使用命令来参数化其它对象</li>
<li>将命令放入队列中进行排队</li>
<li>将命令的操作记录到日志中</li>
<li>支持可撤销的操作</li>
</ul>
<h3 id="2-2-2-实现方式"><a href="#2-2-2-实现方式" class="headerlink" title="2.2.2 实现方式"></a>2.2.2 实现方式</h3><p>首先创建作为命令的接口 <em>Order*，然后创建作为请求的 *Stock</em> 类。实体命令类 <em>BuyStock</em> 和 <em>SellStock*，实现了 *Order</em> 接口，将执行实际的命令处理。创建作为调用对象的类 <em>Broker</em>，它接受订单并能下订单。</p>
<p><em>Broker</em> 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。</p>
<p><img src="F:%5Cimages/201919141348-c.png" alt></p>
<p>&lt;1&gt;创建命令接口——Command</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 命令接口————Command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;命令接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 实体命令类————Command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyStock</span><span class="params">(Stock stock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = stock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 实体命令类————Command</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellStock</span> <span class="keyword">implements</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stock abcStock;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellStock</span><span class="params">(Stock abcStock)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.abcStock = abcStock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        abcStock.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;3&gt;创建命令接收者——Receiver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 请求类，命令接收者————Receiver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ABC"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", Quantity: "</span> + quantity +<span class="string">" ] bought"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Stock [ Name: "</span>+name+<span class="string">", Quantity: "</span> + quantity +<span class="string">" ] sold"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;4&gt;创建Invoker，调用命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 命令调用类，接收命令并执行————Invoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders = <span class="keyword">new</span> ArrayList&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeOrder</span><span class="params">(Order order)</span></span>&#123;</span><br><span class="line">        orders.add(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrders</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Order order : orders)&#123;</span><br><span class="line">            order.execute();</span><br><span class="line">        &#125;</span><br><span class="line">        orders.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;5&gt;设置命令与命令的接收者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.command;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 13:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stock abcStock = <span class="keyword">new</span> Stock();</span><br><span class="line">        BuyStock buyStockOrder = <span class="keyword">new</span> BuyStock(abcStock);</span><br><span class="line">        SellStock sellStockOrder = <span class="keyword">new</span> SellStock(abcStock);</span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        broker.takeOrder(buyStockOrder);</span><br><span class="line">        broker.takeOrder(sellStockOrder);</span><br><span class="line">        broker.placeOrders();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="F:%5Cimages/201919141413-L.png" alt></p>
<ul>
<li>Receiver（Stock）：命令接收者，也就是命令真正的执行者</li>
<li>Command（Order）：命令，对Receiver类进行命令处理 </li>
<li>Invoker（Broker）：通过它来调用命令</li>
<li>Client(Test)：可以设置命令与命令的接收者</li>
</ul>
<h3 id="2-2-3-JDK"><a href="#2-2-3-JDK" class="headerlink" title="2.2.3 JDK"></a>2.2.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" target="_blank" rel="noopener">java.lang.Runnable</a></li>
<li><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">Netflix Hystrix</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/swing/Action.html" target="_blank" rel="noopener">javax.swing.Action</a></li>
</ul>
<h2 id="2-3-解释器（Interpreter）"><a href="#2-3-解释器（Interpreter）" class="headerlink" title="2.3 解释器（Interpreter）"></a>2.3 解释器（Interpreter）</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 </p>
<h3 id="2-3-1-介绍"><a href="#2-3-1-介绍" class="headerlink" title="2.3.1 介绍"></a>2.3.1 介绍</h3><p><strong>意图：</strong> 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong> 对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong> 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong> 构件语法树，定义终结符与非终结符。</p>
<p><strong>关键代码：</strong> 构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<h3 id="2-3-2-实现方式"><a href="#2-3-2-实现方式" class="headerlink" title="2.3.2 实现方式"></a>2.3.2 实现方式</h3><blockquote>
<p>&lt;1&gt;模式结构</p>
</blockquote>
<p>解释器模式包含以下主要角色。</p>
<ol>
<li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li>
<li>终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li>
<li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li>
<li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li>
<li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li>
</ol>
<blockquote>
<p>&lt;2&gt;模式实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span>;    <span class="comment">//解释方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非终结符表达式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonterminalExpression</span> <span class="keyword">implements</span> <span class="title">AbstractExpression</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp1;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">interpret</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//非对终结符表达式的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环境类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression exp;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//数据初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用相关表达式类的解释方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;3&gt;场景模拟</p>
</blockquote>
<p>说明：模拟公交读卡器的身份识别功能。假如“长安通”公交车读卡器可以判断乘客的身份，如果是“西安”的“老人” “妇女”“儿童”就可以免费乘车，其他人员乘车一次扣 2 元。</p>
<p>分析：本实例用“解释器模式”设计比较适合，首先设计其文法规则如下。  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">expression</span>&gt;</span> ::= <span class="tag">&lt;<span class="name">city</span>&gt;</span>的<span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">city</span>&gt;</span> ::= 西安</span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span> ::= 老人|妇女|儿童</span><br></pre></td></tr></table></figure>

<p>然后，根据文法规则按以下步骤设计公交车卡的读卡器程序的类图。</p>
<ul>
<li>定义一个抽象表达式（Expression）接口，它包含了解释方法 interpret(String   info)。</li>
<li>定义一个终结符表达式（Terminal Expression）类，<strong>城市和人就是终结符</strong>。用集合（Set）类来保存满足条件的城市或人，并实现抽象表达式接口中的解释方法 interpret(Stringinfo)，用来判断被分析的字符串是否是集合中的终结符。</li>
<li>定义一个非终结符表达式（AndExpressicm）类，它也是抽象表达式的子类，非终结符表达式一般是文法中的运算符或者其他关键字，这里面就是关键词“<strong>的</strong>”，非终结符它包含满足条件的城市的终结符表达式对象和满足条件的人员的终结符表达式对象，并实现 interpret(String info) 方法，用来判断被分析的字符串是否是满足条件的城市中的满足条件的人员。</li>
<li>最后，定义一个环境（Context）类，它包含<strong>解释器需要的数据，完成对终结符表达式的初始化</strong>，并定义一个方法 freeRide(String info) <strong>调用表达式对象的解释方法来对被分析的字符串进行解释</strong>。其结构图如下图所示。</li>
</ul>
<p><img src="F:%5Cimages/201919141715-3.png" alt></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 16:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 抽象表达式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 16:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 终结符表达式类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(String[] data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        set.addAll(Arrays.asList(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(info))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 非终结符表达式类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Expression city=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Expression person=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(Expression city,Expression person)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.city=city;</span><br><span class="line">        <span class="keyword">this</span>.person=person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        String[] s = info.split(<span class="string">"的"</span>);</span><br><span class="line">        <span class="keyword">return</span> city.interpret(s[<span class="number">0</span>]) &amp;&amp; person.interpret(s[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 上下文环境</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] citys=&#123;<span class="string">"西安"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] persons=&#123;<span class="string">"老人"</span>,<span class="string">"妇女"</span>,<span class="string">"儿童"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> Expression cityPerson;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Expression city=<span class="keyword">new</span> TerminalExpression(citys);</span><br><span class="line">        Expression person=<span class="keyword">new</span> TerminalExpression(persons);</span><br><span class="line">        cityPerson=<span class="keyword">new</span> AndExpression(city,person);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeRide</span><span class="params">(String info)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok=cityPerson.interpret(info);</span><br><span class="line">        <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">            System.out.println(<span class="string">"您是"</span>+info+<span class="string">"，您本次乘车免费！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(info+<span class="string">"，您不是免费人员，本次乘车扣费2元！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.interpreter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.freeRide(<span class="string">"西安的老人"</span>);</span><br><span class="line">        context.freeRide(<span class="string">"西安的年轻人"</span>);</span><br><span class="line">        context.freeRide(<span class="string">"西安的妇女"</span>);</span><br><span class="line">        context.freeRide(<span class="string">"西安的儿童"</span>);</span><br><span class="line">        context.freeRide(<span class="string">"宝鸡的老人"</span>);</span><br><span class="line">        context.freeRide(<span class="string">"宝鸡的儿童"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919141717-h.png" alt></p>
<h3 id="2-3-3-JDK"><a href="#2-3-3-JDK" class="headerlink" title="2.3.3 JDK"></a>2.3.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html" target="_blank" rel="noopener">java.util.Pattern</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/text/Normalizer.html" target="_blank" rel="noopener">java.text.Normalizer</a></li>
<li>All subclasses of <a href="http://docs.oracle.com/javase/8/docs/api/java/text/Format.html" target="_blank" rel="noopener">java.text.Format</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/el/ELResolver.html" target="_blank" rel="noopener">javax.el.ELResolver</a></li>
</ul>
<h2 id="2-4-迭代器（Iterator）"><a href="#2-4-迭代器（Iterator）" class="headerlink" title="2.4 迭代器（Iterator）"></a>2.4 迭代器（Iterator）</h2><h3 id="2-4-1-介绍"><a href="#2-4-1-介绍" class="headerlink" title="2.4.1 介绍"></a>2.4.1 介绍</h3><p>*<em>意图： *</em> 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong> 不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong> 遍历一个聚合对象。</p>
<p><strong>如何解决：</strong> 把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong> 定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong> JAVA 中的 iterator。</p>
<p><strong>优点：</strong>  1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p><strong>缺点：</strong> 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong>  1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p>
<p><strong>注意事项：</strong> 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h3 id="2-4-2-实现方式"><a href="#2-4-2-实现方式" class="headerlink" title="2.4.2 实现方式"></a>2.4.2 实现方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 迭代器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否存在下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 容器类接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取迭代器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实现了 Container 接口的实体类。该类有实现了 Iterator 接口的内部类 MyIterator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] strings = <span class="keyword">new</span> String[]&#123;<span class="string">"123"</span>,<span class="string">"456"</span>,<span class="string">"789"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index &lt; strings.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.hasNext() ? strings[index ++] : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-14 17:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyContainer container = <span class="keyword">new</span> MyContainer();</span><br><span class="line">        Iterator iterator = container.getIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919141749-9.png" alt></p>
<h3 id="2-4-3-JDK"><a href="#2-4-3-JDK" class="headerlink" title="2.4.3 JDK"></a>2.4.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener">java.util.Iterator</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener">java.util.Enumeration</a></li>
</ul>
<h2 id="2-5-中介者（Mediator）"><a href="#2-5-中介者（Mediator）" class="headerlink" title="2.5 中介者（Mediator）"></a>2.5 中介者（Mediator）</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<h3 id="2-5-1-介绍"><a href="#2-5-1-介绍" class="headerlink" title="2.5.1 介绍"></a>2.5.1 介绍</h3><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<p><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p>
<p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<h3 id="2-5-2-实现方式"><a href="#2-5-2-实现方式" class="headerlink" title="2.5.2 实现方式"></a>2.5.2 实现方式</h3><p>以现实生活中打牌的例子来实现下中介者模式。打牌总有输赢，对应的则是货币的变化。</p>
<p>如果不用中介者模式的话，实现如下：</p>
<blockquote>
<p>抽象牌友类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 抽象牌友类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ownMoney;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改变money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractCardPartner other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>牌友类的实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerA</span> <span class="keyword">extends</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractCardPartner other)</span> </span>&#123;</span><br><span class="line">        ownMoney += money;</span><br><span class="line">        other.ownMoney -= money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerB</span> <span class="keyword">extends</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractCardPartner other)</span> </span>&#123;</span><br><span class="line">        ownMoney += money;</span><br><span class="line">        other.ownMoney -= money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Console;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCardPartner A = <span class="keyword">new</span> PartnerA();</span><br><span class="line">        A.ownMoney = <span class="number">20</span>;</span><br><span class="line">        AbstractCardPartner B = <span class="keyword">new</span> PartnerB();</span><br><span class="line">        B.ownMoney = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//A赢了B的钱</span></span><br><span class="line">        A.changeMoney(<span class="number">5</span>, B);</span><br><span class="line">        System.out.println(<span class="string">"A的钱："</span> + A.ownMoney);</span><br><span class="line">        System.out.println(<span class="string">"B的钱："</span> + B.ownMoney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B赢了A的钱</span></span><br><span class="line">        B.changeMoney(<span class="number">10</span>, A);</span><br><span class="line">        System.out.println(<span class="string">"A的钱："</span> + A.ownMoney);</span><br><span class="line">        System.out.println(<span class="string">"B的钱："</span> + B.ownMoney);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="F:%5Cimages/201919171757-U.png" alt></p>
<p>这样的实现确实解决了上面场景中的问题，并且使用了抽象类使具体牌友A和牌友B都依赖于抽象类，从而降低了同事类之间的耦合度。但是如果其中牌友A发生变化时，此时就会影响到牌友B的状态，如果涉及的对象变多的话，这时候某一个牌友的变化将会影响到其他所有相关联的牌友状态。例如牌友A算错了钱，这时候牌友A和牌友B的钱数都不正确了，如果是多个人打牌的话，影响的对象就会更多。</p>
<p>加入一个中介者对象来协调各个对象之间的关联：</p>
<blockquote>
<p>抽象牌友类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 抽象牌友类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ownMoney;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 改变money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mediator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractMediator mediator)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抽象牌友类实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerA</span> <span class="keyword">extends</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PartnerA</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractMediator mediator)</span> </span>&#123;</span><br><span class="line">        mediator.win(<span class="keyword">this</span>,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartnerB</span> <span class="keyword">extends</span> <span class="title">AbstractCardPartner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PartnerB</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> money, AbstractMediator mediator)</span> </span>&#123;</span><br><span class="line">        mediator.win(<span class="keyword">this</span>,money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>抽象中介者</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 赢钱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> winner</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">win</span><span class="params">(AbstractCardPartner winner,<span class="keyword">int</span> money)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中介者实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 18:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">AbstractMediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractCardPartner&gt; partners;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteMediator</span><span class="params">(List&lt;AbstractCardPartner&gt; partners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partners = partners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">win</span><span class="params">(AbstractCardPartner winner, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AbstractCardPartner temp : <span class="keyword">this</span>.partners)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.name.equals(winner.name))&#123;</span><br><span class="line">                temp.ownMoney += money;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.ownMoney -= money;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.mediator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Console;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 17:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractCardPartner A = <span class="keyword">new</span> PartnerA(<span class="string">"玩家A"</span>);</span><br><span class="line">        A.ownMoney = <span class="number">20</span>;</span><br><span class="line">        AbstractCardPartner B = <span class="keyword">new</span> PartnerB(<span class="string">"玩家B"</span>);</span><br><span class="line">        B.ownMoney = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;AbstractCardPartner&gt; partners = Arrays.asList(A,B);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介者</span></span><br><span class="line">        AbstractMediator mediator = <span class="keyword">new</span> ConcreteMediator(partners);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------------A赢了----------------------"</span>);</span><br><span class="line">        <span class="comment">//A赢了钱</span></span><br><span class="line">        A.changeMoney(<span class="number">5</span>,mediator);</span><br><span class="line">        <span class="keyword">for</span> (AbstractCardPartner partner : partners)&#123;</span><br><span class="line">            System.out.println(partner.name + <span class="string">"的钱："</span> + partner.ownMoney);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------------B赢了----------------------"</span>);</span><br><span class="line">        <span class="comment">//B赢了钱</span></span><br><span class="line">        B.changeMoney(<span class="number">10</span>,mediator);</span><br><span class="line">        <span class="keyword">for</span> (AbstractCardPartner partner : partners)&#123;</span><br><span class="line">            System.out.println(partner.name + <span class="string">"的钱："</span> + partner.ownMoney);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919171841-6.png" alt></p>
<p>改变的地方：</p>
<ul>
<li>每个玩家加上了姓名</li>
<li>通过中介者进行结算，而不是由自己结算</li>
<li>结算时扫描玩家列表，只有赢的一方加钱，其余都减钱</li>
</ul>
<h3 id="2-5-3-JDK"><a href="#2-5-3-JDK" class="headerlink" title="2.5.3 JDK"></a>2.5.3 JDK</h3><ul>
<li>All scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" target="_blank" rel="noopener">java.util.Timer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html#execute-java.lang.Runnable-" target="_blank" rel="noopener">java.util.concurrent.Executor#execute()</a></li>
<li>submit() and invokeXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ExecutorService</a></li>
<li>scheduleXXX() methods of <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" target="_blank" rel="noopener">java.util.concurrent.ScheduledExecutorService</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-" target="_blank" rel="noopener">java.lang.reflect.Method#invoke()</a></li>
</ul>
<h2 id="2-6-备忘录（Memento）"><a href="#2-6-备忘录（Memento）" class="headerlink" title="2.6 备忘录（Memento）"></a>2.6 备忘录（Memento）</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<h3 id="2-6-1-介绍"><a href="#2-6-1-介绍" class="headerlink" title="2.6.1 介绍"></a>2.6.1 介绍</h3><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctr + z。 4、IE 中的后退。 4、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h3 id="2-6-2-实现方式"><a href="#2-6-2-实现方式" class="headerlink" title="2.6.2 实现方式"></a>2.6.2 实现方式</h3><p>备忘录模式使用三个类 <em>Memento<em>、</em>Originator</em> 和 <em>CareTaker</em>。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。</p>
<p><img src="F:%5Cimages/201919172056-c.png" alt></p>
<blockquote>
<p>创建 Memento 类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 20:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 Originator 类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 20:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Originator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveStateToMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Memento(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStateFromMemento</span><span class="params">(Memento Memento)</span></span>&#123;</span><br><span class="line">        state = Memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建 CareTaker 类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 20:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Memento&gt; mementos = <span class="keyword">new</span> ArrayList&lt;Memento&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Memento state)</span></span>&#123;</span><br><span class="line">        mementos.add(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mementos.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.memento;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-17 20:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Originator originator = <span class="keyword">new</span> Originator();</span><br><span class="line">        CareTaker careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line">        originator.setState(<span class="string">"State #1"</span>);</span><br><span class="line">        originator.setState(<span class="string">"State #2"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #3"</span>);</span><br><span class="line">        careTaker.add(originator.saveStateToMemento());</span><br><span class="line">        originator.setState(<span class="string">"State #4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Current State: "</span> + originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">"First saved State: "</span> + originator.getState());</span><br><span class="line">        originator.getStateFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">"Second saved State: "</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919172140-Q.png" alt></p>
<h3 id="2-6-3-JDK"><a href="#2-6-3-JDK" class="headerlink" title="2.6.3 JDK"></a>2.6.3 JDK</h3><ul>
<li>java.io.Serializable</li>
</ul>
<h2 id="2-7-观察者（Observer）"><a href="#2-7-观察者（Observer）" class="headerlink" title="2.7 观察者（Observer）"></a>2.7 观察者（Observer）</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<h3 id="2-7-1-介绍"><a href="#2-7-1-介绍" class="headerlink" title="2.7.1 介绍"></a>2.7.1 介绍</h3><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 </p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<h3 id="2-7-2-实现方式"><a href="#2-7-2-实现方式" class="headerlink" title="2.7.2 实现方式"></a>2.7.2 实现方式</h3><p>观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。创建 <em>Subject</em> 类、<em>Observer</em> 抽象类和扩展了抽象类 <em>Observer</em> 的实体类。</p>
<p>只要Subject一改变，就会通知其所有观察者！！！！！</p>
<p><img src="F:%5Cimages/201919182207-9.png" alt></p>
<blockquote>
<p>创建Subject</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 20:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建Observer</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 21:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Observer的实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Binary String: "</span></span><br><span class="line">                + Integer.toBinaryString( subject.getState() ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OctalObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Octal String: "</span></span><br><span class="line">                + Integer.toOctalString( subject.getState() ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 21:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexObserver</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"Hex String: "</span></span><br><span class="line">                + Integer.toHexString( subject.getState() ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 21:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject();</span><br><span class="line">        <span class="keyword">new</span> HexObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line">        <span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line">        System.out.println(<span class="string">"First state change: 15"</span>);</span><br><span class="line">        subject.setState(<span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">"Second state change: 10"</span>);</span><br><span class="line">        subject.setState(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919182140-s.png" alt></p>
<h3 id="2-7-3-JDK"><a href="#2-7-3-JDK" class="headerlink" title="2.7.3 JDK"></a>2.7.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Observer.html" target="_blank" rel="noopener">java.util.Observer</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/EventListener.html" target="_blank" rel="noopener">java.util.EventListener</a></li>
<li><a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSessionBindingListener.html" target="_blank" rel="noopener">javax.servlet.http.HttpSessionBindingListener</a></li>
<li><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a></li>
</ul>
<h2 id="2-8-状态（State）"><a href="#2-8-状态（State）" class="headerlink" title="2.8 状态（State）"></a>2.8 状态（State）</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个<strong>行为随着状态对象改变而改变的 context 对象</strong>。</p>
<h3 id="2-8-1-介绍"><a href="#2-8-1-介绍" class="headerlink" title="2.8.1 介绍"></a>2.8.1 介绍</h3><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<h3 id="2-8-2-实现"><a href="#2-8-2-实现" class="headerlink" title="2.8.2 实现"></a>2.8.2 实现</h3><p>创建一个 <em>State</em> 接口和实现了 <em>State</em> 接口的实体状态类。<em>Context</em> 是一个带有某个状态的类。</p>
<p><img src="F:%5Cimages/201919192252-b.png" alt></p>
<blockquote>
<p>创建状态接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 22:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建Context</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 22:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当State状态改变时，查看其行为变化。</p>
<blockquote>
<p>创建实现状态接口的实体类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 22:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in start state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Start State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 22:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Player is in start state"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Start State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-18 22:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        StartState startState = <span class="keyword">new</span> StartState();</span><br><span class="line">        startState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line"></span><br><span class="line">        StopState stopState = <span class="keyword">new</span> StopState();</span><br><span class="line">        stopState.doAction(context);</span><br><span class="line">        System.out.println(context.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919182229-D.png" alt></p>
<h2 id="2-9-策略（Strategy）"><a href="#2-9-策略（Strategy）" class="headerlink" title="2.9 策略（Strategy）"></a>2.9 策略（Strategy）</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<h3 id="2-9-1-介绍"><a href="#2-9-1-介绍" class="headerlink" title="2.9.1 介绍"></a>2.9.1 介绍</h3><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h3 id="2-9-2-实现"><a href="#2-9-2-实现" class="headerlink" title="2.9.2 实现"></a>2.9.2 实现</h3><p>创建一个定义活动的 <em>Strategy</em> 接口和实现了 <em>Strategy</em> 接口的实体策略类。<em>Context</em> 是一个使用了某种策略的类。</p>
<p>使用 <em>Context</em> 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。</p>
<blockquote>
<p>策略接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-19 22:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>策略实现类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-19 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-19 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Context</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-19 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.strategy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-19 23:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> AddStrategy());</span><br><span class="line">        System.out.println(<span class="string">"1 + 2 ="</span> + context.executeStrategy(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        Context context2 = <span class="keyword">new</span> Context(<span class="keyword">new</span> SubStrategy());</span><br><span class="line">        System.out.println(<span class="string">"1 - 2 ="</span> + context2.executeStrategy(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<p><img src="F:%5Cimages/201919192308-S.png" alt></p>
<h3 id="2-9-3-JDK"><a href="#2-9-3-JDK" class="headerlink" title="2.9.3 JDK"></a>2.9.3 JDK</h3><ul>
<li>java.util.Comparator#compare()</li>
<li>javax.servlet.http.HttpServlet</li>
<li>javax.servlet.Filter#doFilter()</li>
</ul>
<h2 id="2-10-模板方法（Template-Method）"><a href="#2-10-模板方法（Template-Method）" class="headerlink" title="2.10 模板方法（Template Method）"></a>2.10 模板方法（Template Method）</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<h3 id="2-10-1-介绍"><a href="#2-10-1-介绍" class="headerlink" title="2.10.1 介绍"></a>2.10.1 介绍</h3><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。  2、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
<p><strong>优点：</strong> 1、<strong>封装不变部分，扩展可变部分</strong>。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h3 id="2-10-2-实现"><a href="#2-10-2-实现" class="headerlink" title="2.10.2 实现"></a>2.10.2 实现</h3><p>创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p>
<p><img src="F:%5Cimages/201919201824-h.png" alt></p>
<blockquote>
<p>创建一个抽象类</p>
</blockquote>
<p>模板方法play被设置为 final，不可修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-20 18:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化游戏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始游戏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束游戏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化游戏</span></span><br><span class="line">        initialize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始游戏</span></span><br><span class="line">        startPlay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//结束游戏</span></span><br><span class="line">        endPlay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>游戏实体类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-20 18:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Initialize Success !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game Start !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Cricket Game End !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-20 18:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Initialize Success !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game Start !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Football Game End !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.templatemethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-20 18:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game1 = <span class="keyword">new</span> Cricket();</span><br><span class="line">        game1.play();</span><br><span class="line">        System.out.println(<span class="string">"----------------------------"</span>);</span><br><span class="line">        Game game2 = <span class="keyword">new</span> Football();</span><br><span class="line">        game2.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919201819-3.png" alt></p>
<h3 id="2-10-3-JDK"><a href="#2-10-3-JDK" class="headerlink" title="2.10.3 JDK"></a>2.10.3 JDK</h3><ul>
<li>java.util.Collections#sort()</li>
<li>java.io.InputStream#skip()</li>
<li>java.io.InputStream#read()</li>
<li>java.util.AbstractList#indexOf()</li>
</ul>
<h2 id="2-11-访问者模式（Visitor）"><a href="#2-11-访问者模式（Visitor）" class="headerlink" title="2.11 访问者模式（Visitor）"></a>2.11 访问者模式（Visitor）</h2><p>在访问者模式（Visitor Pattern）中，使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<h3 id="2-11-1-介绍"><a href="#2-11-1-介绍" class="headerlink" title="2.11.1 介绍"></a>2.11.1 介绍</h3><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p>
<p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<h3 id="2-11-2-实现"><a href="#2-11-2-实现" class="headerlink" title="2.11.2 实现"></a>2.11.2 实现</h3><p>创建一个定义接受操作的 <em>ComputerPart</em> 接口。<em>Keyboard<em>、</em>Mouse<em>、</em>Monitor</em> 和 <em>Computer</em> 是实现了 <em>ComputerPart</em> 接口的实体类。定义另一个接口 <em>ComputerPartVisitor<em>，它定义了访问者类的操作。</em>Computer</em> 使用实体访问者来执行相应的动作。</p>
<p><img src="F:%5Cimages/201919212240-t.png" alt></p>
<blockquote>
<p>定义ComputerPart接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建ComputerPart的实体类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">       computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> <span class="keyword">implements</span> <span class="title">ComputerPart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ComputerPartVisitor computerPartVisitor)</span> </span>&#123;</span><br><span class="line">        computerPartVisitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义一个访问者接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问者接口实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPartVisitorImpl</span> <span class="keyword">implements</span> <span class="title">ComputerPartVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Computer computer)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Computer................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Mouse mouse)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mouse................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Keyboard keyboard)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Keyboard................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Monitor monitor)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Monitor................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.visitor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-01-21 22:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComputerPart computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        computer.accept(<span class="keyword">new</span> ComputerPartVisitorImpl());</span><br><span class="line"></span><br><span class="line">        ComputerPart keyboard = <span class="keyword">new</span> Keyboard();</span><br><span class="line">        keyboard.accept(<span class="keyword">new</span> ComputerPartVisitorImpl());</span><br><span class="line"></span><br><span class="line">        ComputerPart mouse = <span class="keyword">new</span> Mouse();</span><br><span class="line">        mouse.accept(<span class="keyword">new</span> ComputerPartVisitorImpl());</span><br><span class="line"></span><br><span class="line">        ComputerPart monitor = <span class="keyword">new</span> Monitor();</span><br><span class="line">        monitor.accept(<span class="keyword">new</span> ComputerPartVisitorImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="F:%5Cimages/201919212225-j.png" alt></p>
<h3 id="2-11-3-JDK"><a href="#2-11-3-JDK" class="headerlink" title="2.11.3 JDK"></a>2.11.3 JDK</h3><ul>
<li>javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor</li>
<li>javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor</li>
</ul>
<h2 id="2-12-空对象（Null）"><a href="#2-12-空对象（Null）" class="headerlink" title="2.12 空对象（Null）"></a>2.12 空对象（Null）</h2><p>使用什么都不做的空对象来代替 NULL。</p>
<p>一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealOperation</span> <span class="keyword">extends</span> <span class="title">AbstractOperation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullOperation</span> <span class="keyword">extends</span> <span class="title">AbstractOperation</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractOperation abstractOperation = func(-<span class="number">1</span>);</span><br><span class="line">        abstractOperation.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractOperation <span class="title">func</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (para &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NullOperation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RealOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、结构型"><a href="#三、结构型" class="headerlink" title="三、结构型"></a>三、结构型</h1><h2 id="3-1-适配器（Adapter）"><a href="#3-1-适配器（Adapter）" class="headerlink" title="3.1 适配器（Adapter）"></a>3.1 适配器（Adapter）</h2><h3 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h3><p>把一个类接口转换成另一个用户需要的接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><img src="/.com//1550999701408.png" alt="1550999701408"></p>
<h3 id="3-1-2-实现"><a href="#3-1-2-实现" class="headerlink" title="3.1.2 实现"></a>3.1.2 实现</h3><p>我们有一个 <em>MediaPlayer</em> 接口和一个实现了 <em>MediaPlayer</em> 接口的实体类 <em>AudioPlayer<em>。默认情况下，</em>AudioPlayer</em> 可以播放 mp3 格式的音频文件。</p>
<p>我们还有另一个接口 <em>AdvancedMediaPlayer</em> 和实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p>
<p>我们想要让 <em>AudioPlayer</em> 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 <em>MediaPlayer</em> 接口的适配器类 <em>MediaAdapter*，并使用 *AdvancedMediaPlayer</em> 对象来播放所需的格式。</p>
<p><em>AudioPlayer</em> 使用适配器类 <em>MediaAdapter</em> 传递所需的音频类型，不需要知道能播放所需格式音频的实际类。<em>AdapterPatternDemo*，我们的演示类使用 *AudioPlayer</em> 类来播放各种格式。</p>
<p><img src="/.com//1551001017770.png" alt="1551001017770"></p>
<p>步骤1：为媒体播放器和更高级的媒体播放器创建接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放mp3</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">(String type,String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放mp4</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 播放vlc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：创建实现了 <em>AdvancedMediaPlayer</em> 接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play mp4："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play vlc："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建实现了 <em>MediaPlayer</em> 接口的适配器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AdvancedMediaPlayer advancedMediaPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMediaPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMediaPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">            advancedMediaPlayer.playVlc(name);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            advancedMediaPlayer.playMp4(<span class="string">"mp4"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：创建实现了 <em>MediaPlayer</em> 接口的实体类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MediaAdapter mediaAdapter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//播放mp3，内置支持</span></span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"play mp3："</span> + name);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">"vlc"</span>) || type.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">            mediaAdapter = <span class="keyword">new</span> MediaAdapter(type);</span><br><span class="line">            mediaAdapter.play(type, name);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"invalid media type"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤5：测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.adapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line">        audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"123"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"321"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"456"</span>);</span><br><span class="line">        audioPlayer.play(<span class="string">"mp5"</span>, <span class="string">"654"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-JDK"><a href="#3-1-3-JDK" class="headerlink" title="3.1.3 JDK"></a>3.1.3 JDK</h3><ul>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList%28T...%29" target="_blank" rel="noopener">java.util.Arrays#asList()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-" target="_blank" rel="noopener">java.util.Collections#list()</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-" target="_blank" rel="noopener">java.util.Collections#enumeration()</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-" target="_blank" rel="noopener">javax.xml.bind.annotation.adapters.XMLAdapter</a></li>
</ul>
<h2 id="3-2-外观（Facade）"><a href="#3-2-外观（Facade）" class="headerlink" title="3.2 外观（Facade）"></a>3.2 外观（Facade）</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p>提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。</p>
<h3 id="3-2-2-实现"><a href="#3-2-2-实现" class="headerlink" title="3.2.2 实现"></a>3.2.2 实现</h3><p>我们将创建一个 <em>Shape</em> 接口和实现了 <em>Shape</em> 接口的实体类。下一步是定义一个外观类 <em>ShapeMaker</em>。</p>
<p><em>ShapeMaker</em> 类使用实体类来代表用户对这些类的调用。<em>FacadePatternDemo*，我们的演示类使用 *ShapeMaker</em> 类来显示结果。</p>
<p><img src="/.com//1551002538396.png" alt="1551002538396"></p>
<p>步骤1：创建一个图形接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：实现图形接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"draw square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建外观类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 17:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Circle circle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Square square;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        circle = <span class="keyword">new</span> Circle();</span><br><span class="line"></span><br><span class="line">        square = <span class="keyword">new</span> Square();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.facade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-24 18:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line">        shapeMaker.drawCircle();</span><br><span class="line">        shapeMaker.drawSquare();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-设计原则"><a href="#3-2-3-设计原则" class="headerlink" title="3.2.3 设计原则"></a>3.2.3 设计原则</h3><p>最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。</p>
<h2 id="3-3-桥接模式（Bridge）"><a href="#3-3-桥接模式（Bridge）" class="headerlink" title="3.3 桥接模式（Bridge）"></a>3.3 桥接模式（Bridge）</h2><h3 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h3><p>将抽象与实现分离开来，使它们可以独立变化。</p>
<h3 id="3-3-2-实现"><a href="#3-3-2-实现" class="headerlink" title="3.3.2 实现"></a>3.3.2 实现</h3><p>不同颜色要和不同形状进行搭配，创建一个颜色接口Color，两个实现类White和Blue，内部的paint方法通过传入形状类型画出对应颜色的形状；创建一个作为桥接实现的 Shape抽象类，内部有Color成员变量，通过draw方法进行画图，Square和Circle继承了Shape类。</p>
<p><img src="/.com//1551104273405.png" alt="1551104273405"></p>
<p>步骤1：创建颜色接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：实现颜色接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝色的"</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">White</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色的"</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建桥接抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：继承Shape类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color.paint(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color.paint(<span class="string">"正方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤5：组装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.bridge;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-02-25 22:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Color white = <span class="keyword">new</span> White();</span><br><span class="line">        Shape circle = <span class="keyword">new</span> Circle(white);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        Color blue = <span class="keyword">new</span> Blue();</span><br><span class="line">        Shape square = <span class="keyword">new</span> Square(blue);</span><br><span class="line">        square.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-JDK"><a href="#3-3-3-JDK" class="headerlink" title="3.3.3 JDK"></a>3.3.3 JDK</h3><ul>
<li>AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)</li>
<li>JDBC</li>
</ul>
<h2 id="3-4-享元模式（Flyweight-）"><a href="#3-4-享元模式（Flyweight-）" class="headerlink" title="3.4 享元模式（Flyweight ）"></a>3.4 享元模式（Flyweight ）</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<h3 id="3-4-1-介绍"><a href="#3-4-1-介绍" class="headerlink" title="3.4.1 介绍"></a>3.4.1 介绍</h3><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p>
<p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
<h3 id="3-4-2-实现"><a href="#3-4-2-实现" class="headerlink" title="3.4.2 实现"></a>3.4.2 实现</h3><p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 <em>Circle</em> 对象。</p>
<p><img src="http://mycsdnblog.work/201919231605-1.png" alt></p>
<p>步骤1：创建一个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-08-23 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤2：实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-08-23 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Circle&#123;"</span> +</span><br><span class="line">                <span class="string">"color='"</span> + color + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", x="</span> + x +</span><br><span class="line">                <span class="string">", y="</span> + y +</span><br><span class="line">                <span class="string">", radius="</span> + radius +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤3：创建一个工厂，创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-08-23 15:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String,Shape&gt; map = <span class="keyword">new</span> HashMap&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getCircle</span><span class="params">(String color)</span></span>&#123;</span><br><span class="line">        Circle circle = (Circle) map.get(color);</span><br><span class="line">        <span class="keyword">if</span> (circle == <span class="keyword">null</span>)&#123;</span><br><span class="line">            circle = <span class="keyword">new</span> Circle(color);</span><br><span class="line">            map.put(color, circle);</span><br><span class="line">            System.out.println(<span class="string">"create circle of color:"</span> + color);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤4：使用工厂，获取实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.flyweight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-08-23 15:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String colors[] = &#123;<span class="string">"Red"</span>,<span class="string">"Green"</span>,<span class="string">"Blue"</span>,<span class="string">"White"</span>,<span class="string">"Black"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Circle circle = (Circle) ShapeFactory.getCircle(getRandomColor());</span><br><span class="line">            circle.setRadius(<span class="number">100</span>);</span><br><span class="line">            circle.setX(getRandom());</span><br><span class="line">            circle.setX(getRandom());</span><br><span class="line">            circle.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getRandomColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> colors[(<span class="keyword">int</span>) (Math.random() * colors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Mysql七种join</title>
    <url>/2020/06/28/Mysql%E4%B8%83%E7%A7%8Djoin/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-1-建表"><a href="#1-1-建表" class="headerlink" title="1.1 建表"></a>1.1 建表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tbl_dept(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	deptName VARCHAR(30),</span><br><span class="line">	locAdd VARCHAR(40),</span><br><span class="line">	PRIMARY KEY(id)</span><br><span class="line">)ENGINE&#x3D;INNODB CHARSET &#x3D; utf8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl_emp(</span><br><span class="line">	id INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">	NAME VARCHAR(30),</span><br><span class="line">	deptId INT(11),</span><br><span class="line">	PRIMARY KEY(id),</span><br><span class="line">	FOREIGN KEY tbl_emp(deptId) REFERENCES tbl_dept(id)</span><br><span class="line">)ENGINE&#x3D;INNODB CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-插入数据"><a href="#1-2-插入数据" class="headerlink" title="1.2 插入数据"></a>1.2 插入数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;RD&#39;,11);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;HR&#39;,12);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;MK&#39;,13);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;MIS&#39;,14);</span><br><span class="line">INSERT INTO tbl_dept(deptName,locAdd) VALUES(&#39;FD&#39;,15);</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z3&#39;,1);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z4&#39;,1);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;z5&#39;,1);</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;w5&#39;,2);</span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;w6&#39;,2);</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;s7&#39;,3);</span><br><span class="line"></span><br><span class="line">INSERT INTO tbl_emp(NAME,deptId) VALUES(&#39;s8&#39;,4);</span><br></pre></td></tr></table></figure>

<h1 id="二、连接"><a href="#二、连接" class="headerlink" title="二、连接"></a>二、连接</h1><h2 id="2-1-内连接"><a href="#2-1-内连接" class="headerlink" title="*2.1 内连接"></a>*2.1 内连接</h2><p><img src="http://mycsdnblog.work/201919042008-J.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	INNER JOIN tbl_emp b ON a.id &#x3D; b.deptId;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept,</span><br><span class="line">	tbl_emp </span><br><span class="line">WHERE</span><br><span class="line">	tbl_dept.id &#x3D; tbl_emp.deptId;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://mycsdnblog.work/201919042016-a.png" alt></p>
<h2 id="2-2-外连接"><a href="#2-2-外连接" class="headerlink" title="2.2 外连接"></a>2.2 外连接</h2><h3 id="2-2-1-左外连接"><a href="#2-2-1-左外连接" class="headerlink" title="2.2.1 左外连接"></a>2.2.1 左外连接</h3><p><img src="http://mycsdnblog.work/201919042021-X.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	LEFT JOIN tbl_emp b ON a.id &#x3D; b.deptId;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	LEFT OUTER JOIN tbl_emp b ON a.id &#x3D; b.deptId;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://mycsdnblog.work/201919042026-a.png" alt></p>
<h3 id="2-2-2-右外连接"><a href="#2-2-2-右外连接" class="headerlink" title="2.2.2 右外连接"></a>2.2.2 右外连接</h3><p><img src="http://mycsdnblog.work/201919042031-Y.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	RIGHT JOIN tbl_emp b ON a.id &#x3D; b.deptId;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	RIGHT OUTER JOIN tbl_emp b ON a.id &#x3D; b.deptId;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://mycsdnblog.work/201919042033-m.png" alt></p>
<h3 id="2-2-3-全连接"><a href="#2-2-3-全连接" class="headerlink" title="2.2.3 全连接"></a>2.2.3 全连接</h3><p><img src="http://mycsdnblog.work/201919042042-i.png" alt></p>
<p>mysql不支持，用其他方案代替</p>
<h2 id="2-3-自连接"><a href="#2-3-自连接" class="headerlink" title="2.3 自连接"></a>2.3 自连接</h2><p>自连接，连接的两个表都是同一个表，同样可以由内连接，外连接各种组合方式，按实际应用去组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept a</span><br><span class="line">	LEFT JOIN tbl_dept b ON a.id &#x3D; b.id;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="http://mycsdnblog.work/201919042055-f.png" alt></p>
<h2 id="2-4-笛卡儿积"><a href="#2-4-笛卡儿积" class="headerlink" title="2.4 笛卡儿积"></a>2.4 笛卡儿积</h2><p>A x B</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	tbl_dept</span><br><span class="line">	CROSS JOIN tbl_emp;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>deptName</th>
<th>locAdd</th>
<th>id(1)</th>
<th>NAME</th>
<th align="left">deptId</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>1</td>
<td>z3</td>
<td align="left">1</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>1</td>
<td>z3</td>
<td align="left">1</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>1</td>
<td>z3</td>
<td align="left">1</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>1</td>
<td>z3</td>
<td align="left">1</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>1</td>
<td>z3</td>
<td align="left">1</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>2</td>
<td>z4</td>
<td align="left">1</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>2</td>
<td>z4</td>
<td align="left">1</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>2</td>
<td>z4</td>
<td align="left">1</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>2</td>
<td>z4</td>
<td align="left">1</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>2</td>
<td>z4</td>
<td align="left">1</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>3</td>
<td>z5</td>
<td align="left">1</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>3</td>
<td>z5</td>
<td align="left">1</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>3</td>
<td>z5</td>
<td align="left">1</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>3</td>
<td>z5</td>
<td align="left">1</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>3</td>
<td>z5</td>
<td align="left">1</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>4</td>
<td>w5</td>
<td align="left">2</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>4</td>
<td>w5</td>
<td align="left">2</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>4</td>
<td>w5</td>
<td align="left">2</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>4</td>
<td>w5</td>
<td align="left">2</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>4</td>
<td>w5</td>
<td align="left">2</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>5</td>
<td>w6</td>
<td align="left">2</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>5</td>
<td>w6</td>
<td align="left">2</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>5</td>
<td>w6</td>
<td align="left">2</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>5</td>
<td>w6</td>
<td align="left">2</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>5</td>
<td>w6</td>
<td align="left">2</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>6</td>
<td>s7</td>
<td align="left">3</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>6</td>
<td>s7</td>
<td align="left">3</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>6</td>
<td>s7</td>
<td align="left">3</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>6</td>
<td>s7</td>
<td align="left">3</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>6</td>
<td>s7</td>
<td align="left">3</td>
</tr>
<tr>
<td>1</td>
<td>RD</td>
<td>11</td>
<td>7</td>
<td>s8</td>
<td align="left">4</td>
</tr>
<tr>
<td>2</td>
<td>HR</td>
<td>12</td>
<td>7</td>
<td>s8</td>
<td align="left">4</td>
</tr>
<tr>
<td>3</td>
<td>MK</td>
<td>13</td>
<td>7</td>
<td>s8</td>
<td align="left">4</td>
</tr>
<tr>
<td>4</td>
<td>MIS</td>
<td>14</td>
<td>7</td>
<td>s8</td>
<td align="left">4</td>
</tr>
<tr>
<td>5</td>
<td>FD</td>
<td>15</td>
<td>7</td>
<td>s8</td>
<td align="left">4</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>前端</title>
    <url>/2020/06/28/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="一、RestFul的优点"><a href="#一、RestFul的优点" class="headerlink" title="一、RestFul的优点"></a>一、RestFul的优点</h1><ol>
<li><p>轻量，直接基于http，不再需要任何别的诸如消息协议。get/post/put/delete为CRUD操作</p>
</li>
<li><p>面向资源，一目了然，具有自解释性。</p>
</li>
<li><p>数据描述简单，一般以xml，json做数据交换。</p>
</li>
<li><p>无状态，在调用一个接口（访问、操作资源）的时候，可以不用考虑上下文，不用考虑当前状态，极大的降低了复杂度。</p>
</li>
<li><p>简单、低耦合</p>
</li>
</ol>
<h1 id="二、VUE的生命周期"><a href="#二、VUE的生命周期" class="headerlink" title="二、VUE的生命周期"></a>二、VUE的生命周期</h1><p><img src="http://mycsdnblog.work/201919241738-U.png" alt></p>
<h1 id="三、Nuxt-js"><a href="#三、Nuxt-js" class="headerlink" title="三、Nuxt.js"></a>三、Nuxt.js</h1><h1 id="四、Promise异步调用"><a href="#四、Promise异步调用" class="headerlink" title="四、Promise异步调用"></a>四、Promise异步调用</h1><h1 id="五、async-await方法同步调用"><a href="#五、async-await方法同步调用" class="headerlink" title="五、async/await方法同步调用"></a>五、async/await方法同步调用</h1>]]></content>
  </entry>
  <entry>
    <title>网络层次模型划分（下）</title>
    <url>/2020/06/28/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p><strong>上一篇：</strong><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/网络原理/网络分层模型划分（上）.md" target="_blank" rel="noopener">网络层次模型划分（上）</a></p>
<h1 id="网络层次模型划分（下）"><a href="#网络层次模型划分（下）" class="headerlink" title="网络层次模型划分（下）"></a>网络层次模型划分（下）</h1><h3 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h3><p>上一篇主要分享了网络分层的基本概念，为什么要进行网络分层？又是如何进行分层？每一层的基本功能是什么？而且对于每一层的的功能细节方面，比如数据包的组成以及每层包含的一些协议的使用都没有细说，那么这一篇文章将会分享网络分层每层中协议等深入讲解。（PS：可能里边有的讲解不正确，还请大佬指出改正）</p>
<h3 id="1、物理层"><a href="#1、物理层" class="headerlink" title="1、物理层"></a>1、物理层</h3><p>物理层里边涉及到最多的是硬件底层的一些内容，没有需要过多了解的内容，我们直接看数据链路层。</p>
<h3 id="2、数据链路层"><a href="#2、数据链路层" class="headerlink" title="2、数据链路层"></a>2、数据链路层</h3><p>上回讲到数据链路层中规定的“以太网协议”来规定电信号的分组形式，什么是以太网，以太网的数据包是什么样子的？</p>
<h4 id="2-1-以太网协议"><a href="#2-1-以太网协议" class="headerlink" title="2.1 以太网协议"></a>2.1 <strong>以太网协议</strong></h4><p>以太网规定，每组的电信号就是一个数据包，每个数据包我们可以成为“帧”。每帧的组成是由标头(Head)和数据(Data)组成。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE.png?raw=true" alt></p>
<p>那么你会问，标头里有什么信息？Data 数据又会存放写什么？为什么分为两部分？放在一块不好吗？</p>
<p><strong>1、标头</strong></p>
<p>为什么传输数据会有标头，我们想呀，在传输数据的时候，接收端怎么判断是不是给自己发送的，那么就只取出标头来进行判断。</p>
<p>数据包的标头中通常会存放一些有关数据包的说明、发送者是谁、接受者又是谁等相关识别信息。</p>
<p>标头的长度固定为 18 字节，也就是说，一些标头识别信息的大小不能超过 18 字节。</p>
<p><strong>2、数据</strong></p>
<p>数据，顾名思义，你要传输给接收端什么数据都会放到数据包中，也就是整个数据包的具体内容，比如文件、字符串之类的。</p>
<p>数据部分的长度最小至少为 46 个字节，最长 1500 字节。我们可能会想到，如果小于 46 字节没啥问题可以存放开，那么大于 1500 字节怎么处理呢？很简单，我们就分成两个包处理（分割），两个包存放不下就分割成三个包……</p>
<h4 id="2-2-广播"><a href="#2-2-广播" class="headerlink" title="2.2 广播"></a>2.2 广播</h4><p>上回说到，广播的作用就是用来查找接收端的 MAC 地址，从而进行下一步的数据传输。注意，广播只是一种发送数据的形式，而计算机想要知道另一台计算机的 MAC 地址是通过 ARP 协议解决的，ARP 协议会在讲完 IP 协议后再说，因为它会涉及到 IP 协议的一点内容，现在讲可能会有点乱。</p>
<p>如果你觉的上边稍微有点乱，那怎们稍微屡一下，我们想要发送数据，首先要知道对方的唯一标识（MAC 地址），要想知道对方的 MAC 地址，需要使用 ARP 协议，假设我们通过 ARP 协议拿到了接收方的 MAC 地址。</p>
<p>我们开始发送数据，将发送方的 MAC 地址和接收方的 MAC 地址封装在数据包中，然后发送端向同一子网络中（同一局域网）中的所有计算机发送该数据包，所有的计算机接收到该包之后，就对数据包的头部进行提取，提取出里边封装好的接收端 MAC 地址和自己的 MAC 地址作比对，如果相同，就说明该数据包是给自己发送的，否则，就会丢弃该数据包，这个过程就是广播的过程。</p>
<p>上一篇文章在这个地方留下的一个问题就以上是在同一局域网中，如果不在同一局域网中我们怎么处理？我们平常使用无线网都知道每个无线局域网都会有一个路由器，我们先通过以上的方法将数据发送到路由器，然后路由器转发数据到其他局域网中的计算机。</p>
<h3 id="3、网络层"><a href="#3、网络层" class="headerlink" title="3、网络层"></a>3、网络层</h3><p>网络层中最重要的一个协议就是 IP 协议，我们一般发送端给服务端发送数据同时要知道两个地址才能准确送达到对方，分别为 IP 地址和 MAC 地址。停！stop! 上边讲到的明明知道对方的 MAC 地址就可以传输数据了，为什么现在需要两个地址呢？你给我说明白，说不明白取关！</p>
<p>上边确实是一个 MAC 地址就可以通信，但是前提是通过 ARP 协议获得的 MAC 地址，而 ARP 协议正是利用的接收端的 IP 地址才获取到接收端的 MAC 地址的，所以这两个地址很重要，那么如果实现的，下边会继续讲。</p>
<h4 id="3-1-IP-协议"><a href="#3-1-IP-协议" class="headerlink" title="3.1 IP 协议"></a>3.1 IP 协议</h4><p>IP 的数据包是直接放入到以太网数据包的“数据”部分的，这样做有一个好处就是“上层的变动完全涉及不到下层的结构”。然后数据包就变成这个样子了。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/IP%E5%8D%8F%E8%AE%AE.png?raw=true" alt></p>
<p>IP 数据包也分为标头(Head)和数据(Data)两部分。</p>
<p>  <strong>1、标头</strong></p>
<p>IP 数据包的标头是 20 ~ 60 字节，主要包括版本、IP 地址等信息。</p>
<p><strong>2、数据</strong></p>
<p>数据的最大长度为 65515 字节。整个 IP 数据包的最大总长度为 65535 字节。主要存放 IP 数据包的具体内容。</p>
<p>问题来了，以太网的数据部分最长为 1500 字节，你把一个长度为 65535 字节的 IP 数据包放到以太网的数据包汇总，不会被撑破吗？你在逗我么？确实是呀，那我们就分割数据包吧，分割成几个以太网数据包分开发送。</p>
<h4 id="3-2-AND-运算"><a href="#3-2-AND-运算" class="headerlink" title="3.2 AND 运算"></a>3.2 <strong>AND 运算</strong></h4><p>IP 协议上篇文章中最重要的作用就是判断两个设备是否属于同一子网中（同一局域网中）。</p>
<p>将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<blockquote>
<p>PS：看这篇文章之前，一定先要看之前写的入门网络分层的文章，不然会有很多疑问点。</p>
</blockquote>
<p>我们可以通过 DNS 解析知道对方的 IP ，除了判断两个计算机是否在同一局域网中，还有一个作用就是然后通过 ARP 协议获取到对方的 MAC 地址。停！真想让我取关吗？ARP 就 TN 的说了多少遍了，该详细说一下了吧？  </p>
<h4 id="3-3-ARP-协议"><a href="#3-3-ARP-协议" class="headerlink" title="3.3 ARP 协议"></a>3.3 ARP 协议</h4><blockquote>
<p>前提：对方的 IP 地址是已知的，通过 DNS 解析得到。</p>
</blockquote>
<p>ARP 协议发出一个数据包，包含在以太网的数据包中（其中包含对方的 IP 地址，对方的 MAC 地址栏是 FF:FF:FF:FF:FF:FF）。子网络中的每台主机都会收到这个包，然后从中取出 IP 地址与自身对比，如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p>
<h3 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a>4、传输层</h3><p>传输层主要涉及到两个重要协议，UDP 和 TCP 协议，上篇讲过主要用来确定端口到端口的通信，计算机中不同运行的程序端口号不相同。</p>
<p>“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023的端口被系统占用，我们只能选用大于1023 的端口。</p>
<h4 id="4-1-UDP-协议"><a href="#4-1-UDP-协议" class="headerlink" title="4.1 UDP 协议"></a>4.1 UDP 协议</h4><p>UDP 协议也分为标头(Head)和数据(Data)两部分。</p>
<p><strong>1、标头</strong></p>
<p>标头的长度为 8 字节。主要存放了发送和接收端口号。</p>
<p><strong>2、数据</strong></p>
<p>数据部分和标头部分的总长度不超过 65535 字节，正好放进一个IP数据包。</p>
<p>前边也讲过，数据包之间是包含关系的，所以 UDP 的数据包是放到 IP 数据包的“数据”部分的，IP 数据包又放在以太网数据包的“数据”部分的。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/UDP%E5%8D%8F%E8%AE%AE.png?raw=true" alt></p>
<h4 id="4-2-TCP-协议"><a href="#4-2-TCP-协议" class="headerlink" title="4.2 TCP 协议"></a>4.2 TCP 协议</h4><p>TCP 和 UDP 是相同的，上一篇讲了 UDP 和 TCP 的优缺点，TCP 保证了网络的可靠性，TCP 三次握手和四次挥手就是这部分内容。</p>
<p>TCP 的数据包和 UDP 相同嵌入在 IP 协议的“数据”部分，TCP 并没有长度限制，但是为了保证传输效率，肯定要进行限制的，TCP 的数据包的长度一般不会超过 IP 数据包的长度了，保证单个的 TCP 数据包不再进行分割。</p>
<h3 id="5、应用层"><a href="#5、应用层" class="headerlink" title="5、应用层"></a>5、应用层</h3><p>应用层是最高一层，直接面向用户，它的数据包会放在 TCP 的数据包的“数据”部分，那么整个五层的数据包就会变成一下这样。</p>
<p>  <img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE.png?raw=true" alt></p>
<p>以上五层中的内容基本讲完了，我是从下到上逐层写的，这两篇文章可以让你入门网络五层协议的基本内容了。</p>
<p>里边还有一些 DNS 解析、如何分配 IP 地址以及TCP 三次握手四次挥手后续会单独拿出来写。老规矩，点赞、转发，小鹿谢谢你的支持，我们下期再见！</p>
]]></content>
  </entry>
  <entry>
    <title>TCP 之三次握手</title>
    <url>/2020/06/28/TCP%20%E4%B9%8B%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<h2 id="动画：TCP-三次握手"><a href="#动画：TCP-三次握手" class="headerlink" title="动画：TCP 三次握手"></a>动画：TCP 三次握手</h2><h3 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h3><p>TCP 三次握手过程对于面试是必考的一个，所以不但要掌握 TCP 整个握手的过程，其中有些小细节也更受到面试官的青睐。</p>
<p>对于这部分掌握以及 TCP 的四次挥手，小鹿将会以动画的形式呈现给每个人，这样将复杂的知识简单化，理解起来也容易了很多，尤其对于一个初学者来说。</p>
<h3 id="学习导图"><a href="#学习导图" class="headerlink" title="学习导图"></a>学习导图</h3><p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt></p>
<h3 id="一、TCP-是什么？"><a href="#一、TCP-是什么？" class="headerlink" title="一、TCP 是什么？"></a>一、TCP 是什么？</h3><p><code>TCP（Transmission Control Protocol 传输控制协议）</code>是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>我们知道了上述了解到了 <code>TCP</code>的定义，通俗一点的讲，<code>TCP</code>就是一个双方通信的一个规范标准（协议）。</p>
<p>我们在学习 <code>TCP</code> 握手过程之前，首先必须了解 <code>TCP</code> 报文头部的一些标志信息，因为在 <code>TCP</code>握手的过程中，会使用到这些报文信息，如果没有掌握这些信息，在学习握手过程中，整个人处于懵逼状态，也是为了能够深入 <code>TCP</code> 三次握手的原理。</p>
<h3 id="二、TCP-头部报文"><a href="#二、TCP-头部报文" class="headerlink" title="二、TCP 头部报文"></a>二、TCP 头部报文</h3><p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E5%A4%B4%E9%83%A8%E6%8A%A5%E6%96%87.png" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E5%A4%B4%E9%83%A8%E6%8A%A5%E6%96%87.png"></p>
<h4 id="2-1-source-port-和-destination-port"><a href="#2-1-source-port-和-destination-port" class="headerlink" title="2.1 source port 和 destination port"></a>2.1 <code>source port</code> 和 <code>destination port</code></h4><blockquote>
<p>两者分别为「源端口号」和「目的端口号」。源端口号就是指本地端口，目的端口就是远程端口。</p>
</blockquote>
<p>一个数据包（<code>pocket</code>）被解封装成数据段（<code>segment</code>）后就会涉及到连接上层协议的端口问题。</p>
<p>可以这么理解，我们可以想象发送方很多的窗户，接收方也有很多的窗户，这些窗口都标有不同的端口号，源端口号和目的端口号就分别代表从哪个规定的串口发送到对方接收的窗口。不同的应用程度都有着不同的端口，之前网络分层的文章中有提到过。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E6%BA%90%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7.png" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E6%BA%90%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p>
<blockquote>
<p>扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p>
</blockquote>
<h4 id="2-2-Sequence-Numbe"><a href="#2-2-Sequence-Numbe" class="headerlink" title="2.2 Sequence Numbe"></a>2.2 <code>Sequence Numbe</code></h4><blockquote>
<p>称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。</p>
</blockquote>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/Sqn.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/Sqn.gif"></p>
<p>再通俗一点的讲，每个字段在传送中用序列号来标记自己位置的，而这个字段就是用来完成双方传输中确保字段原始位置是按照传输顺序的。（发送方是数据是怎样一个顺序，到了接受方也要确保是这个顺序）</p>
<blockquote>
<p>PS：初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)，这里后边会讲到。</p>
</blockquote>
<h4 id="2-3-Acknowledgment-Numbe"><a href="#2-3-Acknowledgment-Numbe" class="headerlink" title="2.3 Acknowledgment Numbe"></a>2.3 <code>Acknowledgment Numbe</code></h4><blockquote>
<p>称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。</p>
</blockquote>
<p>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。</p>
<p>在这里，现在我们只需知道它的作用是什么，就是在数据传输的时候是一段一段的，都是由序列号进行标识的，所以说，接收端每接收一段，之后就想要的下一段的序列号就称为「确认序列号」。</p>
<h4 id="2-4-TCP-Flag"><a href="#2-4-TCP-Flag" class="headerlink" title="2.4 TCP Flag"></a>2.4 <code>TCP Flag</code></h4><p><code>TCP</code> 首部中有 6 个标志比特，它们中的多个可同时被设置为 <code>1</code>，主要是用于操控 <code>TCP</code> 的状态机的，依次为<code>URG，ACK，PSH，RST，SYN，FIN</code>。</p>
<p>不要求初学者全部掌握，在这里只讲三个重点的标志：</p>
<h5 id="2-4-1-ACK"><a href="#2-4-1-ACK" class="headerlink" title="2.4.1 ACK"></a>2.4.1 <code>ACK</code></h5><p>这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/ACK.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/ACK.gif"></p>
<blockquote>
<p>此标志表示「应答域有效」，就是说前面所说的TCP应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</p>
</blockquote>
<h5 id="2-4-2-SYN"><a href="#2-4-2-SYN" class="headerlink" title="2.4.2 SYN"></a>2.4.2 <code>SYN</code></h5><blockquote>
<p>表示「同步序列号」，是 TCP 握手的发送的第一个数据包。</p>
</blockquote>
<p>用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。看下面动画：</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/SYN.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/SYN.gif"></p>
<h5 id="2-4-3-FIN"><a href="#2-4-3-FIN" class="headerlink" title="2.4.3 FIN"></a>2.4.3 <code>FIN</code></h5><blockquote>
<p>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。</p>
</blockquote>
<p>这个很好理解，就是说，发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了。动画如下：</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/FIN.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/FIN.gif"></p>
<h4 id="2-5-Window-size"><a href="#2-5-Window-size" class="headerlink" title="2.5 Window size"></a>2.5 <code>Window size</code></h4><p>称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。</p>
<h3 id="3、为什么进行-TCP-三次握手？"><a href="#3、为什么进行-TCP-三次握手？" class="headerlink" title="3、为什么进行 TCP 三次握手？"></a>3、为什么进行 TCP 三次握手？</h3><p>如果之前你不了解网络分层的话，建议看看写的文章。</p>
<p><font color="blue" face="黑体"><a href="[https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E5%88%92%E5%88%86%EF%BC%88%E4%B8%8A%EF%BC%89.md](https://github.com/luxiangqiang/Blog/blob/master/articel/网络原理/网络分层划分（上）.md)">网络分层协议</a></font></p>
<p>第一，为了确认双方的接收与发送能力是否正常。第二，指定自己的初始化序列号，为后面的可靠传送做准备。第三，如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<p>如果你了解 UDP 的话，TCP 的出现正式弥补了 UDP 不可靠传输的缺点。但是 TCP 的诞生，也必然增加了连接的复杂性。</p>
<h3 id="4、TCP-三次握手过程？"><a href="#4、TCP-三次握手过程？" class="headerlink" title="4、TCP 三次握手过程？"></a>4、TCP 三次握手过程？</h3><p>TCP 三次握手的过程掌握最重要的两点就是客户端和服务端状态的变化，另一个是三次握手过程标志信息的变化，那么掌握 TCP 的三次握手就简单多了。下面我们就以动画形式进行拆解三次握手过程。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%BE.png" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%BE.png"></p>
<ul>
<li><font color="#A52A2A" face="黑体"><strong>初始状态</strong></font>：客户端处于 <code>closed(关闭)</code>状态，服务器处于 <code>listen(监听)</code> 状态。</li>
</ul>
<p><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/网络原理/images/初始化状态.png" target="_blank" rel="noopener">https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E5%88%9D%E5%A7%8B%E5%8C%96%E7%8A%B6%E6%80%81.png</a></p>
<ul>
<li><font color="#A52A2A" face="黑体"><strong>第一次握手</strong></font>：客户端发送请求报文将 <code>SYN = 1</code>同步序列号和初始化序列号<code>seq = x</code>发送给服务端，发送完之后客户端处于<code>SYN_Send</code>状态。</li>
</ul>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.gif"></p>
<ul>
<li><font color="#A52A2A" face="黑体"><strong>第二次握手</strong></font>：服务端受到 <code>SYN</code> 请求报文之后，如果同意连接，会以自己的同步序列号<code>SYN(服务端) = 1</code>、初始化序列号 <code>seq = y</code>和确认序列号（期望下次收到的数据包）<code>ack = x+ 1</code> 以及确认号<code>ACK = 1</code>报文作为应答，服务器为<code>SYN_Receive</code>状态。</li>
</ul>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B.gif"></p>
<ul>
<li><font color="#A52A2A" face="黑体"><strong>第三次握手</strong></font>： 客户端接收到服务端的 <code>SYN + ACK</code>之后，知道可以下次可以发送了下一序列的数据包了，然后发送同步序列号 <code>ack = y  + 1</code>和数据包的序列号 <code>seq = x + 1</code>以及确认号<code>ACK = 1</code>确认包作为应答，客户端转为<code>established</code>状态。</li>
</ul>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif" alt="https://github.com/luxiangqiang/Blog/blob/master/articel/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/images/%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.gif"></p>
<h3 id="5、为什么不是一次、二次握手？"><a href="#5、为什么不是一次、二次握手？" class="headerlink" title="5、为什么不是一次、二次握手？"></a>5、为什么不是一次、二次握手？</h3><blockquote>
<p>防止了服务器端的一直等待而浪费资源。</p>
</blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。如果此时客户端发送的延迟的握手信息服务器收到，然后服务器进行响应，认为客户端要和它建立连接，此时客户端并没有这个意思，但 <code>server</code> 却以为新的运输连接已经建立，并一直等待 <code>client</code> 发来数据。这样，<code>server</code> 的很多资源就白白浪费掉了。</p>
]]></content>
  </entry>
  <entry>
    <title>网络分层模型划分（上）</title>
    <url>/2020/06/28/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%88%92%E5%88%86%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>整个暑假去面试，面试了很多家公司（无论是小厂还是大厂）问到的深度不同，网络原理是面试最容易问到的问题，虽然我们在项目中很少去实践它，但是了解其原理，会让我们背后网络通信是如果工作的，既能在面试官面前体现出你的基础是否扎实，也能对以后深入网络这部分学习有更多的了解。</p>
<p>很多同学面试在准备这部分的时候，都会去背，这部分确实很难掌握，我个人总结的最好的学习网络原理的方法就是不用刻意的去记忆而是完全的结合实际去讲整个原理融会贯通。虽然一开始学习起来很吃力，但是稍微用点心，多看几遍，多问自己为什么，把自己当做是开发网络原理的开发者，面试前的准备只要理清逻辑就足够了，而不是去背这部分内容。</p>
<p>而且这部分相同的知识点面试官有多种提问方式，但是其中很多都是换汤不换药。我记得最多的问的是输入URL，到页面呈现出来，其中经历了什么？这道面试题的背后，涉及到了很多网络原理的知识，我们这篇文章不会全部分享到，而是先把由来和网络层次划分弄清楚，就完成了这篇文章的目的。</p>
<h2 id="一、为什么要进行网络层次划分？"><a href="#一、为什么要进行网络层次划分？" class="headerlink" title="一、为什么要进行网络层次划分？"></a>一、为什么要进行网络层次划分？</h2><p>说到网络层次划分并不陌生，我刚刚接触到网络层次的时候一脸懵逼，这么多层，一层不就行了嘛？层与层之间好多协议，还有各种数据包，第一次我放弃了。</p>
<p>当我从新拾起网络层次的时候，我下定决心从根上理解它。首先弄明白它的原理，那必定要知道它的由来，也就是为什么要进行网络层次划分？这个问题问的好。</p>
<p>假如“小鹿”是网络的开发人员，起初认为计算机与计算机之间的通信只需要一根线就可以完成通信，对没错，但是世界那么大，那么多计算机，距离又远，不但浪费线，还没出现各种线被你偷偷剪断的情况，毋庸置疑，那计算机之间通信就不行了。（后边出来了无线网，虽然其中网关、路由之间也需要连线，但不是让每台计算机两两连接，而是一个区域为单位计算机相互连接通信）</p>
<p>不行，老板说，“小鹿”你给我想法子改，改不出来今晚不能睡觉，“小鹿”仔细想了想，这还是个技术活，需要进行全面的改进，也发现所谓的计算机之间的连线只能传送0、1信号，另一台计算并不知道那么多0、1代表什么，而且“小鹿”又发现不同厂商的生产的计算机既然有连线实现通信也是很麻烦的，干脆定义一套规则吧，无论“某硕”计算机还是“某想”计算机，都必须遵守这套规则，其实所说的这套规则就是我们经常说的“网络协议”。</p>
<p>不是说网络层次的由来吗，怎么讲到网络协议了。咱们继续，通过上面的问题，那个计算机之间通过连线传送0、1信号的问题虽然规定了通信规则，但是除了像0、1这种无意义的信号之外，网络中还存在着其他各种各样的问题，两个计算机之间怎么进行识别？以及怎么才能知道对方的地址？以及不同计算机应用程序怎么知道是给自己传递的数据，还有不同的通信数据格式怎么来规定等等一系列的问题都出来了。</p>
<p>“小鹿”发现，如果各种问题都写成一套协议来规定双方通信的规则，但是呢？万一其中哪些规则通信中出现问题，影响到了其他规则，最常见的就是数据包，一个数据包中如果包含各种各样的协议，不就乱套了。</p>
<p>“小鹿”为了能够把它设计的更好，决定采用分层划分的结构，既能规定不同层的完成的功能，又能实现层与层之间的改动而不相互影响，这就是我们经常听到网络划分层次的好处。</p>
<h2 id="二、-网络分层是如何进行分层的？"><a href="#二、-网络分层是如何进行分层的？" class="headerlink" title="二、 网络分层是如何进行分层的？"></a>二、 网络分层是如何进行分层的？</h2><p>既然我们决定要分层，那么分为几层才好呢？</p>
<p>起初网络分层是标准的七层，也就是我们所说的 OSI 七层模型。</p>
<blockquote>
<p>参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/3/16cf692d1539c275?w=359&h=534&f=png&s=79194" alt></p>
<p>我们所知道的还有 TCP/IP 四层模型和 TCP/IP 五层模型。这又是怎么出来的，其实所谓的 TCP/IP  四层模型和 TCP/IP 五层模型是以 OSI 七层优化而来，把某些层进行合并了，其实本质上还是相同的，但是我个人最喜欢用五层来解释。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/3/16cf692fc7cc96f3?w=945&h=537&f=png&s=234451" alt></p>
<h2 id="三、每一层的作用是什么？"><a href="#三、每一层的作用是什么？" class="headerlink" title="三、每一层的作用是什么？"></a>三、每一层的作用是什么？</h2><p>这一部分涉及到每一层的很多协议和知识点，但是我们这一节不具体分享，为什么？我们具体深入之前必须大脑里有个具体的网络分层结构图，先要知道每层是做什么的，层与层之间的关系，然后下一节再深入每层中的每个协议怎么通信的，这样的好处学起来条理清晰，而不至于当时我学习的时候表面还不懂，就深入最后懵逼状态。</p>
<h3 id="3-1-物理层"><a href="#3-1-物理层" class="headerlink" title="3.1 物理层"></a>3.1 物理层</h3><p>物理层，顾名思义，用物理手段将电脑连接起来，就像我们上边讲到的计算机之间的物理连线。主要用来传输0、1信号，上边也分析过了，0、1信号毕竟没有任何的现实意义，所有我们用另一层用来规定不同0、1组合的意义是什么。</p>
<h3 id="3-2-数据链路层"><a href="#3-2-数据链路层" class="headerlink" title="3.2 数据链路层"></a>3.2 数据链路层</h3><p>下层的物理层既然不能规定不同0、1组合的信号代表什么意义，那么我们在数据链路层规定一套协议，专门的给0、1信号进行分组，以及规定不同的组代表什么意思，从而双方计算机都能够进行识别，这个协议就是“以太网协议”（具体的以太网协议内容下节内容详细讲解）。</p>
<p>但是问题又来了，我们要发送给对方计算机，怎么标识对方以及怎么知道对方的地址呢？</p>
<h4 id="3-2-1-MAC-地址"><a href="#3-2-1-MAC-地址" class="headerlink" title="3.2.1 MAC 地址"></a>3.2.1 MAC 地址</h4><p>我们所说的MAC地址到底的作用是啥？说白了它就是作为网络中计算机设备的唯一标识，从计算机在厂商生产出来就被十六进制的数标识为MAC地址。</p>
<p>既然我们知道了用MAC地址作为标识，那么怎么才能知道我们要进行通信的计算机MAC地址呢？</p>
<h4 id="3-2-2-广播"><a href="#3-2-2-广播" class="headerlink" title="3.2.2 广播"></a>3.2.2 广播</h4><p>这里广播详细的在下一节讲，这一节你只需要知道广播可以帮助我们能够知道对方的 MAC 地址。那么既然知道了MAC地址就可以通信了？没有想得那么简单，广播中还存在两种情况，一种是，在同一子网络下（同一局域网下）的计算机是通过 ARP 协议获取到对方 MAC地址的。不同自网络中（不同局域网）中是交给两个局域网的网关（路由器）去处理的。这里边涉及到很多细节的知识，都会集中到下一节，但是这一节你了解怎么进行标识计算机和怎么获取到MAC地址就可以了。</p>
<h3 id="3-3-网络层"><a href="#3-3-网络层" class="headerlink" title="3.3 网络层"></a>3.3 网络层</h3><p>物理层和数据链路层都有自己的事情要做，也就是我们上边所讲到的这些（里边很多细节不在这节多说）。上边两层在我看来可以完成正常通信了，那么网络层出来干啥子？</p>
<p>网络层的由来是因为在数据链路层中我们说说两台计算机之间的通信是分为同一子网络和不同子网络之间，那么问题就来了，怎么判断两台计算机是否在同一子网络（局域网）中？这就是网络层要解决的问题。</p>
<h4 id="3-3-1-IP-协议"><a href="#3-3-1-IP-协议" class="headerlink" title="3.3.1 IP 协议"></a>3.3.1 IP 协议</h4><p>我们通常用到的 IP 地址，就是网络层中的东西，所规定的的协议就是 IP 协议。很多小伙伴问，IP 地址想必也是地址吧，上边都有唯一标识的 MAC 地址了，IP 地址出来是混饭吃的？为了能够让大家更方便的理解 IP 地址和 MAC 地址，我们可以将 IP 地址抽象成一种逻辑上的地址，也就是说 MAC 地址是物理上的地址，就是定死了。IP 地址呢，是动态分配的，不是固定死的。</p>
<p>我们就是通过 IP 地址来判断两个计算机设备是否在同一子网络中的，那么你会问它是怎么判断的，以及 IP 地址谁给他分配的？又是如何分配的等一些列问题，我们不着急，这里只说一下大体的流程，详细会后续写一大篇。</p>
<p>既然我们通过 IP 地址来判断两个计算机是否处于同一局域网中，那么首先要知道对方的 IP 地址吧？DNS 解析想必大家都知道，可以将域名解析为 IP 地址。好了，我们知道两台计算机的 IP 地址了，怎么进行判断是否同一局域网中？</p>
<h4 id="3-3-2-子网掩码"><a href="#3-3-2-子网掩码" class="headerlink" title="3.3.2 子网掩码"></a>3.3.2 子网掩码</h4><p>嘿嘿，又是一个只听说过，但是不知道这个什么作用的一个名词，没事，等我聊完，你就明白是做什么的了。</p>
<p>子网掩码就是用来标识同一局域网中的 IP 地址的信息的？什么信息？IP 地址是由 32 个二进制位组成的，也就是四个十进制（如：255.255.255.000）。</p>
<p>子网掩码也是由 32 个二进制位组成的，但是只能用 0 或 1 来表示，如11111111.11111111.11111111.00000000。</p>
<p>到底什么意思呢？有 1 的部分表示网络部分，有 0 表示主机部分，这和判断两台计算机是否在同一局域网中有什么关系？没错，是有关系的！两台计算机的 IP 地址分别和子网掩码进行一种运算（AND 运算），如果结果相同，两台计算机就在同一局域网中，否则就不在同一局域网中。</p>
<p>AND 是如何进行运算的，IP 的数据包的组成等问题，不在这里多陈述。</p>
<h3 id="3-4-传输层"><a href="#3-4-传输层" class="headerlink" title="3.4 传输层"></a>3.4 传输层</h3><p>好了，如果你认为计算机可以进行通信了，那么“小鹿”恭喜你，你已经基本知道了以上几层划分的作用，但是如果你正在一边打 LOL，一边和朋友在 QQ 聊天，突然，游戏中队友聊天信息出现在了 QQ 窗口中，咦？出现了什么情况?</p>
<p>其实是以上层级还是不够，出现上边的原因就是，两台计算机虽然可以通信了，但是每天计算机运行着好多的程序，谁知道你们传输的信息是属于哪些程序的，怨不得 LOL 的聊天信息跑到了 QQ 窗口中。</p>
<p>想必大家猜到了传输层主要用来干啥滴，是的，传输层的主要功能就是为了能够实现“端口到端口”的通信。计算机上运行的不同程序都会分配不同的端口，所以才能使得数据能够正确的传送给不同的应用程序。</p>
<h4 id="3-4-1-UDP-协议"><a href="#3-4-1-UDP-协议" class="headerlink" title="3.4.1 UDP 协议"></a>3.4.1 UDP 协议</h4><p>加入端口号也需要一套规则，那就是 UDP 协议，但是 UDP协议有个缺点，一旦进行通信，就不知道对方是否接收到数据了，我们再定义一套规则，让其可以和对方进行确认，那么 TCP 出现了。</p>
<h4 id="3-4-2-TCP-协议"><a href="#3-4-2-TCP-协议" class="headerlink" title="3.4.2 TCP 协议"></a>3.4.2 TCP 协议</h4><p>我们通常说 TCP 三次握手和四次挥手，没错，这就是传输层中完成的，TCP 三次握手涉及到的内容贼多，都可以单独写一篇长文，这里不多陈述，知道它是在传输层中完成的以及它的作用是什么，能够认识到它就好了。</p>
<h3 id="3-5-应用层协议"><a href="#3-5-应用层协议" class="headerlink" title="3.5 应用层协议"></a>3.5 应用层协议</h3><p>“喂，你发给我的是什么破数据，乱七八糟的，我TM能解析吗？能不能按照我的规定给我传送？“</p>
<p>“好的，下次不敢了”</p>
<p>想必大家已经猜到了应用层的协议，应用层的功能就是规定了应用程序的数据格式。我们经常用得到的电子邮件、HTTP协议、以及FTP数据的格式，就是在应用层定义的。</p>
<p><strong>如果觉得本文对你有帮助，点个star，我希望能够让更多处在递归困惑的人看到，谢谢各位支持！</strong>下一篇我打算出一篇完整关于链表的文章，终极目标：将数据结构与算法每个知识点写成一系列的文章。</p>
<p><strong>下一篇：</strong> <a href="https://github.com/luxiangqiang/Blog/blob/master/articel/网络原理/网络层次模型划分（下）.md" target="_blank" rel="noopener">网络层次模型划分（下）</a></p>
<hr>
**作者: 小鹿**

<p><strong>原创公众号：小鹿动画学编程。</strong></p>
<p><strong>简介：</strong> 和小鹿同学一起用动画的方式从零基础学编程，将 Web前端领域、数据结构与算法、网络原理等通俗易懂的呈献给小伙伴。先定个小目标，原创 1000 篇的动画技术文章，和各位小伙伴共同努力一起学习！</p>
]]></content>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/02/18/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li>进程：操作系统进行资源分配和调度的一个独立单位</li>
<li>线程：cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位</li>
<li>进程在运行时各自内存单元相互独立，线程在运行时之间内存共享  </li>
<li>比如网易云音乐和腾讯视频是两个不同的进程；而网易云音乐中你可以听歌的同时发表对歌曲的评论，这是两个不同的线程</li>
</ul>
<h3 id="启动一个线程是调用-run-方法还是-start-方法"><a href="#启动一个线程是调用-run-方法还是-start-方法" class="headerlink" title="启动一个线程是调用 run()方法还是 start()方法"></a>启动一个线程是调用 run()方法还是 start()方法</h3><ul>
<li>启动一个线程是调用 start()方法</li>
<li>start()执行后使线程处于可运行状态，这意味着它可以由 JVM 调度并执行，但不表示线程就会立即运行</li>
<li>run()方法是线程启动后(真正执行后)要进行回调的方法</li>
</ul>
<h3 id="同步线程及线程调度相关的方法"><a href="#同步线程及线程调度相关的方法" class="headerlink" title="同步线程及线程调度相关的方法"></a>同步线程及线程调度相关的方法</h3><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁   </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常   </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，</li>
<li>而是由 JVM 确定唤醒哪个线程，而且与优先级无关  </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</li>
</ul>
<h3 id="java-中-wait-和-sleep-方法的不同"><a href="#java-中-wait-和-sleep-方法的不同" class="headerlink" title="java 中 wait 和 sleep 方法的不同"></a>java 中 wait 和 sleep 方法的不同</h3><ul>
<li>wait 会释放锁，wait 通常被用于线程间交互</li>
<li>sleep 一直持有锁，sleep 通常被用于暂停执行</li>
</ul>
<h3 id="synchronized-和-volatile-关键字的作用和区别"><a href="#synchronized-和-volatile-关键字的作用和区别" class="headerlink" title="synchronized 和 volatile 关键字的作用和区别"></a>synchronized 和 volatile 关键字的作用和区别</h3><ul>
<li>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。  </li>
<li>volatile 仅能使用在变量级别，仅能实现变量的修改可见性，并不能保证原子性</li>
<li>volatile 不会造成线程的阻塞</li>
<li>synchronized 可以使用在变量、方法、和类级别 ，synchronized 可以保证变量的修改可见性和原子性</li>
<li>synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="线程池的理解"><a href="#线程池的理解" class="headerlink" title="线程池的理解"></a>线程池的理解</h2><p>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节<br>省了开辟子线程的时间，提高的代码执行效率。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任常务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<h3 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h3><ol>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。  </li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。    </li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。  </li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求   </li>
</ol>
<h3 id="JDK-的-java-util-concurrent-Executors-中提供了生成多种线程池的静态方法"><a href="#JDK-的-java-util-concurrent-Executors-中提供了生成多种线程池的静态方法" class="headerlink" title="JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法"></a>JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法</h3><pre><code>1. ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
2. ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);
3. ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);
4. ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</code></pre><h3 id="线程池的执行策略"><a href="#线程池的执行策略" class="headerlink" title="线程池的执行策略"></a>线程池的执行策略</h3><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义###"></a>死锁定义###</h3><p>指多个线程因竞争资源而造成的一种僵局（互相等待）</p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol>
<li>互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待</li>
<li>不剥夺条件：资源不可被剥夺，即只能由获得该资源的线程自己来释放（只能是主动释放)</li>
<li>请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</li>
<li>循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul>
<li>控制加锁顺序（线程按照一定的顺序加锁）</li>
<li>控制加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>
</ul>
<h3 id="多线程间的通信怎么实现"><a href="#多线程间的通信怎么实现" class="headerlink" title="多线程间的通信怎么实现"></a>多线程间的通信怎么实现</h3><ol>
<li>共享变量：线程间通信可以通过发送信号，发送信号的一个简单方式是在共享对象的变量里设置信号值</li>
<li>wait/notify机制：以资源为例，生产者生产一个资源，通知消费者就消费掉一个资源，生产者继续生产资源，消费者消费资源</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2020/02/18/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="java异常分类"><a href="#java异常分类" class="headerlink" title="java异常分类"></a>java异常分类</h3><ul>
<li>异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception。   </li>
<li>Error 一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。  </li>
<li>Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常。  </li>
<li>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；  </li>
<li>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够</li>
</ul>
<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><ul>
<li>Error类异常的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</li>
<li>Exception类应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li>
<li>Exception中的普通异常必须 try..catch 处理或用 throws 声明继<br>续抛给上层调用方法处理，否则编译不会通过，所以普通异常也称为 checked 异常</li>
<li>Exception中的系统异常，可以处理也可以不处理，编译时不会报错，但运行可能出错</li>
</ul>
<h3 id="最常见的-5-个-RuntimeException"><a href="#最常见的-5-个-RuntimeException" class="headerlink" title="最常见的 5 个 RuntimeException"></a>最常见的 5 个 RuntimeException</h3><ol>
<li>java.lang.NullPointerException 空指针异常</li>
<li>java.lang.IndexOutOfBoundsException 数组角标越界异常</li>
<li>java.lang.ClassCastException 数据类型转换异常</li>
<li>java.lang.NumberFormatException 字符串转换为数字异常</li>
<li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误</li>
<li>java.lang.IllegalArgumentException 方法传递参数错误</li>
</ol>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><ol>
<li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。</li>
<li>throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。  <h4 id="throws："><a href="#throws：" class="headerlink" title="throws："></a>throws：</h4></li>
<li>throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。  </li>
<li>throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。 </li>
<li>throws 表示出现异常的一种可能性，并不一定会发生这种异常。</li>
</ol>
<h3 id="调用下面的方法，得到的返回值是什么？"><a href="#调用下面的方法，得到的返回值是什么？" class="headerlink" title="调用下面的方法，得到的返回值是什么？"></a>调用下面的方法，得到的返回值是什么？</h3><blockquote>
<pre><code>1.public int getNum(){
2. try {
3. int a = 1/0;
4. return 1;
5. } catch (Exception e) {
6. return 2;
7. }finally{
8. return 3;
9. }</code></pre></blockquote>
<p>方法执行完返回3<br>在 catch 中遇到了 return 或者异常等能使该函数终止的话<br>那么有 finally 就必须先执行完 finally 代码块里面的代码</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/02/18/Java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h1><p><strong>final：java中的关键字，修饰符</strong></p>
<p>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.</p>
<ul>
<li>被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 </li>
<li>被声明final的方法只能使用，不能重载。</li>
</ul>
<p><strong>finally：java的一种异常处理机制。</strong></p>
<p>finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</p>
<p><strong>finalize：Java中的一个方法名</strong></p>
<p>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。<strong>finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p>
<p>  <strong>对象的销毁过程</strong> </p>
<p>在对象的销毁过程中，按照对象的finalize的执行情况，可以分为以下几种，系统会记录对象的对应状态：</p>
<ul>
<li>unfinalized 没有执行finalize，系统也不准备执行。 </li>
<li>finalizable 可以执行finalize了，系统会在随后的某个时间执行finalize。 </li>
<li>finalized 该对象的finalize已经被执行了。 </li>
</ul>
<p>GC怎么来保持对finalizable的对象的追踪呢。GC有一个Queue，叫做F-Queue，所有对象在变为finalizable的时候会加入到该Queue，然后等待GC执行它的finalize方法。 </p>
<p>这时我们引入了对对象的另外一种记录分类，系统可以检查到一个对象属于哪一种。<br>reachable 从活动的对象引用链可以到达的对象。包括所有线程当前栈的局部变量，所有的静态变量等等。<br>finalizer-reachable 除了reachable外，从F-Queue可以通过引用到达的对象。<br>unreachable 其它的对象。 </p>
<p>1 首先，所有的对象都是从Reachable+Unfinalized走向死亡之路的。 </p>
<p>2 当从当前活动集到对象不可达时，对象可以从Reachable状态变到F-Reachable或者Unreachable状态。 </p>
<p>3 当对象为非Reachable+Unfinalized时，GC会把它移入F-Queue，状态变为F-Reachable+Finalizable。 </p>
<p>4 好了，关键的来了，任何时候，GC都可以从F-Queue中拿到一个Finalizable的对象，标记它为Finalized，然后执行它的finalize方法，由于该对象在这个线程中又可达了，于是该对象变成Reachable了（并且Finalized）。而finalize方法执行时，又有可能把其它的F-Reachable的对象变为一个Reachable的，这个叫做对象再生。 </p>
<p>5 当一个对象在Unreachable+Unfinalized时，如果该对象使用的是默认的Object的finalize，或者虽然重写了，但是新的实现什么也不干。为了性能，GC可以把该对象之间变到Reclaimed状态直接销毁，而不用加入到F-Queue等待GC做进一步处理。 </p>
<p>6 从状态图看出，不管怎么折腾，任意一个对象的finalize只至多执行一次，一旦对象变为Finalized，就怎么也不会在回到F-Queue去了。当然没有机会再执行finalize了。 </p>
<p>7 当对象处于Unreachable+Finalized时，该对象离真正的死亡不远了。GC可以安全的回收该对象的内存了。进入Reclaimed。 </p>
<h1 id="二、Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#二、Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="二、Java中的String，StringBuilder，StringBuffer三者的区别"></a>二、Java中的String，StringBuilder，StringBuffer三者的区别</h1><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> System.out.println(str);</span><br><span class="line"><span class="number">3</span> str=str+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">4</span> System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，<strong>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</strong></p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">2</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line"><span class="number">3</span> System.out.println(str);</span><br><span class="line"><span class="number">4</span> System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>

<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">2 String str2&#x3D;&quot;de&quot;;</span><br><span class="line">3 String str&#x3D;str1+str2;</span><br></pre></td></tr></table></figure>

<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>　　2. 再来说线程安全</p>
<p>　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>　　3. 总结一下<br>　　<strong>String：适用于少量的字符串操作的情况</strong></p>
<p>　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
<h1 id="三、Arrays-sort-实现原理和-Collections-sort-实现原理"><a href="#三、Arrays-sort-实现原理和-Collections-sort-实现原理" class="headerlink" title="三、Arrays.sort 实现原理和 Collections.sort 实现原理"></a>三、Arrays.sort 实现原理和 Collections.sort 实现原理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://mycsdnblog.work/201919061054-m.png" alt="1551191608732"></p>
<h1 id="四、Java中boolean占几个字节"><a href="#四、Java中boolean占几个字节" class="headerlink" title="四、Java中boolean占几个字节"></a>四、Java中boolean占几个字节</h1><p>JVM规范指出boolean当做int处理，也就是4字节，boolean数组当做byte数组处理，这样我们可以得出boolean类型占了单独使用是4个字节，在数组中是确定的1个字节。</p>
<h1 id="五、Java基本类型所占的字节"><a href="#五、Java基本类型所占的字节" class="headerlink" title="五、Java基本类型所占的字节"></a>五、Java基本类型所占的字节</h1><p><img src="/.com//1551592963527.png" alt="1551592963527"></p>
<h1 id="六、Java的虚函数"><a href="#六、Java的虚函数" class="headerlink" title="六、Java的虚函数"></a>六、Java的虚函数</h1><p><strong>java类中普通成员函数就是虚函数。</strong></p>
<p>JAVA中的函数，除非声明为static或final，都可以看做是虚的，因为它们都是动态绑定的</p>
<p><strong>会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape1 = circle;</span><br><span class="line">        Shape shape2 = square;</span><br><span class="line">        shape1.draw();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、“方法”"><a href="#七、“方法”" class="headerlink" title="七、“方法”"></a>七、“方法”</h1><h2 id="7-1-Object中的方法"><a href="#7-1-Object中的方法" class="headerlink" title="7.1 Object中的方法"></a>7.1 Object中的方法</h2><p><img src="/.com//1561973717974.png" alt="1551439525914"></p>
<h2 id="7-2-String中常用的方法"><a href="#7-2-String中常用的方法" class="headerlink" title="7.2 String中常用的方法"></a>7.2 String中常用的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类中的方法。</span><br><span class="line">length()</span><br><span class="line">isEmpty()</span><br><span class="line">equals()</span><br><span class="line">toCharArray()</span><br><span class="line">valueOf()</span><br><span class="line">intern()</span><br><span class="line">compareTo()</span><br><span class="line">subString()</span><br><span class="line">contains()</span><br><span class="line">split()</span><br><span class="line">trim()</span><br><span class="line">toLowerCase()</span><br><span class="line">toUpperCase()</span><br><span class="line">startsWith()</span><br></pre></td></tr></table></figure>

<h1 id="八、Java中的浅拷贝和深拷贝"><a href="#八、Java中的浅拷贝和深拷贝" class="headerlink" title="八、Java中的浅拷贝和深拷贝"></a>八、Java中的浅拷贝和深拷贝</h1><h2 id="8-1-浅拷贝"><a href="#8-1-浅拷贝" class="headerlink" title="8.1 浅拷贝"></a>8.1 浅拷贝</h2><h3 id="8-1-1-基本概念"><a href="#8-1-1-基本概念" class="headerlink" title="8.1.1 基本概念"></a>8.1.1 基本概念</h3><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p>
<p>②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>具体模型如图所示：可以看到基本数据类型的成员变量，对其值创建了新的拷贝。而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。</p>
<p><img src="http://mycsdnblog.work/201919141921-T.png" alt></p>
<h3 id="8-1-2-实现方式"><a href="#8-1-2-实现方式" class="headerlink" title="8.1.2 实现方式"></a>8.1.2 实现方式</h3><blockquote>
<p><strong>通过拷贝构造方法实现浅拷贝</strong></p>
</blockquote>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(p1);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = person.age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = person.age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://mycsdnblog.work/201919141948-H.png" alt></p>
<p>结果分析：</p>
<p><strong>age为引用类型，age2为基本类型</strong></p>
<p>修改p1的age，p2的age也随之改变</p>
<p>修改p1的age2，p2的age2不变。</p>
<blockquote>
<p><strong>通过重写clone()方法进行浅拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919141953-J.png" alt></p>
<h2 id="8-2-深拷贝"><a href="#8-2-深拷贝" class="headerlink" title="8.2 深拷贝"></a>8.2 深拷贝</h2><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。<strong>那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象</strong>。<strong>也就是说，对象进行深拷贝要对整个对象图进行拷贝！</strong></p>
<p><strong>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</strong></p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="http://mycsdnblog.work/201919141955-9.png" alt></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h3 id="8-2-2-实现方式"><a href="#8-2-2-实现方式" class="headerlink" title="8.2.2 实现方式"></a>8.2.2 实现方式</h3><blockquote>
<p><strong>通过重写clone方法来实现深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        person.setAge((Age) person.getAge().clone());</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142004-2.png" alt></p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<blockquote>
<p><strong>通过序列化的方式进行深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(p1);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        Person p2 = (Person) objectInputStream.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142017-F.png" alt></p>
<h1 id="九、Java中的权限"><a href="#九、Java中的权限" class="headerlink" title="九、Java中的权限"></a>九、Java中的权限</h1><p>​       1、私有权限（private）</p>
<p>　　private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。</p>
<p>　　2、默认权限（default）</p>
<p>　　类，数据成员，构造方法，方法成员，都能够使用默认权限，<strong>即不写任何关键字</strong>。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。</p>
<p>　　3、受保护权限（protected）</p>
<p>　　protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</p>
<p>　　4、公共权限（public）</p>
<p>　　public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。  </p>
<h1 id="十、一个class文件中可以有几个类"><a href="#十、一个class文件中可以有几个类" class="headerlink" title="十、一个class文件中可以有几个类"></a>十、一个class文件中可以有几个类</h1><p>可以有多个类，但是：</p>
<p>1.public 权限的类只能有一个（也可以一个都没有，但最多只有1个）<br>2.这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）<br>3.若这个文件中没有public的类，则文件名随便是一个类的名字即可<br>4.你用Javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件</p>
<h1 id="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"><a href="#十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类" class="headerlink" title="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"></a>十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类</h1><p>1.抽象类和接口类的对比：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>抽象类</strong></th>
<th align="center"><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与正常Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center"><strong>它比接口速度要快</strong></td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>2.什么时候使用抽象类和接口</p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<p>3.Java8的改进</p>
<p>接口中可以声明default方法。default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</p>
<p>如果一个类实现了两个接口（可以看做是“多继承”），这两个接口又同时都包含了一个名字相同的default方法，那么会发生什么情况？ 在这样的情况下，编译器会报错。让我用例子来解释一下：</p>
<p><img src="http://mycsdnblog.work/201919122049-L.png" alt></p>
<h1 id="十二、自然排序和定制排序"><a href="#十二、自然排序和定制排序" class="headerlink" title="十二、自然排序和定制排序"></a>十二、自然排序和定制排序</h1><p>自然排序是通过实现了的Comparable来进行的</p>
<p>定制排序是实现Comparator</p>
<h1 id="十四、equals和hashcode的区别以及联系"><a href="#十四、equals和hashcode的区别以及联系" class="headerlink" title="十四、equals和hashcode的区别以及联系"></a>十四、equals和hashcode的区别以及联系</h1><p>1.equals方法</p>
<p>自反性 ： x.equals(x) 结果应该返回true。</p>
<p>对称性 ： x.equals(y) 结果返回true当且仅当y.equals(x)也应该返回true。</p>
<p>传递性 ： x.equals(y) 返回true，并且y.equals(z) 返回true，那么x.equals(z) 也应该返回true。</p>
<p>一致性 ： x.equals(y)的第一次调用为true，那么x.equals(y)的第二次，第三次等多次调用也应该为true，但是前提条件是在进行比较之前，x和y都没有被修改。</p>
<p>x.equals(null) 应该返回false。</p>
<p>这个方法返回true当且仅当x和y指向了同样的对象(x==y)，这句话也就是说明了在默认情况下，<strong>Object类中的equals方法默认比较的是对象的地址，因为只有是相同的地址才会相等(x == y)，如果没有重写equals方法，那么默认就是比较的是地址。</strong>注意：<strong>无论何时这个equals方法被重写那么都是有必要去重写hashCode方法，这个是因为为了维持hashCode的一种约定，相同的对象必须要有相同的hashCode值。</strong></p>
<p>2.hashcode</p>
<p>在同一次的java程序应用过程中，对应同样的对象多次调用hashCode方法，hashCode方法必须一致性的返回同样的一个地址值，前提是这个对象不能改变</p>
<p>两个对象相同是依据equals方法来的，那么其中的每一个对象调用hashCode方法都必须返回相同的一个integer值，也就是对象的地址。equals方法相等，那么hashCode方法也必须相等。</p>
<p>如果两个对象依据equals方法返回的结果不相等，那么对于其中的每一个对象调用hashCode方法返回的结果也不是一定必须得相等（也就是说，equals方法的结果为false，那么hashCode方法返回的结果可以相同也可以不相同），但是，对于我们开发者来说，针对两个对象的不相等如果生成相同的hashCode则可以提高应用程序的性能。</p>
<p>​         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p>
<p>​         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
<p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 </p>
<p><strong>并不是所有重写equals()的时候都要重写hashCode()，如果不涉及到哈希表的话，就不需要了。</strong></p>
<h1 id="十五：自动装箱与拆箱"><a href="#十五：自动装箱与拆箱" class="headerlink" title="十五：自动装箱与拆箱"></a>十五：自动装箱与拆箱</h1><h2 id="15-1-基本概念"><a href="#15-1-基本概念" class="headerlink" title="15.1 基本概念"></a>15.1 基本概念</h2><p>装箱：将基本类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>如何实现?</p>
<p>拿Integer来举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = integer; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p><strong>装箱：主要调用的是Integer的valueOf(int)方法</strong></p>
<p><strong>拆箱：自动调用Integer的intValue方法</strong></p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
<ol>
<li><p>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。</p>
</li>
<li><p><strong>Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。</strong></p>
</li>
<li><p>new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。</p>
</li>
</ol>
<h2 id="15-2-实战"><a href="#15-2-实战" class="headerlink" title="15.2 实战"></a>15.2 实战</h2><h3 id="15-2-1-示例1"><a href="#15-2-1-示例1" class="headerlink" title="15.2.1 示例1"></a>15.2.1 示例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果为：</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-示例2"><a href="#15-2-2-示例2" class="headerlink" title="15.2.2 示例2"></a>15.2.2 示例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double a = <span class="number">100.0</span>;</span><br><span class="line">        Double b = <span class="number">100.0</span>;</span><br><span class="line">        Double c = <span class="number">200.0</span>;</span><br><span class="line">        Double d = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>false<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。</p>
<p>很简单：<strong>在某个范围内的整型数值的个数是有限的，而浮点数却不是</strong>。</p>
<p>注意：</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double、Float的valueOf方法的实现是类似的。</li>
</ul>
<h1 id="十六、equals和"><a href="#十六、equals和" class="headerlink" title="十六、equals和=="></a>十六、equals和==</h1><p>==：判断两个对象的地址是否相等，基本类型就是判断值是否相等</p>
<p>equals：类没有重写equals方法，等价于==；覆盖的话就是比较两个对象的内容</p>
<h1 id="十七：Java闭包和回调"><a href="#十七：Java闭包和回调" class="headerlink" title="十七：Java闭包和回调"></a>十七：Java闭包和回调</h1><ul>
<li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</li>
<li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。</li>
</ul>
<p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p>
<p>在Java中，闭包是 通过“接口与内部类实现的”</p>
<p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”来实现，因为对于非静态内部类而言，它不仅记录了其外部类的详细信息，还保留了一个创建非静态内部类的引用，通过它可以访问外部类的私有成员，因此可以把非静态内部类当成面向对象领域的闭包。那么，通过这种仿闭包的非静态内部类可以很方便地实现回调，这是一种非常灵活的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-13 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 测试闭包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClosure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> Food();</span><br><span class="line">        food.getEat().eat();</span><br><span class="line">        food.getNum();</span><br><span class="line"></span><br><span class="line">        Food pub = <span class="keyword">new</span> Food();</span><br><span class="line">        Food.EatActive eatActive = pub.<span class="keyword">new</span> EatActive();</span><br><span class="line">        eatActive.eat();</span><br><span class="line">        pub.getNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"food"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"my food"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Active <span class="title">getEat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatActive</span> <span class="keyword">implements</span> <span class="title">Active</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"no"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Active</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包(closure)是一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域.</p>
<h1 id="十八、hashCode"><a href="#十八、hashCode" class="headerlink" title="十八、hashCode"></a>十八、hashCode</h1><p>hashCode就是根据存储在一个对象实例中的所有数据，提取出一个<strong>32</strong>位的整数，该整数的目的是用来标示该实例的唯一性，有点类似于MD5码，每个文件都能通过MD5算法生成一个唯一的MD5码。</p>
<h1 id="十九、Math-abs"><a href="#十九、Math-abs" class="headerlink" title="十九、Math.abs"></a>十九、Math.abs</h1><p>Java的API文档中说，对abs(int a)运算，“如果参数等于 Integer.MIN_VALUE 的值(即能够表示的最小负 int 值)，那么结果与该值相同且为负。</p>
<h1 id="二十、static关键字"><a href="#二十、static关键字" class="headerlink" title="二十、static关键字"></a>二十、static关键字</h1><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，<strong>它当且仅当在类初次加载时会被初始化</strong>。<strong>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</strong>。</p>
<p><strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong>。</p>
<h1 id="二十一、Collection和Collections的区别"><a href="#二十一、Collection和Collections的区别" class="headerlink" title="二十一、Collection和Collections的区别"></a>二十一、Collection和Collections的区别</h1><p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p> Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p>
<p>2、Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<h1 id="二十二、Overload和Override的区别？"><a href="#二十二、Overload和Override的区别？" class="headerlink" title="二十二、Overload和Override的区别？"></a>二十二、Overload和Override的区别？</h1><p> Overload是重载的意思，Override是覆盖的意思，也就是重写。</p>
<p>​    重载Overload：在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。</p>
<p>​    重载的特点：与返回值类型无关，只看参数列表。</p>
<p>​    重写Override表示子类中的方法可以与父类中的某个方法的<strong>名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中定义的那个完全相同的方法给覆盖掉了，这也是面向对象编程的多态的一种表现。子类覆盖父类方法时只能抛出父类的异常或者异常的子类或者父类异常的子集，因为子类可以解决父类的一些问题，但不能比父类有更多的问题。还有，子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，则子类中根本不存在覆盖，即子类中和父类的private的同名的方法没有覆盖的关系，因为private的访问权限只限于同一类中，而子类就不会访问到private的方法，所以是子类中增加的一个全新的方法。</p>
<p>​    <strong>重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法是可以改变返回值类型的</strong>。所以，如果两个方法的参数列表完全一样，是不能通过让他们的返回值类型不同来实现重载的。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<h1 id="二十三、Java参数是值传递还是引用传递"><a href="#二十三、Java参数是值传递还是引用传递" class="headerlink" title="二十三、Java参数是值传递还是引用传递"></a>二十三、Java参数是值传递还是引用传递</h1><p><strong>值传递</strong></p>
<p><strong>Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</strong></p>
<h1 id="二十四、final关键字对类、方法和成员变量的修饰"><a href="#二十四、final关键字对类、方法和成员变量的修饰" class="headerlink" title="二十四、final关键字对类、方法和成员变量的修饰"></a>二十四、final关键字对类、方法和成员变量的修饰</h1><ol>
<li>final修饰类 </li>
</ol>
<p>被修饰的类不能被继承，也没有子类。假如随意创建这些类的子类，子类可能会错误的修改父类的实现细节、出于安全原因，类的实现细节不允许有任何改动、在创建对象模型的时候，确信这个类不会再被扩展。<strong>注：如果对一个已经被final修饰的类进行继承操作，则会在编译的期间直接出现错误</strong></p>
<ol start="2">
<li>final修饰方法</li>
</ol>
<p>final修饰的方法表示此方法已经是“最后的、最终的”含义，<strong>亦即此方法不能被重写</strong>，（但是可以载多个final修饰的方法）。</p>
<p>需要注意的一点是: 重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法的访问权限是private，将会导致子类不能直接继承到此方法，这时候再在子类中定义相同的方法名和参数，不会产生重写与final之间出现的矛盾，而是在子类中定义了新的方法。</p>
<ol start="3">
<li>final修饰变量</li>
</ol>
<p><strong>final修饰的变量表示此变量是“最后的、最终的”,一旦定义了final变量，并在首次为其显示进行了初始化之后，final修饰的变量值不可被再修改。</strong></p>
<p>final修饰的变量，无论是类属性、对象属性、形参还是局部变量，这些变量都是需要进行显示初始化（即为其显示指定初始值）。</p>
<p><strong>另外，无论对于基本数据类型还是引用数据类型，final修饰的变量都是首次初始化后值都不能修改。对于基本数据类型，很好理解。对于引用数据类型，引用变量指向的是实际的对象，但其存储的是所指向对象的地址，因此，其值不能修改并不意味着其所指向的对象不能修改。</strong> </p>
<h1 id="二十五、整型转字符串"><a href="#二十五、整型转字符串" class="headerlink" title="二十五、整型转字符串"></a>二十五、整型转字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">String string = String.valueOf(i);</span><br><span class="line">String string2 = <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">String string3 = i.toString();</span><br></pre></td></tr></table></figure>

<h1 id="二十六、Java中的异常"><a href="#二十六、Java中的异常" class="headerlink" title="二十六、Java中的异常"></a>二十六、Java中的异常</h1><p>采用的设计模式是：<strong>责任链模式</strong></p>
<p>Java有两种异常类型：<strong>受检查异常和运行时异常</strong></p>
<p>检查异常：<strong>这些异常从程序的角度来说是必须经过捕捉处理的，否则编译通不过，</strong>比如IOException，SQLException。</p>
<p>运行时异常（不受检查异常）：Error和运行时异常</p>
<p>Error是程序无法处理的，如：OutOfMemmoryError，如果出现Error，Java虚拟机就会终止线程。</p>
<p><strong>运行时异常：如RunTimeException，IndexOutOfBoundsException，NullPointerException，这些异常一般是由程序的逻辑错误引起的，解决此类异常应该仔细排查程序，不需要进行检查。</strong></p>
<p><strong>两者的区别：</strong></p>
<p>非检查异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。</p>
<p><strong>受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。</strong></p>
<p>对于运行异常，建议不要用 try…catch…捕获处理，应该在程序开发调试的过程中尽量的避免，当然有一些必须要处理的，自己知道了那个部分会出现异常，而这种异常你要把它处理的你想要的结果，例如：空值处理。</p>
<p><img src="http://mycsdnblog.work/201919152249-a.png" alt></p>
<p>1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；</p>
<p><img src="http://mycsdnblog.work/201919152250-n.png" alt></p>
<p>2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；</p>
<p><img src="http://mycsdnblog.work/201919152250-9.png" alt></p>
<p>3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）</p>
<p><img src="http://mycsdnblog.work/201919152251-y.png" alt></p>
<p>4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获<strong>（就算我们没写异常捕获语句运行时也会抛出错误！！）</strong>，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<p><img src="http://mycsdnblog.work/201919152252-T.png" alt></p>
<p>5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>，这也是我们学习java异常语句中主要处理的异常对象。</p>
<p><img src="http://mycsdnblog.work/201919152253-t.png" alt></p>
<h1 id="二十七、Enum"><a href="#二十七、Enum" class="headerlink" title="二十七、Enum"></a>二十七、Enum</h1><h3 id="27-1-什么是Enum"><a href="#27-1-什么是Enum" class="headerlink" title="27.1 什么是Enum"></a>27.1 什么是Enum</h3><p>Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量</p>
<h3 id="27-2-Enum的特性"><a href="#27-2-Enum的特性" class="headerlink" title="27.2 Enum的特性"></a>27.2 Enum的特性</h3><ul>
<li>Enum常量隐式的加上了static和final，一旦被创建就无法修改</li>
<li>Enum提供了是类型安全的(type-safe)</li>
<li>Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量</li>
<li>两个Enum常量可以使用 <code>==</code>或<code>equals()</code>方法比较</li>
<li>Enum可以用在switch语句中，就像int，String。</li>
<li>Enum有自己的名称空间</li>
<li>Enum可以实现Java接口</li>
<li>可以在Enum中定义构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-04-26 20:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-3-Enum面试问题"><a href="#27-3-Enum面试问题" class="headerlink" title="27.3 Enum面试问题"></a>27.3 Enum面试问题</h3><ol>
<li>说说Enum的继承<br>所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口</li>
<li>Enum的values,ordinal,valueOf方法<br>enums默认有values()，ordinal()和valueOf()方法。<br>values()方法返回所有在enum中定义的常量值，以数组形式返回。<br>ordinal()方法返回每个常量的索引下标，就像数组的下标<br>valueOf()方法传入字符串参数，如果enum中存在对应字符串的常量值，则返回对应的enum常量</li>
</ol>
<h1 id="二十八、Java数组复制的方法"><a href="#二十八、Java数组复制的方法" class="headerlink" title="二十八、Java数组复制的方法"></a>二十八、Java数组复制的方法</h1><h2 id="28-1-for循环"><a href="#28-1-for循环" class="headerlink" title="28.1 for循环"></a>28.1 for循环</h2><p>代码灵活，效率低</p>
<h2 id="28-2-System-arraycopy-方法"><a href="#28-2-System-arraycopy-方法" class="headerlink" title="28.2 System.arraycopy()方法"></a>28.2 System.arraycopy()方法</h2><p>通过源码可以看到，其为native方法，即原生态方法。自然效率更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">* <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">* <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">* <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">* <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="28-3-Arrays-copyOf"><a href="#28-3-Arrays-copyOf" class="headerlink" title="28.3 Arrays.copyOf()"></a>28.3 Arrays.copyOf()</h2><p>实现还是基于System.arraycopy()，所以效率自然低于System.arraycpoy()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-4-Object-clone"><a href="#28-4-Object-clone" class="headerlink" title="28.4 Object.clone()"></a>28.4 Object.clone()</h2><p>从源码来看同样也是native方法，但返回为Object类型，所以赋值时将发生强转，所以效率不如之前两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二十九、Java中的泛型"><a href="#二十九、Java中的泛型" class="headerlink" title="二十九、Java中的泛型"></a>二十九、Java中的泛型</h1><h1 id="三十、Java中的迭代器"><a href="#三十、Java中的迭代器" class="headerlink" title="三十、Java中的迭代器"></a>三十、Java中的迭代器</h1><p>迭代器模式：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。</p>
<p>Iterator遍历时不可以删除集合中的元素问题</p>
<h1 id="三十一、Java中的内部类作用"><a href="#三十一、Java中的内部类作用" class="headerlink" title="三十一、Java中的内部类作用"></a>三十一、Java中的内部类作用</h1><p><strong>1.内部类可以很好的实现隐藏</strong></p>
<p> <strong>一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</strong></p>
<p><strong>2.内部类拥有外围类的所有元素的访问权限</strong></p>
<p><strong>3.可实现多重继承</strong></p>
<p><strong>4.可以避免修改接口而实现同一个类中两种同名方法的调用。</strong></p>
<p>如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。</p>
<h1 id="三十二、如何解析JSON"><a href="#三十二、如何解析JSON" class="headerlink" title="三十二、如何解析JSON"></a>三十二、如何解析JSON</h1><h1 id="三十三、不用中间变量交换两个数"><a href="#三十三、不用中间变量交换两个数" class="headerlink" title="三十三、不用中间变量交换两个数"></a>三十三、不用中间变量交换两个数</h1><p>a=a+b b=a-b a=a-b</p>
<p>a= a ^ b b = a ^ b a = a ^ b</p>
<h1 id="三十四、Java中对象的大小"><a href="#三十四、Java中对象的大小" class="headerlink" title="三十四、Java中对象的大小"></a>三十四、Java中对象的大小</h1><h2 id="34-1-Java对象结构"><a href="#34-1-Java对象结构" class="headerlink" title="34.1 Java对象结构"></a>34.1 Java对象结构</h2><p><img src="http://mycsdnblog.work/201919111010-0.png" alt></p>
<ol>
<li>Mark Word：存储对象运行时记录信息（<strong>存储对象的HashCode、分代年龄和锁标记位</strong>），占用内存大小与机器位数一样，即<strong>32位机占4字节，64位机占8字节</strong></li>
<li>元数据指针：指向描述类型的Klass对象（Java类的C++对等体）的指针，Klass对象包含了实例对象所属类型的元数据，因此该字段被称为元数据指针，JVM在运行时将频繁使用这个指针定位到位于方法区内的类型信息。<strong>占用内存大小与机器位数一样</strong>。</li>
<li>数组长度：数组对象特有，4个字节</li>
<li>实例数据：实例数据就是8大基本数据类型byte、short、int、long、float、double、char、boolean（对象类型也是由这8大基本数据类型复合而成），每种数据类型占多少字节就不一一例举了</li>
<li>填充：不定，<strong>HotSpot的对齐方式为8字节对齐，即一个对象必须为8字节的整数倍</strong>，因此如果最后前面的数据大小为17则填充7，前面的数据大小为18则填充6，以此类推</li>
</ol>
<p>为了保证效率，Java编译期在编译Java对象的时候，通过字段类型对Java对象的字段会进行排序，具体顺序如下表所示：</p>
<p><img src="http://mycsdnblog.work/201919111012-s.png" alt></p>
<p>元数据指针的大小。元数据指针是一个引用类型，因此正常来说64位机元数据指针应当为8字节，32位机元数据指针应当为4字节，<strong>但是HotSpot中有一项优化是对元数据类型指针进行压缩存储</strong>，使用JVM参数：</p>
<ul>
<li>-XX:+UseCompressedOops开启压缩</li>
<li>-XX:-UseCompressedOops关闭压缩</li>
</ul>
<p>HotSpot默认是前者，即开启元数据指针压缩，当开启压缩的时候，64位机上的元数据指针将占据4个字节的大小。换句话说就是<strong>当开启压缩的时候，64位机上的引用将占据4个字节，否则是正常的8字节</strong>。</p>
<h2 id="34-2-Java对象内存大小计算"><a href="#34-2-Java对象内存大小计算" class="headerlink" title="34.2 Java对象内存大小计算"></a>34.2 Java对象内存大小计算</h2><p>首先是Object对象的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 = 12字节，由于12字节不是8的倍数，因此填充4字节，对象Object占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，对象Object占据16字节内存</li>
</ol>
<p>接着是字符’a’的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 2字节char = 14字节，由于14字节不是8的倍数，因此填充2字节，字符’a’占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，字符’a’占据24字节内存</li>
</ol>
<p>接着是整型1的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节int = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，整型1占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 4字节int = 20字节，由于20字节正好是8的倍数，因此填充4字节，整型1占据24字节内存</li>
</ol>
<p>接着是字符串”aaaaa”的大小，所有静态字段不需要管，只关注实例字段，String对象中实例字段有”char value[]”与”int hash”，由此可知：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节引用 + 4字节int = 20字节，由于20字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据24字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 8字节引用 + 4字节int = 28字节，由于28字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据32字节内存</li>
</ol>
<p>最后是长度为1的char型数组的大小：</p>
<ol>
<li>开启指针压缩时，8字节的Mark Word + 4字节的元数据指针 + 4字节的数组大小引用 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，长度为1的char型数组占据24字节内存</li>
<li>关闭指针压缩时，8字节的Mark Word + 8字节的元数据指针 + 8字节的数组大小引用 + 2字节char = 26字节，由于26字节不是8的倍数，因此填充6字节，长度为1的char型数组占据32字节内存</li>
</ol>
<h1 id="三十五、Class-forName-和ClassLoader-loadClass的区别"><a href="#三十五、Class-forName-和ClassLoader-loadClass的区别" class="headerlink" title="三十五、Class.forName()和ClassLoader.loadClass的区别"></a>三十五、Class.forName()和ClassLoader.loadClass的区别</h1><h2 id="35-1-Java类的装载过程"><a href="#35-1-Java类的装载过程" class="headerlink" title="35.1 Java类的装载过程"></a>35.1 Java类的装载过程</h2><p><img src="http://mycsdnblog.work/201919160937-r.png" alt></p>
<p>1.装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象； </p>
<p>2.链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； </p>
<ul>
<li>校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证） </li>
<li>准备：给类的静态变量分配并初始化存储空间； </li>
<li>解析：将常量池中的符号引用转成直接引用； </li>
</ul>
<p>3.初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
<h2 id="35-2-Class-forName-和ClassLoader-loadClass"><a href="#35-2-Class-forName-和ClassLoader-loadClass" class="headerlink" title="35.2 Class.forName()和ClassLoader.loadClass"></a>35.2 <strong>Class.forName()和ClassLoader.loadClass</strong></h2><p>Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);</p>
<p>第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。</p>
<p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。</p>
<p>ClassLoader.getSystemClassLoader().loadClass(className)方法，内部实际调用的方法是  ClassLoader.getSystemClassLoader().loadClass(className,false);</p>
<p>第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，</p>
<p>不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</p>
<h2 id="35-3-为什么数据库连接要使用Class-forName-className"><a href="#35-3-为什么数据库连接要使用Class-forName-className" class="headerlink" title="35.3 为什么数据库连接要使用Class.forName(className)"></a>35.3 为什么数据库连接要使用Class.forName(className)</h2><p>JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-4-Class-forName，Class-class，getClass-的区别"><a href="#35-4-Class-forName，Class-class，getClass-的区别" class="headerlink" title="35.4 Class.forName，Class.class，getClass()的区别"></a>35.4 Class.forName，Class.class，getClass()的区别</h2><p>Class.forName：会触发静态初始化</p>
<p>Class.class：将类装载进JVM中，不做初始化工作</p>
<p>getClass()：对类进行静态和非静态初始化</p>
<h1 id="三十六、序列化版本号serialVersionUID的作用"><a href="#三十六、序列化版本号serialVersionUID的作用" class="headerlink" title="三十六、序列化版本号serialVersionUID的作用"></a>三十六、序列化版本号serialVersionUID的作用</h1><p>Java中序列化，实现Serializable接口</p>
<p>serialVersionUID的主要作用有以下两个：</p>
<p>1、能够成功反序列化</p>
<p>2、版本控制</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 </li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </li>
</ul>
<h1 id="三十七、MVC和MVVM"><a href="#三十七、MVC和MVVM" class="headerlink" title="三十七、MVC和MVVM"></a>三十七、MVC和MVVM</h1><p>MVC，Model View Controller，是软件架构中最常见的一种框架，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。</p>
<p><img src="http://mycsdnblog.work/201919041924-a.png" alt></p>
<h1 id="三十八、Java中char可以表示一个汉字吗？"><a href="#三十八、Java中char可以表示一个汉字吗？" class="headerlink" title="三十八、Java中char可以表示一个汉字吗？"></a>三十八、Java中char可以表示一个汉字吗？</h1><p>在uft8编码下占三个字节；<br><strong>在GBK编码下占2个字节；</strong><br>但是如果 char表示英文字母：<br>在uft8编码下占一个字节；<br><strong>在GBK编码下还是占2个字节；</strong> </p>
<p><strong>所以char类型的值不管是英文还是中文都是统一两个字节！</strong> </p>
<h1 id="三十九、Java对象的生命周期"><a href="#三十九、Java对象的生命周期" class="headerlink" title="三十九、Java对象的生命周期"></a>三十九、Java对象的生命周期</h1><p>在Java中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li><p>创建阶段(Created)</p>
</li>
<li><p>应用阶段(In Use)</p>
</li>
<li><p>不可见阶段(Invisible)</p>
<p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。</p>
</li>
<li><p>不可达阶段(Unreachable)</p>
<p>对象处于不可达阶段是指该对象不再被任何强引用所持有</p>
<p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>
</li>
<li><p>收集阶段(Collected)</p>
<p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)</p>
<p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)</p>
<p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ol>
<h1 id="四十、理解Java中的各种O"><a href="#四十、理解Java中的各种O" class="headerlink" title="四十、理解Java中的各种O"></a>四十、理解Java中的各种O</h1><p><strong>1、PO(persistant object) 持久对象</strong> </p>
<p>对应于DAO层中操作的对象</p>
<ul>
<li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录，多个记录可以用PO的集合。</li>
<li>在o/r 映射的时候出现的概念,如果没有o/r映射,就没有这个概念存在了。</li>
<li>PO中应该不包含任何对数据库的操作。</li>
</ul>
<p><strong>2、VO(value object) 值对象</strong> </p>
<p>对应View层，用于显示的Java Bean</p>
<ul>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不（大部分情况是表所有字段集合的子集），这根据业务的需要。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的web service传输中而VO用于界面的展示，可以把DTO转化为VO提供给前台。</p>
</li>
</ul>
<p><strong>3、DTO(Data Transfer Object)，数据传输对象</strong> </p>
<p>在应用程序不同tie(关系)之间传输的对象 </p>
<p>对应Controller层中，接收和返回的Java Bean。</p>
<ul>
<li>用在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li>
</ul>
<p><strong>4、BO(business object) 业务对象</strong> </p>
<p>对应Service中的Java Bean </p>
<ul>
<li><p>从业务模型的角度看,见UML元件领域模型中的领域对象.封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ul>
<p>关于BO主要有三种概念</p>
<ul>
<li>只包含业务对象的属性</li>
<li>只包含业务方法</li>
<li>两者都包含</li>
</ul>
<p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<p><strong>5、DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO,<br>提供数据库的CRUD操作…   </p>
<p><strong>6、POJO(plain ordinary java object) 简单无规则java对象</strong><br>纯的传统意义的java对象。就是说在一些Object/Relation<br>Mapping工具中，能够做到维护数据库表记录的persisent<br>object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java<br>Bean，只有属性字段及setter和getter方法！。 </p>
<p><img src="http://mycsdnblog.work/201919161441-u.png" alt></p>
<h1 id="四十一、Spring-Boot中的classpath"><a href="#四十一、Spring-Boot中的classpath" class="headerlink" title="四十一、Spring Boot中的classpath"></a>四十一、Spring Boot中的classpath</h1><p>springboot项目创建完成后，会生成该项目名称+iml后缀的文件。该文件位于项目的根目录下。<br>打开后，在name=”NewModuleRootManager”的component声明中，会有几个默认content声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/resources"</span> <span class="attr">type</span>=<span class="string">"java-resource"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/test/java"</span> <span class="attr">isTestSource</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/target"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中sourceFolder 中声明的就是classpath，只是类型不同。对应的工程文件目录：</p>
<p><img src="http://mycsdnblog.work/201919171559-E.png" alt></p>
<p>其中蓝色的java目录：保存项目的java文件。<br> resources是项目的资源目录，里面通常包含static与templates目录<br> 绿色的test/java目录是编写的测试类的目录。</p>
<ul>
<li>工程编译后，会将src/main/java中的.java文件按照包文件结构编译成.class存入target/classes目录。</li>
<li>工程编译后，会将src/main/resources中的static、templates目录里的文件分别拷贝入classes/static 与classes/template 中。结构保持一致。</li>
<li>工程编译后，会将test/java 中的文件编译进classes/test-classes目录中。</li>
</ul>
<p><strong>可以根据项目需要，修改.iml文件的content，来添加不同的资源路径。</strong></p>
<h1 id="四十二、静态内部类的和普通内部类的区别"><a href="#四十二、静态内部类的和普通内部类的区别" class="headerlink" title="四十二、静态内部类的和普通内部类的区别"></a>四十二、静态内部类的和普通内部类的区别</h1><p>定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明 为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是<strong>外部类可以访问内部类的所有方法与属性，包括私有方法与属性</strong>。</p>
<h2 id="42-1-创建实例"><a href="#42-1-创建实例" class="headerlink" title="42.1 创建实例"></a>42.1 创建实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass.InnerClass innerClass = OutClass.getInstance().<span class="keyword">new</span> InnerClass();</span><br><span class="line"></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-2-内部类中的this"><a href="#42-2-内部类中的this" class="headerlink" title="42.2 内部类中的this"></a>42.2 内部类中的this</h2><p> 内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，于是能访问外围类的所有成员，不需任何特殊条件，可理 解为内部类链接到外部类。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。</p>
<h2 id="42-3-外部类访问内部类"><a href="#42-3-外部类访问内部类" class="headerlink" title="42.3 外部类访问内部类"></a>42.3 外部类访问内部类</h2><p>内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。内部类对象通过‘外部类名.this.xxx’的形式访问外部类的属性与方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-4-内部类向上转型"><a href="#42-4-内部类向上转型" class="headerlink" title="42.4 内部类向上转型"></a>42.4 内部类向上转型</h2><p>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类访问，从而完全隐藏实现的细节。</p>
<h2 id="42-5-方法内的类"><a href="#42-5-方法内的类" class="headerlink" title="42.5 方法内的类"></a>42.5 方法内的类</h2><p>方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-6-静态内部类"><a href="#42-6-静态内部类" class="headerlink" title="42.6 静态内部类"></a>42.6 静态内部类</h2><p>定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。</p>
<p>通常称为<strong>嵌套类</strong>，当内部类是static时，意味着：</p>
<p>   [1]<strong>要创建嵌套类的对象，并不需要其外围类的对象</strong>；</p>
<p>   [2]<strong>不能从嵌套类的对象中访问非静态的外围类对象</strong>（不能够从静态内部类的对象中访问外部类的非静态成员）；</p>
<p>嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，<strong>所以普通的内部类不能有static数据和static字段</strong>， 也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。<strong>也就是说，在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这 个类中定义静态的成员变量与成员方法。</strong></p>
<p>另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的 对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于 该类的对象，更不属于其他外部类的对象。</p>
<h2 id="42-7-内部类标识符"><a href="#42-7-内部类标识符" class="headerlink" title="42.7 内部类标识符"></a>42.7 内部类标识符</h2><p>每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：<strong>外围类的名字，加上$,再加上内部类名字</strong>。</p>
<h2 id="42-8-为什么使用内部类"><a href="#42-8-为什么使用内部类" class="headerlink" title="42.8 为什么使用内部类"></a>42.8 为什么使用内部类</h2><p><strong>内部类一般只为其外部类使用；</strong></p>
<p><strong>内部类提供了某种进入外部类的窗户；</strong></p>
<p><strong>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。</strong></p>
<h1 id="四十三、接口的幂等性"><a href="#四十三、接口的幂等性" class="headerlink" title="四十三、接口的幂等性"></a>四十三、接口的幂等性</h1><p>同步锁</p>
<p>分布式锁</p>
<p>业务字段加唯一约束</p>
<p>令牌表+唯一约束</p>
<p>mysql的insert ignore或者on duplicate key update</p>
<p>共享锁+普通索引</p>
<p>利用MQ或者Redis扩展</p>
<p>使用redis去重</p>
<h1 id="四十四、Java自动类型转换"><a href="#四十四、Java自动类型转换" class="headerlink" title="四十四、Java自动类型转换"></a>四十四、Java自动类型转换</h1><p><img src="http://mycsdnblog.work/201919011617-G.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/02/18/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h1><p><strong>final：java中的关键字，修饰符</strong></p>
<p>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.</p>
<ul>
<li>被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 </li>
<li>被声明final的方法只能使用，不能重载。</li>
</ul>
<p><strong>finally：java的一种异常处理机制。</strong></p>
<p>finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</p>
<p><strong>finalize：Java中的一个方法名</strong></p>
<p>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。<strong>finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p>
<p>  <strong>对象的销毁过程</strong> </p>
<p>在对象的销毁过程中，按照对象的finalize的执行情况，可以分为以下几种，系统会记录对象的对应状态：</p>
<ul>
<li>unfinalized 没有执行finalize，系统也不准备执行。 </li>
<li>finalizable 可以执行finalize了，系统会在随后的某个时间执行finalize。 </li>
<li>finalized 该对象的finalize已经被执行了。 </li>
</ul>
<p>GC怎么来保持对finalizable的对象的追踪呢。GC有一个Queue，叫做F-Queue，所有对象在变为finalizable的时候会加入到该Queue，然后等待GC执行它的finalize方法。 </p>
<p>这时我们引入了对对象的另外一种记录分类，系统可以检查到一个对象属于哪一种。<br>reachable 从活动的对象引用链可以到达的对象。包括所有线程当前栈的局部变量，所有的静态变量等等。<br>finalizer-reachable 除了reachable外，从F-Queue可以通过引用到达的对象。<br>unreachable 其它的对象。 </p>
<p>1 首先，所有的对象都是从Reachable+Unfinalized走向死亡之路的。 </p>
<p>2 当从当前活动集到对象不可达时，对象可以从Reachable状态变到F-Reachable或者Unreachable状态。 </p>
<p>3 当对象为非Reachable+Unfinalized时，GC会把它移入F-Queue，状态变为F-Reachable+Finalizable。 </p>
<p>4 好了，关键的来了，任何时候，GC都可以从F-Queue中拿到一个Finalizable的对象，标记它为Finalized，然后执行它的finalize方法，由于该对象在这个线程中又可达了，于是该对象变成Reachable了（并且Finalized）。而finalize方法执行时，又有可能把其它的F-Reachable的对象变为一个Reachable的，这个叫做对象再生。 </p>
<p>5 当一个对象在Unreachable+Unfinalized时，如果该对象使用的是默认的Object的finalize，或者虽然重写了，但是新的实现什么也不干。为了性能，GC可以把该对象之间变到Reclaimed状态直接销毁，而不用加入到F-Queue等待GC做进一步处理。 </p>
<p>6 从状态图看出，不管怎么折腾，任意一个对象的finalize只至多执行一次，一旦对象变为Finalized，就怎么也不会在回到F-Queue去了。当然没有机会再执行finalize了。 </p>
<p>7 当对象处于Unreachable+Finalized时，该对象离真正的死亡不远了。GC可以安全的回收该对象的内存了。进入Reclaimed。 </p>
<h1 id="二、Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#二、Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="二、Java中的String，StringBuilder，StringBuffer三者的区别"></a>二、Java中的String，StringBuilder，StringBuffer三者的区别</h1><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> System.out.println(str);</span><br><span class="line"><span class="number">3</span> str=str+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">4</span> System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，<strong>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</strong></p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">2</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line"><span class="number">3</span> System.out.println(str);</span><br><span class="line"><span class="number">4</span> System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>

<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">2 String str2&#x3D;&quot;de&quot;;</span><br><span class="line">3 String str&#x3D;str1+str2;</span><br></pre></td></tr></table></figure>

<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>　　2. 再来说线程安全</p>
<p>　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>　　3. 总结一下<br>　　<strong>String：适用于少量的字符串操作的情况</strong></p>
<p>　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
<h1 id="三、Arrays-sort-实现原理和-Collections-sort-实现原理"><a href="#三、Arrays-sort-实现原理和-Collections-sort-实现原理" class="headerlink" title="三、Arrays.sort 实现原理和 Collections.sort 实现原理"></a>三、Arrays.sort 实现原理和 Collections.sort 实现原理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://mycsdnblog.work/201919061054-m.png" alt="1551191608732"></p>
<h1 id="四、Java中boolean占几个字节"><a href="#四、Java中boolean占几个字节" class="headerlink" title="四、Java中boolean占几个字节"></a>四、Java中boolean占几个字节</h1><p>JVM规范指出boolean当做int处理，也就是4字节，boolean数组当做byte数组处理，这样我们可以得出boolean类型占了单独使用是4个字节，在数组中是确定的1个字节。</p>
<h1 id="五、Java基本类型所占的字节"><a href="#五、Java基本类型所占的字节" class="headerlink" title="五、Java基本类型所占的字节"></a>五、Java基本类型所占的字节</h1><p><img src="/.com//1551592963527.png" alt="1551592963527"></p>
<h1 id="六、Java的虚函数"><a href="#六、Java的虚函数" class="headerlink" title="六、Java的虚函数"></a>六、Java的虚函数</h1><p><strong>java类中普通成员函数就是虚函数。</strong></p>
<p>JAVA中的函数，除非声明为static或final，都可以看做是虚的，因为它们都是动态绑定的</p>
<p><strong>会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape1 = circle;</span><br><span class="line">        Shape shape2 = square;</span><br><span class="line">        shape1.draw();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、“方法”"><a href="#七、“方法”" class="headerlink" title="七、“方法”"></a>七、“方法”</h1><h2 id="7-1-Object中的方法"><a href="#7-1-Object中的方法" class="headerlink" title="7.1 Object中的方法"></a>7.1 Object中的方法</h2><p><img src="/.com//1561973717974.png" alt="1551439525914"></p>
<h2 id="7-2-String中常用的方法"><a href="#7-2-String中常用的方法" class="headerlink" title="7.2 String中常用的方法"></a>7.2 String中常用的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类中的方法。</span><br><span class="line">length()</span><br><span class="line">isEmpty()</span><br><span class="line">equals()</span><br><span class="line">toCharArray()</span><br><span class="line">valueOf()</span><br><span class="line">intern()</span><br><span class="line">compareTo()</span><br><span class="line">subString()</span><br><span class="line">contains()</span><br><span class="line">split()</span><br><span class="line">trim()</span><br><span class="line">toLowerCase()</span><br><span class="line">toUpperCase()</span><br><span class="line">startsWith()</span><br></pre></td></tr></table></figure>

<h1 id="八、Java中的浅拷贝和深拷贝"><a href="#八、Java中的浅拷贝和深拷贝" class="headerlink" title="八、Java中的浅拷贝和深拷贝"></a>八、Java中的浅拷贝和深拷贝</h1><h2 id="8-1-浅拷贝"><a href="#8-1-浅拷贝" class="headerlink" title="8.1 浅拷贝"></a>8.1 浅拷贝</h2><h3 id="8-1-1-基本概念"><a href="#8-1-1-基本概念" class="headerlink" title="8.1.1 基本概念"></a>8.1.1 基本概念</h3><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p>
<p>②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>具体模型如图所示：可以看到基本数据类型的成员变量，对其值创建了新的拷贝。而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。</p>
<p><img src="http://mycsdnblog.work/201919141921-T.png" alt></p>
<h3 id="8-1-2-实现方式"><a href="#8-1-2-实现方式" class="headerlink" title="8.1.2 实现方式"></a>8.1.2 实现方式</h3><blockquote>
<p><strong>通过拷贝构造方法实现浅拷贝</strong></p>
</blockquote>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(p1);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = person.age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = person.age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://mycsdnblog.work/201919141948-H.png" alt></p>
<p>结果分析：</p>
<p><strong>age为引用类型，age2为基本类型</strong></p>
<p>修改p1的age，p2的age也随之改变</p>
<p>修改p1的age2，p2的age2不变。</p>
<blockquote>
<p><strong>通过重写clone()方法进行浅拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919141953-J.png" alt></p>
<h2 id="8-2-深拷贝"><a href="#8-2-深拷贝" class="headerlink" title="8.2 深拷贝"></a>8.2 深拷贝</h2><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。<strong>那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象</strong>。<strong>也就是说，对象进行深拷贝要对整个对象图进行拷贝！</strong></p>
<p><strong>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</strong></p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="http://mycsdnblog.work/201919141955-9.png" alt></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h3 id="8-2-2-实现方式"><a href="#8-2-2-实现方式" class="headerlink" title="8.2.2 实现方式"></a>8.2.2 实现方式</h3><blockquote>
<p><strong>通过重写clone方法来实现深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        person.setAge((Age) person.getAge().clone());</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142004-2.png" alt></p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<blockquote>
<p><strong>通过序列化的方式进行深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(p1);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        Person p2 = (Person) objectInputStream.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142017-F.png" alt></p>
<h1 id="九、Java中的权限"><a href="#九、Java中的权限" class="headerlink" title="九、Java中的权限"></a>九、Java中的权限</h1><p>​       1、私有权限（private）</p>
<p>　　private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。</p>
<p>　　2、默认权限（default）</p>
<p>　　类，数据成员，构造方法，方法成员，都能够使用默认权限，<strong>即不写任何关键字</strong>。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。</p>
<p>　　3、受保护权限（protected）</p>
<p>　　protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</p>
<p>　　4、公共权限（public）</p>
<p>　　public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。  </p>
<h1 id="十、一个class文件中可以有几个类"><a href="#十、一个class文件中可以有几个类" class="headerlink" title="十、一个class文件中可以有几个类"></a>十、一个class文件中可以有几个类</h1><p>可以有多个类，但是：</p>
<p>1.public 权限的类只能有一个（也可以一个都没有，但最多只有1个）<br>2.这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）<br>3.若这个文件中没有public的类，则文件名随便是一个类的名字即可<br>4.你用Javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件</p>
<h1 id="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"><a href="#十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类" class="headerlink" title="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"></a>十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类</h1><p>1.抽象类和接口类的对比：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>抽象类</strong></th>
<th align="center"><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与正常Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center"><strong>它比接口速度要快</strong></td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>2.什么时候使用抽象类和接口</p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<p>3.Java8的改进</p>
<p>接口中可以声明default方法。default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</p>
<p>如果一个类实现了两个接口（可以看做是“多继承”），这两个接口又同时都包含了一个名字相同的default方法，那么会发生什么情况？ 在这样的情况下，编译器会报错。让我用例子来解释一下：</p>
<p><img src="http://mycsdnblog.work/201919122049-L.png" alt></p>
<h1 id="十二、自然排序和定制排序"><a href="#十二、自然排序和定制排序" class="headerlink" title="十二、自然排序和定制排序"></a>十二、自然排序和定制排序</h1><p>自然排序是通过实现了的Comparable来进行的</p>
<p>定制排序是实现Comparator</p>
<h1 id="十四、equals和hashcode的区别以及联系"><a href="#十四、equals和hashcode的区别以及联系" class="headerlink" title="十四、equals和hashcode的区别以及联系"></a>十四、equals和hashcode的区别以及联系</h1><p>1.equals方法</p>
<p>自反性 ： x.equals(x) 结果应该返回true。</p>
<p>对称性 ： x.equals(y) 结果返回true当且仅当y.equals(x)也应该返回true。</p>
<p>传递性 ： x.equals(y) 返回true，并且y.equals(z) 返回true，那么x.equals(z) 也应该返回true。</p>
<p>一致性 ： x.equals(y)的第一次调用为true，那么x.equals(y)的第二次，第三次等多次调用也应该为true，但是前提条件是在进行比较之前，x和y都没有被修改。</p>
<p>x.equals(null) 应该返回false。</p>
<p>这个方法返回true当且仅当x和y指向了同样的对象(x==y)，这句话也就是说明了在默认情况下，<strong>Object类中的equals方法默认比较的是对象的地址，因为只有是相同的地址才会相等(x == y)，如果没有重写equals方法，那么默认就是比较的是地址。</strong>注意：<strong>无论何时这个equals方法被重写那么都是有必要去重写hashCode方法，这个是因为为了维持hashCode的一种约定，相同的对象必须要有相同的hashCode值。</strong></p>
<p>2.hashcode</p>
<p>在同一次的java程序应用过程中，对应同样的对象多次调用hashCode方法，hashCode方法必须一致性的返回同样的一个地址值，前提是这个对象不能改变</p>
<p>两个对象相同是依据equals方法来的，那么其中的每一个对象调用hashCode方法都必须返回相同的一个integer值，也就是对象的地址。equals方法相等，那么hashCode方法也必须相等。</p>
<p>如果两个对象依据equals方法返回的结果不相等，那么对于其中的每一个对象调用hashCode方法返回的结果也不是一定必须得相等（也就是说，equals方法的结果为false，那么hashCode方法返回的结果可以相同也可以不相同），但是，对于我们开发者来说，针对两个对象的不相等如果生成相同的hashCode则可以提高应用程序的性能。</p>
<p>​         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p>
<p>​         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
<p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 </p>
<p><strong>并不是所有重写equals()的时候都要重写hashCode()，如果不涉及到哈希表的话，就不需要了。</strong></p>
<h1 id="十五：自动装箱与拆箱"><a href="#十五：自动装箱与拆箱" class="headerlink" title="十五：自动装箱与拆箱"></a>十五：自动装箱与拆箱</h1><h2 id="15-1-基本概念"><a href="#15-1-基本概念" class="headerlink" title="15.1 基本概念"></a>15.1 基本概念</h2><p>装箱：将基本类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>如何实现?</p>
<p>拿Integer来举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = integer; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p><strong>装箱：主要调用的是Integer的valueOf(int)方法</strong></p>
<p><strong>拆箱：自动调用Integer的intValue方法</strong></p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
<ol>
<li><p>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。</p>
</li>
<li><p><strong>Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。</strong></p>
</li>
<li><p>new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。</p>
</li>
</ol>
<h2 id="15-2-实战"><a href="#15-2-实战" class="headerlink" title="15.2 实战"></a>15.2 实战</h2><h3 id="15-2-1-示例1"><a href="#15-2-1-示例1" class="headerlink" title="15.2.1 示例1"></a>15.2.1 示例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果为：</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-示例2"><a href="#15-2-2-示例2" class="headerlink" title="15.2.2 示例2"></a>15.2.2 示例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double a = <span class="number">100.0</span>;</span><br><span class="line">        Double b = <span class="number">100.0</span>;</span><br><span class="line">        Double c = <span class="number">200.0</span>;</span><br><span class="line">        Double d = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>false<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。</p>
<p>很简单：<strong>在某个范围内的整型数值的个数是有限的，而浮点数却不是</strong>。</p>
<p>注意：</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double、Float的valueOf方法的实现是类似的。</li>
</ul>
<h1 id="十六、equals和"><a href="#十六、equals和" class="headerlink" title="十六、equals和=="></a>十六、equals和==</h1><p>==：判断两个对象的地址是否相等，基本类型就是判断值是否相等</p>
<p>equals：类没有重写equals方法，等价于==；覆盖的话就是比较两个对象的内容</p>
<h1 id="十七：Java闭包和回调"><a href="#十七：Java闭包和回调" class="headerlink" title="十七：Java闭包和回调"></a>十七：Java闭包和回调</h1><ul>
<li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</li>
<li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。</li>
</ul>
<p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p>
<p>在Java中，闭包是 通过“接口与内部类实现的”</p>
<p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”来实现，因为对于非静态内部类而言，它不仅记录了其外部类的详细信息，还保留了一个创建非静态内部类的引用，通过它可以访问外部类的私有成员，因此可以把非静态内部类当成面向对象领域的闭包。那么，通过这种仿闭包的非静态内部类可以很方便地实现回调，这是一种非常灵活的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-13 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 测试闭包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClosure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> Food();</span><br><span class="line">        food.getEat().eat();</span><br><span class="line">        food.getNum();</span><br><span class="line"></span><br><span class="line">        Food pub = <span class="keyword">new</span> Food();</span><br><span class="line">        Food.EatActive eatActive = pub.<span class="keyword">new</span> EatActive();</span><br><span class="line">        eatActive.eat();</span><br><span class="line">        pub.getNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"food"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"my food"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Active <span class="title">getEat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatActive</span> <span class="keyword">implements</span> <span class="title">Active</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"no"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Active</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包(closure)是一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域.</p>
<h1 id="十八、hashCode"><a href="#十八、hashCode" class="headerlink" title="十八、hashCode"></a>十八、hashCode</h1><p>hashCode就是根据存储在一个对象实例中的所有数据，提取出一个<strong>32</strong>位的整数，该整数的目的是用来标示该实例的唯一性，有点类似于MD5码，每个文件都能通过MD5算法生成一个唯一的MD5码。</p>
<h1 id="十九、Math-abs"><a href="#十九、Math-abs" class="headerlink" title="十九、Math.abs"></a>十九、Math.abs</h1><p>Java的API文档中说，对abs(int a)运算，“如果参数等于 Integer.MIN_VALUE 的值(即能够表示的最小负 int 值)，那么结果与该值相同且为负。</p>
<h1 id="二十、static关键字"><a href="#二十、static关键字" class="headerlink" title="二十、static关键字"></a>二十、static关键字</h1><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，<strong>它当且仅当在类初次加载时会被初始化</strong>。<strong>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</strong>。</p>
<p><strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong>。</p>
<h1 id="二十一、Collection和Collections的区别"><a href="#二十一、Collection和Collections的区别" class="headerlink" title="二十一、Collection和Collections的区别"></a>二十一、Collection和Collections的区别</h1><p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p> Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p>
<p>2、Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<h1 id="二十二、Overload和Override的区别？"><a href="#二十二、Overload和Override的区别？" class="headerlink" title="二十二、Overload和Override的区别？"></a>二十二、Overload和Override的区别？</h1><p> Overload是重载的意思，Override是覆盖的意思，也就是重写。</p>
<p>​    重载Overload：在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。</p>
<p>​    重载的特点：与返回值类型无关，只看参数列表。</p>
<p>​    重写Override表示子类中的方法可以与父类中的某个方法的<strong>名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中定义的那个完全相同的方法给覆盖掉了，这也是面向对象编程的多态的一种表现。子类覆盖父类方法时只能抛出父类的异常或者异常的子类或者父类异常的子集，因为子类可以解决父类的一些问题，但不能比父类有更多的问题。还有，子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，则子类中根本不存在覆盖，即子类中和父类的private的同名的方法没有覆盖的关系，因为private的访问权限只限于同一类中，而子类就不会访问到private的方法，所以是子类中增加的一个全新的方法。</p>
<p>​    <strong>重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法是可以改变返回值类型的</strong>。所以，如果两个方法的参数列表完全一样，是不能通过让他们的返回值类型不同来实现重载的。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<h1 id="二十三、Java参数是值传递还是引用传递"><a href="#二十三、Java参数是值传递还是引用传递" class="headerlink" title="二十三、Java参数是值传递还是引用传递"></a>二十三、Java参数是值传递还是引用传递</h1><p><strong>值传递</strong></p>
<p><strong>Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</strong></p>
<h1 id="二十四、final关键字对类、方法和成员变量的修饰"><a href="#二十四、final关键字对类、方法和成员变量的修饰" class="headerlink" title="二十四、final关键字对类、方法和成员变量的修饰"></a>二十四、final关键字对类、方法和成员变量的修饰</h1><ol>
<li>final修饰类 </li>
</ol>
<p>被修饰的类不能被继承，也没有子类。假如随意创建这些类的子类，子类可能会错误的修改父类的实现细节、出于安全原因，类的实现细节不允许有任何改动、在创建对象模型的时候，确信这个类不会再被扩展。<strong>注：如果对一个已经被final修饰的类进行继承操作，则会在编译的期间直接出现错误</strong></p>
<ol start="2">
<li>final修饰方法</li>
</ol>
<p>final修饰的方法表示此方法已经是“最后的、最终的”含义，<strong>亦即此方法不能被重写</strong>，（但是可以载多个final修饰的方法）。</p>
<p>需要注意的一点是: 重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法的访问权限是private，将会导致子类不能直接继承到此方法，这时候再在子类中定义相同的方法名和参数，不会产生重写与final之间出现的矛盾，而是在子类中定义了新的方法。</p>
<ol start="3">
<li>final修饰变量</li>
</ol>
<p><strong>final修饰的变量表示此变量是“最后的、最终的”,一旦定义了final变量，并在首次为其显示进行了初始化之后，final修饰的变量值不可被再修改。</strong></p>
<p>final修饰的变量，无论是类属性、对象属性、形参还是局部变量，这些变量都是需要进行显示初始化（即为其显示指定初始值）。</p>
<p><strong>另外，无论对于基本数据类型还是引用数据类型，final修饰的变量都是首次初始化后值都不能修改。对于基本数据类型，很好理解。对于引用数据类型，引用变量指向的是实际的对象，但其存储的是所指向对象的地址，因此，其值不能修改并不意味着其所指向的对象不能修改。</strong> </p>
<h1 id="二十五、整型转字符串"><a href="#二十五、整型转字符串" class="headerlink" title="二十五、整型转字符串"></a>二十五、整型转字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">String string = String.valueOf(i);</span><br><span class="line">String string2 = <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">String string3 = i.toString();</span><br></pre></td></tr></table></figure>

<h1 id="二十六、Java中的异常"><a href="#二十六、Java中的异常" class="headerlink" title="二十六、Java中的异常"></a>二十六、Java中的异常</h1><p>采用的设计模式是：<strong>责任链模式</strong></p>
<p>Java有两种异常类型：<strong>受检查异常和运行时异常</strong></p>
<p>检查异常：<strong>这些异常从程序的角度来说是必须经过捕捉处理的，否则编译通不过，</strong>比如IOException，SQLException。</p>
<p>运行时异常（不受检查异常）：Error和运行时异常</p>
<p>Error是程序无法处理的，如：OutOfMemmoryError，如果出现Error，Java虚拟机就会终止线程。</p>
<p><strong>运行时异常：如RunTimeException，IndexOutOfBoundsException，NullPointerException，这些异常一般是由程序的逻辑错误引起的，解决此类异常应该仔细排查程序，不需要进行检查。</strong></p>
<p><strong>两者的区别：</strong></p>
<p>非检查异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。</p>
<p><strong>受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。</strong></p>
<p>对于运行异常，建议不要用 try…catch…捕获处理，应该在程序开发调试的过程中尽量的避免，当然有一些必须要处理的，自己知道了那个部分会出现异常，而这种异常你要把它处理的你想要的结果，例如：空值处理。</p>
<p><img src="http://mycsdnblog.work/201919152249-a.png" alt></p>
<p>1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；</p>
<p><img src="http://mycsdnblog.work/201919152250-n.png" alt></p>
<p>2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；</p>
<p><img src="http://mycsdnblog.work/201919152250-9.png" alt></p>
<p>3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）</p>
<p><img src="http://mycsdnblog.work/201919152251-y.png" alt></p>
<p>4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获<strong>（就算我们没写异常捕获语句运行时也会抛出错误！！）</strong>，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<p><img src="http://mycsdnblog.work/201919152252-T.png" alt></p>
<p>5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>，这也是我们学习java异常语句中主要处理的异常对象。</p>
<p><img src="http://mycsdnblog.work/201919152253-t.png" alt></p>
<h1 id="二十七、Enum"><a href="#二十七、Enum" class="headerlink" title="二十七、Enum"></a>二十七、Enum</h1><h3 id="27-1-什么是Enum"><a href="#27-1-什么是Enum" class="headerlink" title="27.1 什么是Enum"></a>27.1 什么是Enum</h3><p>Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量</p>
<h3 id="27-2-Enum的特性"><a href="#27-2-Enum的特性" class="headerlink" title="27.2 Enum的特性"></a>27.2 Enum的特性</h3><ul>
<li>Enum常量隐式的加上了static和final，一旦被创建就无法修改</li>
<li>Enum提供了是类型安全的(type-safe)</li>
<li>Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量</li>
<li>两个Enum常量可以使用 <code>==</code>或<code>equals()</code>方法比较</li>
<li>Enum可以用在switch语句中，就像int，String。</li>
<li>Enum有自己的名称空间</li>
<li>Enum可以实现Java接口</li>
<li>可以在Enum中定义构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-04-26 20:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-3-Enum面试问题"><a href="#27-3-Enum面试问题" class="headerlink" title="27.3 Enum面试问题"></a>27.3 Enum面试问题</h3><ol>
<li>说说Enum的继承<br>所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口</li>
<li>Enum的values,ordinal,valueOf方法<br>enums默认有values()，ordinal()和valueOf()方法。<br>values()方法返回所有在enum中定义的常量值，以数组形式返回。<br>ordinal()方法返回每个常量的索引下标，就像数组的下标<br>valueOf()方法传入字符串参数，如果enum中存在对应字符串的常量值，则返回对应的enum常量</li>
</ol>
<h1 id="二十八、Java数组复制的方法"><a href="#二十八、Java数组复制的方法" class="headerlink" title="二十八、Java数组复制的方法"></a>二十八、Java数组复制的方法</h1><h2 id="28-1-for循环"><a href="#28-1-for循环" class="headerlink" title="28.1 for循环"></a>28.1 for循环</h2><p>代码灵活，效率低</p>
<h2 id="28-2-System-arraycopy-方法"><a href="#28-2-System-arraycopy-方法" class="headerlink" title="28.2 System.arraycopy()方法"></a>28.2 System.arraycopy()方法</h2><p>通过源码可以看到，其为native方法，即原生态方法。自然效率更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">* <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">* <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">* <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">* <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="28-3-Arrays-copyOf"><a href="#28-3-Arrays-copyOf" class="headerlink" title="28.3 Arrays.copyOf()"></a>28.3 Arrays.copyOf()</h2><p>实现还是基于System.arraycopy()，所以效率自然低于System.arraycpoy()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-4-Object-clone"><a href="#28-4-Object-clone" class="headerlink" title="28.4 Object.clone()"></a>28.4 Object.clone()</h2><p>从源码来看同样也是native方法，但返回为Object类型，所以赋值时将发生强转，所以效率不如之前两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二十九、Java中的泛型"><a href="#二十九、Java中的泛型" class="headerlink" title="二十九、Java中的泛型"></a>二十九、Java中的泛型</h1><h1 id="三十、Java中的迭代器"><a href="#三十、Java中的迭代器" class="headerlink" title="三十、Java中的迭代器"></a>三十、Java中的迭代器</h1><p>迭代器模式：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。</p>
<p>Iterator遍历时不可以删除集合中的元素问题</p>
<h1 id="三十一、Java中的内部类作用"><a href="#三十一、Java中的内部类作用" class="headerlink" title="三十一、Java中的内部类作用"></a>三十一、Java中的内部类作用</h1><p><strong>1.内部类可以很好的实现隐藏</strong></p>
<p> <strong>一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</strong></p>
<p><strong>2.内部类拥有外围类的所有元素的访问权限</strong></p>
<p><strong>3.可实现多重继承</strong></p>
<p><strong>4.可以避免修改接口而实现同一个类中两种同名方法的调用。</strong></p>
<p>如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。</p>
<h1 id="三十二、如何解析JSON"><a href="#三十二、如何解析JSON" class="headerlink" title="三十二、如何解析JSON"></a>三十二、如何解析JSON</h1><h1 id="三十三、不用中间变量交换两个数"><a href="#三十三、不用中间变量交换两个数" class="headerlink" title="三十三、不用中间变量交换两个数"></a>三十三、不用中间变量交换两个数</h1><p>a=a+b b=a-b a=a-b</p>
<p>a= a ^ b b = a ^ b a = a ^ b</p>
<h1 id="三十四、Java中对象的大小"><a href="#三十四、Java中对象的大小" class="headerlink" title="三十四、Java中对象的大小"></a>三十四、Java中对象的大小</h1><h2 id="34-1-Java对象结构"><a href="#34-1-Java对象结构" class="headerlink" title="34.1 Java对象结构"></a>34.1 Java对象结构</h2><p><img src="http://mycsdnblog.work/201919111010-0.png" alt></p>
<ol>
<li>Mark Word：存储对象运行时记录信息（<strong>存储对象的HashCode、分代年龄和锁标记位</strong>），占用内存大小与机器位数一样，即<strong>32位机占4字节，64位机占8字节</strong></li>
<li>元数据指针：指向描述类型的Klass对象（Java类的C++对等体）的指针，Klass对象包含了实例对象所属类型的元数据，因此该字段被称为元数据指针，JVM在运行时将频繁使用这个指针定位到位于方法区内的类型信息。<strong>占用内存大小与机器位数一样</strong>。</li>
<li>数组长度：数组对象特有，4个字节</li>
<li>实例数据：实例数据就是8大基本数据类型byte、short、int、long、float、double、char、boolean（对象类型也是由这8大基本数据类型复合而成），每种数据类型占多少字节就不一一例举了</li>
<li>填充：不定，<strong>HotSpot的对齐方式为8字节对齐，即一个对象必须为8字节的整数倍</strong>，因此如果最后前面的数据大小为17则填充7，前面的数据大小为18则填充6，以此类推</li>
</ol>
<p>为了保证效率，Java编译期在编译Java对象的时候，通过字段类型对Java对象的字段会进行排序，具体顺序如下表所示：</p>
<p><img src="http://mycsdnblog.work/201919111012-s.png" alt></p>
<p>元数据指针的大小。元数据指针是一个引用类型，因此正常来说64位机元数据指针应当为8字节，32位机元数据指针应当为4字节，<strong>但是HotSpot中有一项优化是对元数据类型指针进行压缩存储</strong>，使用JVM参数：</p>
<ul>
<li>-XX:+UseCompressedOops开启压缩</li>
<li>-XX:-UseCompressedOops关闭压缩</li>
</ul>
<p>HotSpot默认是前者，即开启元数据指针压缩，当开启压缩的时候，64位机上的元数据指针将占据4个字节的大小。换句话说就是<strong>当开启压缩的时候，64位机上的引用将占据4个字节，否则是正常的8字节</strong>。</p>
<h2 id="34-2-Java对象内存大小计算"><a href="#34-2-Java对象内存大小计算" class="headerlink" title="34.2 Java对象内存大小计算"></a>34.2 Java对象内存大小计算</h2><p>首先是Object对象的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 = 12字节，由于12字节不是8的倍数，因此填充4字节，对象Object占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，对象Object占据16字节内存</li>
</ol>
<p>接着是字符’a’的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 2字节char = 14字节，由于14字节不是8的倍数，因此填充2字节，字符’a’占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，字符’a’占据24字节内存</li>
</ol>
<p>接着是整型1的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节int = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，整型1占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 4字节int = 20字节，由于20字节正好是8的倍数，因此填充4字节，整型1占据24字节内存</li>
</ol>
<p>接着是字符串”aaaaa”的大小，所有静态字段不需要管，只关注实例字段，String对象中实例字段有”char value[]”与”int hash”，由此可知：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节引用 + 4字节int = 20字节，由于20字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据24字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 8字节引用 + 4字节int = 28字节，由于28字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据32字节内存</li>
</ol>
<p>最后是长度为1的char型数组的大小：</p>
<ol>
<li>开启指针压缩时，8字节的Mark Word + 4字节的元数据指针 + 4字节的数组大小引用 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，长度为1的char型数组占据24字节内存</li>
<li>关闭指针压缩时，8字节的Mark Word + 8字节的元数据指针 + 8字节的数组大小引用 + 2字节char = 26字节，由于26字节不是8的倍数，因此填充6字节，长度为1的char型数组占据32字节内存</li>
</ol>
<h1 id="三十五、Class-forName-和ClassLoader-loadClass的区别"><a href="#三十五、Class-forName-和ClassLoader-loadClass的区别" class="headerlink" title="三十五、Class.forName()和ClassLoader.loadClass的区别"></a>三十五、Class.forName()和ClassLoader.loadClass的区别</h1><h2 id="35-1-Java类的装载过程"><a href="#35-1-Java类的装载过程" class="headerlink" title="35.1 Java类的装载过程"></a>35.1 Java类的装载过程</h2><p><img src="http://mycsdnblog.work/201919160937-r.png" alt></p>
<p>1.装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象； </p>
<p>2.链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； </p>
<ul>
<li>校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证） </li>
<li>准备：给类的静态变量分配并初始化存储空间； </li>
<li>解析：将常量池中的符号引用转成直接引用； </li>
</ul>
<p>3.初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
<h2 id="35-2-Class-forName-和ClassLoader-loadClass"><a href="#35-2-Class-forName-和ClassLoader-loadClass" class="headerlink" title="35.2 Class.forName()和ClassLoader.loadClass"></a>35.2 <strong>Class.forName()和ClassLoader.loadClass</strong></h2><p>Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);</p>
<p>第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。</p>
<p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。</p>
<p>ClassLoader.getSystemClassLoader().loadClass(className)方法，内部实际调用的方法是  ClassLoader.getSystemClassLoader().loadClass(className,false);</p>
<p>第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，</p>
<p>不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</p>
<h2 id="35-3-为什么数据库连接要使用Class-forName-className"><a href="#35-3-为什么数据库连接要使用Class-forName-className" class="headerlink" title="35.3 为什么数据库连接要使用Class.forName(className)"></a>35.3 为什么数据库连接要使用Class.forName(className)</h2><p>JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-4-Class-forName，Class-class，getClass-的区别"><a href="#35-4-Class-forName，Class-class，getClass-的区别" class="headerlink" title="35.4 Class.forName，Class.class，getClass()的区别"></a>35.4 Class.forName，Class.class，getClass()的区别</h2><p>Class.forName：会触发静态初始化</p>
<p>Class.class：将类装载进JVM中，不做初始化工作</p>
<p>getClass()：对类进行静态和非静态初始化</p>
<h1 id="三十六、序列化版本号serialVersionUID的作用"><a href="#三十六、序列化版本号serialVersionUID的作用" class="headerlink" title="三十六、序列化版本号serialVersionUID的作用"></a>三十六、序列化版本号serialVersionUID的作用</h1><p>Java中序列化，实现Serializable接口</p>
<p>serialVersionUID的主要作用有以下两个：</p>
<p>1、能够成功反序列化</p>
<p>2、版本控制</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 </li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </li>
</ul>
<h1 id="三十七、MVC和MVVM"><a href="#三十七、MVC和MVVM" class="headerlink" title="三十七、MVC和MVVM"></a>三十七、MVC和MVVM</h1><p>MVC，Model View Controller，是软件架构中最常见的一种框架，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。</p>
<p><img src="http://mycsdnblog.work/201919041924-a.png" alt></p>
<h1 id="三十八、Java中char可以表示一个汉字吗？"><a href="#三十八、Java中char可以表示一个汉字吗？" class="headerlink" title="三十八、Java中char可以表示一个汉字吗？"></a>三十八、Java中char可以表示一个汉字吗？</h1><p>在uft8编码下占三个字节；<br><strong>在GBK编码下占2个字节；</strong><br>但是如果 char表示英文字母：<br>在uft8编码下占一个字节；<br><strong>在GBK编码下还是占2个字节；</strong> </p>
<p><strong>所以char类型的值不管是英文还是中文都是统一两个字节！</strong> </p>
<h1 id="三十九、Java对象的生命周期"><a href="#三十九、Java对象的生命周期" class="headerlink" title="三十九、Java对象的生命周期"></a>三十九、Java对象的生命周期</h1><p>在Java中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li><p>创建阶段(Created)</p>
</li>
<li><p>应用阶段(In Use)</p>
</li>
<li><p>不可见阶段(Invisible)</p>
<p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。</p>
</li>
<li><p>不可达阶段(Unreachable)</p>
<p>对象处于不可达阶段是指该对象不再被任何强引用所持有</p>
<p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>
</li>
<li><p>收集阶段(Collected)</p>
<p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)</p>
<p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)</p>
<p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ol>
<h1 id="四十、理解Java中的各种O"><a href="#四十、理解Java中的各种O" class="headerlink" title="四十、理解Java中的各种O"></a>四十、理解Java中的各种O</h1><p><strong>1、PO(persistant object) 持久对象</strong> </p>
<p>对应于DAO层中操作的对象</p>
<ul>
<li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录，多个记录可以用PO的集合。</li>
<li>在o/r 映射的时候出现的概念,如果没有o/r映射,就没有这个概念存在了。</li>
<li>PO中应该不包含任何对数据库的操作。</li>
</ul>
<p><strong>2、VO(value object) 值对象</strong> </p>
<p>对应View层，用于显示的Java Bean</p>
<ul>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不（大部分情况是表所有字段集合的子集），这根据业务的需要。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的web service传输中而VO用于界面的展示，可以把DTO转化为VO提供给前台。</p>
</li>
</ul>
<p><strong>3、DTO(Data Transfer Object)，数据传输对象</strong> </p>
<p>在应用程序不同tie(关系)之间传输的对象 </p>
<p>对应Controller层中，接收和返回的Java Bean。</p>
<ul>
<li>用在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li>
</ul>
<p><strong>4、BO(business object) 业务对象</strong> </p>
<p>对应Service中的Java Bean </p>
<ul>
<li><p>从业务模型的角度看,见UML元件领域模型中的领域对象.封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ul>
<p>关于BO主要有三种概念</p>
<ul>
<li>只包含业务对象的属性</li>
<li>只包含业务方法</li>
<li>两者都包含</li>
</ul>
<p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<p><strong>5、DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO,<br>提供数据库的CRUD操作…   </p>
<p><strong>6、POJO(plain ordinary java object) 简单无规则java对象</strong><br>纯的传统意义的java对象。就是说在一些Object/Relation<br>Mapping工具中，能够做到维护数据库表记录的persisent<br>object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java<br>Bean，只有属性字段及setter和getter方法！。 </p>
<p><img src="http://mycsdnblog.work/201919161441-u.png" alt></p>
<h1 id="四十一、Spring-Boot中的classpath"><a href="#四十一、Spring-Boot中的classpath" class="headerlink" title="四十一、Spring Boot中的classpath"></a>四十一、Spring Boot中的classpath</h1><p>springboot项目创建完成后，会生成该项目名称+iml后缀的文件。该文件位于项目的根目录下。<br>打开后，在name=”NewModuleRootManager”的component声明中，会有几个默认content声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/resources"</span> <span class="attr">type</span>=<span class="string">"java-resource"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/test/java"</span> <span class="attr">isTestSource</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/target"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中sourceFolder 中声明的就是classpath，只是类型不同。对应的工程文件目录：</p>
<p><img src="http://mycsdnblog.work/201919171559-E.png" alt></p>
<p>其中蓝色的java目录：保存项目的java文件。<br> resources是项目的资源目录，里面通常包含static与templates目录<br> 绿色的test/java目录是编写的测试类的目录。</p>
<ul>
<li>工程编译后，会将src/main/java中的.java文件按照包文件结构编译成.class存入target/classes目录。</li>
<li>工程编译后，会将src/main/resources中的static、templates目录里的文件分别拷贝入classes/static 与classes/template 中。结构保持一致。</li>
<li>工程编译后，会将test/java 中的文件编译进classes/test-classes目录中。</li>
</ul>
<p><strong>可以根据项目需要，修改.iml文件的content，来添加不同的资源路径。</strong></p>
<h1 id="四十二、静态内部类的和普通内部类的区别"><a href="#四十二、静态内部类的和普通内部类的区别" class="headerlink" title="四十二、静态内部类的和普通内部类的区别"></a>四十二、静态内部类的和普通内部类的区别</h1><p>定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明 为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是<strong>外部类可以访问内部类的所有方法与属性，包括私有方法与属性</strong>。</p>
<h2 id="42-1-创建实例"><a href="#42-1-创建实例" class="headerlink" title="42.1 创建实例"></a>42.1 创建实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass.InnerClass innerClass = OutClass.getInstance().<span class="keyword">new</span> InnerClass();</span><br><span class="line"></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-2-内部类中的this"><a href="#42-2-内部类中的this" class="headerlink" title="42.2 内部类中的this"></a>42.2 内部类中的this</h2><p> 内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，于是能访问外围类的所有成员，不需任何特殊条件，可理 解为内部类链接到外部类。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。</p>
<h2 id="42-3-外部类访问内部类"><a href="#42-3-外部类访问内部类" class="headerlink" title="42.3 外部类访问内部类"></a>42.3 外部类访问内部类</h2><p>内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。内部类对象通过‘外部类名.this.xxx’的形式访问外部类的属性与方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-4-内部类向上转型"><a href="#42-4-内部类向上转型" class="headerlink" title="42.4 内部类向上转型"></a>42.4 内部类向上转型</h2><p>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类访问，从而完全隐藏实现的细节。</p>
<h2 id="42-5-方法内的类"><a href="#42-5-方法内的类" class="headerlink" title="42.5 方法内的类"></a>42.5 方法内的类</h2><p>方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-6-静态内部类"><a href="#42-6-静态内部类" class="headerlink" title="42.6 静态内部类"></a>42.6 静态内部类</h2><p>定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。</p>
<p>通常称为<strong>嵌套类</strong>，当内部类是static时，意味着：</p>
<p>   [1]<strong>要创建嵌套类的对象，并不需要其外围类的对象</strong>；</p>
<p>   [2]<strong>不能从嵌套类的对象中访问非静态的外围类对象</strong>（不能够从静态内部类的对象中访问外部类的非静态成员）；</p>
<p>嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，<strong>所以普通的内部类不能有static数据和static字段</strong>， 也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。<strong>也就是说，在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这 个类中定义静态的成员变量与成员方法。</strong></p>
<p>另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的 对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于 该类的对象，更不属于其他外部类的对象。</p>
<h2 id="42-7-内部类标识符"><a href="#42-7-内部类标识符" class="headerlink" title="42.7 内部类标识符"></a>42.7 内部类标识符</h2><p>每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：<strong>外围类的名字，加上$,再加上内部类名字</strong>。</p>
<h2 id="42-8-为什么使用内部类"><a href="#42-8-为什么使用内部类" class="headerlink" title="42.8 为什么使用内部类"></a>42.8 为什么使用内部类</h2><p><strong>内部类一般只为其外部类使用；</strong></p>
<p><strong>内部类提供了某种进入外部类的窗户；</strong></p>
<p><strong>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。</strong></p>
<h1 id="四十三、接口的幂等性"><a href="#四十三、接口的幂等性" class="headerlink" title="四十三、接口的幂等性"></a>四十三、接口的幂等性</h1><p>同步锁</p>
<p>分布式锁</p>
<p>业务字段加唯一约束</p>
<p>令牌表+唯一约束</p>
<p>mysql的insert ignore或者on duplicate key update</p>
<p>共享锁+普通索引</p>
<p>利用MQ或者Redis扩展</p>
<p>使用redis去重</p>
<h1 id="四十四、Java自动类型转换"><a href="#四十四、Java自动类型转换" class="headerlink" title="四十四、Java自动类型转换"></a>四十四、Java自动类型转换</h1><p><img src="http://mycsdnblog.work/201919011617-G.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github+Node搭建个人博客</title>
    <url>/2020/02/17/Hexo+Github+Node%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<hr>
<h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>Hexo：    <a href="http://hexo.io" target="_blank" rel="noopener">http://hexo.io</a><br>Github:     <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a><br>Next：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>  </p>
<h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><blockquote>
<p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。<br>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，将前者称为站点配置文件， 后者称为主题配置文件。<br>注：修改站点配置文件后需重启网站，修改主题配置文件后直接刷新网页即可<br>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
</blockquote>
<h3 id="Hexo-GitHub搭建网站原理"><a href="#Hexo-GitHub搭建网站原理" class="headerlink" title="Hexo+GitHub搭建网站原理"></a>Hexo+GitHub搭建网站原理</h3><blockquote>
<p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
</blockquote>
<h3 id="基础Cmd命令"><a href="#基础Cmd命令" class="headerlink" title="基础Cmd命令"></a>基础Cmd命令</h3><p>cmd进入D:\blog目录<br>window+R进入cmd命令窗口，默认进去是C:user\zwb<br>进入D:\blog目录，此时需进入D盘，输入命令D:<br>输入命令cd D:\blog  （错误命令：直接输入cd D:blog）</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> （安装Node.js会自动包含环境变量及npm的安装）<br>检测Node.js是否安装成功，在命令行中输入 node -v :<br>检测npm是否安装成功，在命令行中输入npm -v :  </p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>参考原文：<a href="https://blog.csdn.net/WX_JIN/article/details/51027783" target="_blank" rel="noopener">https://blog.csdn.net/WX_JIN/article/details/51027783</a><br>参考原文：<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a>  </p>
<p>在D盘新建文件夹D:\Blog，打开Cmd命令行，进入该文件夹<br>输入npm命令安装Hexo：npm install -g hexo-cli<br>左上角显示npm，表示在调用npm程序，npm命令未执行完，需耐心等待<br>输入命令初始化博客：hexo init blog<br>左上角显示hexo，表示在调用hexo程序，hexo命令未执行完，需耐心等待<br>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：  </p>
<h4 id="HEXO常用命令"><a href="#HEXO常用命令" class="headerlink" title="HEXO常用命令"></a>HEXO常用命令</h4><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 </p>
<p>在本地查看效果<br>命令执行完后，D:\Blog下会出现Blog子目录，进入D:\Blog\blog目录，输入以下命令在本地查看效果<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>浏览器输入地址访问：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>也可以输入1条命令：hexo clean &amp;&amp; hexo g  &amp;&amp; hexo d   </p>
<h3 id="部署到远程GitHub"><a href="#部署到远程GitHub" class="headerlink" title="部署到远程GitHub"></a>部署到远程GitHub</h3><p>申请GitHub账号，下载Git客户端，配置SSH<br>安装部署插件插件：    npm install hexo-deployer-git –save<br>部署你本地的主题到github上 ，代码如下，每次修改本地主题，都需要执行以下代码<br>hexo g == hexo generate     #生成<br>hexo s == hexo server        #启动服务预览<br>hexo d == hexo deploy        #部署  </p>
<h4 id="更换为Next主题"><a href="#更换为Next主题" class="headerlink" title="更换为Next主题"></a>更换为Next主题</h4><p>参考原文：<a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a><br><a href="https://blog.csdn.net/qsdsn/article/details/77946677" target="_blank" rel="noopener">https://blog.csdn.net/qsdsn/article/details/77946677</a></p>
<h3 id="Next主题网站案例"><a href="#Next主题网站案例" class="headerlink" title="Next主题网站案例"></a>Next主题网站案例</h3><p>yilia主题：    <a href="www.lookk.cn/">www.lookk.cn/</a><br>next主题:        <a href="https://wolzq.com/" target="_blank" rel="noopener">https://wolzq.com/</a>  </p>
<h3 id="Next主题下载"><a href="#Next主题下载" class="headerlink" title="Next主题下载"></a>Next主题下载</h3><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>  themes/next（中间有个空格，指定下载到theme/next目录下）<br>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia </p>
<h3 id="Next主题配置入坑指南"><a href="#Next主题配置入坑指南" class="headerlink" title="Next主题配置入坑指南"></a>Next主题配置入坑指南</h3><p>入坑：FATAL can not read a block mapping entry<br>解决：_config.yml文件中配置格式为属性名+英文冒号+英文空格+属性值，我主题配置项少写了空格导致</p>
<p>入坑：”欢迎您扫一扫上面的微信公众号，订阅我的博客!“显示为中文乱码<br>解决：主题配置文件_config.yml原来的编码为ANSI，不支持中文，只需将配置文件_config.yml保存为UTF-8编码格式。  </p>
<h3 id="Next个性化设置"><a href="#Next个性化设置" class="headerlink" title="Next个性化设置"></a>Next个性化设置</h3><h4 id="GitHub图标"><a href="#GitHub图标" class="headerlink" title="GitHub图标"></a>GitHub图标</h4><p>右上角GitHub图标1：     <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">http://tholman.com/github-corners/</a><br>右上角GitHub图标2：     <a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">https://github.blog/2008-12-19-github-ribbons/</a><br>挑选自己喜欢的样式复制代码，然后粘贴到themes/next/layout/_layout.swig文件中(放在<div class="headband"></div>的下面)</p>
<p>注意：  </p>
<ol>
<li>记得修改href为自己的github地址</li>
<li>可以在style样式自定义GitHub图标显示的位置</li>
</ol>
<h4 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h4><p> 安装字数统计插件：    npm i –save hexo-wordcount<br> 主题配置文件 _config.yml 中打开 wordcount 统计功能<br>打开/themes/next/layout/_macro/post.swig文件，进行如下修改</p>
]]></content>
  </entry>
  <entry>
    <title>Linux命令入门</title>
    <url>/2020/02/17/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>参考原文：<a href="https://man.linuxde.net/" target="_blank" rel="noopener">https://man.linuxde.net/</a><br>参考原文：<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">https://www.linuxcool.com/</a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>格式：命令名称 [命令参数] [命令对象]，  命令参数可以使用长格式或短格式， 两者分别用–与-作为前缀。<br>长格式    man –help<br>短格式     man -h<br>Ctrl + C：终止命令执行<br>在命令末尾添加上一个&amp;符号，命令将进入系统后台来执行，不在屏幕上输出信息</p>
<h3 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a>上传和下载</h3><p>wget：用来从指定的URL下载文件<br>实例： wget  <a href="http://www.linuxde.net/testfile.zip" target="_blank" rel="noopener">http://www.linuxde.net/testfile.zip</a></p>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><ul>
<li>pwd：    显示当前目录  </li>
<li>cd：    进入指定目录   </li>
<li>ls：       显示当前目录文件  </li>
<li>mkdir：    创建目录或者文件  </li>
</ul>
<h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p>打包：把多个目录或文件变为一个文件（打包前后文件大小不变）<br>压缩：将一个大的文件通过一些压缩算法变成一个小文件。（压缩后文件变小）<br>tar  -x 解压缩  -c 创建新文件<br>压　缩：tar -jcv -f filename.tar.bz2  要被压缩的文件或目录名称<br>查　询：tar -jtv -f filename.tar.bz2<br>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录  </p>
<h3 id="字符和文件查找"><a href="#字符和文件查找" class="headerlink" title="字符和文件查找"></a>字符和文件查找</h3><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）<br>gerp：一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来<br>实例：ps -a  mysqld | gerp  </p>
<p>find：文件搜索工具，在指定目录下搜索文件<br>find /home -name “*.txt”     在/home目录下查找以.txt结尾的文件名  </p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>w：    显示已经登陆系统的用户列表，并显示用户正在执行的指令<br>last：显示最近登录用户信息<br>su：    切换为其他用户，eg：su -test            // 切换为test用户<br>useradd：新增用户 ， eg：useradd zwb      // 新增zwb用户<br>sudo：以其他用户身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户</p>
<p>操作系统就好比一个网站，登录用户就好比网站的用户，网站有多个用户，类似地，操作系统也有多个用户，不同用户权限不同<br>多个用户可以同时登录同一网站，类似地，可以有多个用户同时登录操作系统</p>
<p>Linux 系统中用户信息存放在 /etc/passwd 文件中。<br>/etc/passwd 文件将每个用户的基本信息记录为文件中的一行，包括用户名，密码，用户ID，群组ID<br>系统中新建一个用户，新用户的详细信息就会被添加到这个文件中<br>用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码</p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>service：启动、停止、重新启动和关闭系统服务，显示所有系统服务的当前状态<br>格式：service  服务名  ，服务名：自动要控制的服务名，即/etc/init.d目录下的脚本文件名<br>service mysqld start   开启服务<br>service mysqld stop     关闭服务<br>service mysqld restart  重启服务<br>service mysqld status  查看服务运行状态<br>ps：用于报告当前系统的进程状态  </p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器环境搭建</title>
    <url>/2020/02/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>公网IP：        115.29.141.226<br>内网IP：        172.31.162.137<br>实例ID：        i-m5eikb8hczg76dr9g645<br>实例名称：    ZWB999WF  </p>
<h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>Xshell：      <a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a><br>Xftp：      <a href="https://www.netsarang.com/zh/all-downloads/" target="_blank" rel="noopener">https://www.netsarang.com/zh/all-downloads/</a><br>JDK：      <a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a><br>MySQL：  <a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/5.6.html#downloads</a><br>Tomcat：      <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a>  </p>
<h3 id="下载JDK和MySQL的账号和密码"><a href="#下载JDK和MySQL的账号和密码" class="headerlink" title="下载JDK和MySQL的账号和密码"></a>下载JDK和MySQL的账号和密码</h3><p>账号：<a href="mailto:liwei@xiaostudy.com">liwei@xiaostudy.com</a><br>密码：OracleTest1234  </p>
<h3 id="（一）连接阿里云服务器"><a href="#（一）连接阿里云服务器" class="headerlink" title="（一）连接阿里云服务器"></a>（一）连接阿里云服务器</h3><ol>
<li>网页上的workbench连接</li>
<li>网页上的VNC连接</li>
<li>网页上的云命令cloud shell连接</li>
<li>第三方工具连接，如Xshell，Xftp，Putty等，本人采用的是第三方工具连接  </li>
</ol>
<p>Xshell结合Xftp访问云服务器<br>使用Xshell访问Linux系统的时候，经常需要上传和下载文件，文件传输软件Xftp可以和Xshell很好的结合在一起使用。我们在操作Linux服务器的时候都是先使用Xshell的，然后遇到需要上传或下载文件的时候，再打开Xftp。下面就一起来学习用Xshell关联Xftp传输文件。<br>参考原文：<a href="https://blog.csdn.net/longgeaisisi/article/details/78680180" target="_blank" rel="noopener">https://blog.csdn.net/longgeaisisi/article/details/78680180</a></p>
<h3 id="（二）下载配置JDk"><a href="#（二）下载配置JDk" class="headerlink" title="（二）下载配置JDk"></a>（二）下载配置JDk</h3><p>tar -zxvf jdk-8u231-linux-x64.tar.gz<br>vim /etc/profile      编辑配置文件<br>在配置文件后添加下面的内容(我的是直接安装在root目录，所以路径直接写root)<br>export JAVA_HOME=”/root/jdk1.8.0_231”<br>export PATH=”$JAVA_HOME/bin:$PATH”<br>source /etc/profile     刷新配置文件</p>
<h3 id="（三）下载配置Tomcat"><a href="#（三）下载配置Tomcat" class="headerlink" title="（三）下载配置Tomcat"></a>（三）下载配置Tomcat</h3><p>安装命令：tar -zxvf apache-tomcat-8.5.47.tar.gz<br>启动命令：cd apache-tomcat-8.5.47/bin/<br>    ./startup.sh   </p>
<h3 id="（四）下载配置MySQL"><a href="#（四）下载配置MySQL" class="headerlink" title="（四）下载配置MySQL"></a>（四）下载配置MySQL</h3><p>参考原文：<a href="https://www.cnblogs.com/thinkingandworkinghard/p/6711255.html" target="_blank" rel="noopener">https://www.cnblogs.com/thinkingandworkinghard/p/6711255.html</a><br>参考原文：<a href="https://blog.csdn.net/qq_40714770/article/details/84577548" target="_blank" rel="noopener">https://blog.csdn.net/qq_40714770/article/details/84577548</a></p>
<h3 id="安装配置mysql步骤"><a href="#安装配置mysql步骤" class="headerlink" title="安装配置mysql步骤"></a>安装配置mysql步骤</h3><ol>
<li>在Linux上安装mysql</li>
<li>登录mysql，设置root用户的密码</li>
<li>新增zwb用户，设置密码，授予远程访问mysql权限</li>
<li>数据库增删改查</li>
</ol>
<h3 id="在Linux上安装mysql方式"><a href="#在Linux上安装mysql方式" class="headerlink" title="在Linux上安装mysql方式"></a>在Linux上安装mysql方式</h3><ol>
<li>在线安装（yum -y install mysql-community-server  </li>
<li>源码手动编译安装</li>
<li>事先准备好mysql包并通过命令解压tar -xvf mysql-5.7.24-1.el6.x86_64.rpm-bundle.tar通过rpm -vih xx.rpm 依次安装安装</li>
</ol>
<hr>
<p>注：Linux上源码安装mysql需要熟悉yum命令，rpm命令，安装gc++和make编译器（太费时间，容易出错，不采用该方式）</p>
<p>登录mysql，设置root用户的密码<br>     初始登录root用户：      mysql -u root;   （此时root用户密码为空，直接回车）<br>     设置root用户密码：      mysqladmin -u root password 123; (123为密码，也可以写成:’123’或”123”) ；<br>     刷新权限：              flush privileges;<br>     再次登录root用户：      mysql -u root -p; （-u 后跟登入的用户名，-p 提示要密码登入）<br>     退出mysql：              quit或者exit  </p>
<hr>
<p>注：mysql中输入每条SQL命令后需要末尾加”；“（加分号）<br>       mysql中关键字不区分大小写，，列名表名区分大小写，这可在配置文件中修改（mysql的配置文件：my.cnf）<br>修改用户密码或设置权限后，需要使用flush privileges刷新权限后才生效<br>我真是个智障，在workBench中输完SQL命令应该点执行按钮，而不是敲回车  </p>
<p>新增zwb用户，设置密码，授予远程访问mysql权限<br>创建zwb用户，授予zwb权限，使其通过密码可以从任何主机上连接到mysql服务器，命令入下：<br>创建用户：create user ‘zwb’@’%’ identified by ‘@dlmu3709’;   (成功)<br>授予权限：grant select on 数据库.* to 用户名@登录主机 identified by “密码”<br>授予权限：grant select,insert,update,delete on <em>.</em> to zwb@”%” Identified by “123456”;<br>授予权限：grant all on <em>.</em> to ‘zwb’@’%’;<br>刷新权限：flush privileges;<br>配置阿里云安全组规则，开放3306端口  </p>
<h3 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a>数据库增删改查</h3><p>显示数据库：show databases；<br>选择数据库：use 数据库名;<br>显示数据表：show tables；<br>显示表结构：describe  表名；（显示数据库表的列名，列的属性）  </p>
<p>###（五）设置服务开机启动<br>       开启，关闭，重启，查看服务状态<br>格式：service 服务名  start || stop || restart || status<br>实例：</p>
<p>设置MySQL随系统开机启动<br>命令：systemctl enable mysqld<br>命令：systemctl daemon-reload  </p>
<p>关闭防火墙<br>关闭防火墙：sudo systemctl stop firewalld.service<br>关闭开机启动：sudo systemctl disable firewalld.service  </p>
<p>查看MySQL版本<br>登录mysql后输入命令：select version();<br>直接在linux输入命令 rpm -qa|grep mysql  </p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之链表系列[题型篇]</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/</url>
    <content><![CDATA[<h1 id="数据结构与算法之链表系列【题型篇】"><a href="#数据结构与算法之链表系列【题型篇】" class="headerlink" title="数据结构与算法之链表系列【题型篇】"></a>数据结构与算法之链表系列【题型篇】</h1><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E3%80%90%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png?raw=true" alt="æ°æ®ç»æä¸ç®æ³ä¹é¾è¡¨ç³»åãé¢åç¯ãæç»´å¯¼å¾.png"></p>
<br>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.png?raw=true" alt="æ°æ®ç»æä¸ç®æ³ä¹é¾è¡¨ç³»åç®å½.png"></p>
<br>

<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>如果你和小鹿一样，刚开始对链表的操作代码实现很懵的话，不妨按照小鹿经过一个月的时间对链表相关操作以及题型的整理总结，由浅入深进行适当的练习，我相信，当你真正的练习完这些题目，不但会让你失去链表对你心理上的困惑，而且对你学习其他数据结构有很大的信心和帮助！</p>
<br>

<h4 id="1、学习建议"><a href="#1、学习建议" class="headerlink" title="1、学习建议"></a>1、学习建议</h4><p>小鹿不建议你一口气去看完这篇所有的题目和练习，给自己制定一个小计划，我当初整理该题目的时候，每天都计划认真整理一到题目，把每道题分析透，这样才能达到最好的吸收。</p>
<br>

<h4 id="2、学习路径"><a href="#2、学习路径" class="headerlink" title="2、学习路径"></a>2、学习路径</h4><blockquote>
<p>本篇分为三个阶段，基础练习阶段、进阶练习阶段、加强练习阶段。</p>
</blockquote>
<p>1）基础练习阶段</p>
<p>首先进行第一个阶段之前，你已经对链表的基础知识能够熟练掌握，但是对于没有动手写过链表代码，那么你从第一阶段最基础的开始进行。确保每一个基础点要亲自动手用自己熟悉的语言写出来，虽然本篇中基本都是 javascript 代码实现的，但是算法思路是一成不变的，如果遇到困难可以自行百度或谷歌，也可以下方给我进行留言。</p>
<p>2）进阶练习阶段</p>
<p>如果你对上述的链表基本代码已经完全熟练掌握了，那么恭喜你可以进行下一个阶段，进阶阶段，这一阶段增加的难度就是链表的操作是对于实际问题来解决的，所以非常锻炼你对问题的分析能力和解决能力，也考验你对代码的全面性、鲁棒性。这一阶段非常的重要，下面的每道题我都做出了详细的分析。</p>
<p>3）加强练习阶段</p>
<p>如果上述的进阶练习阶段的题型你都了如指掌了，那么不妨我们实战一下，LeetCode 汇聚了很多面试的题型，所以我在上边整理了几个经典的题目，你可以尝试着解答它们，相关题目的代码以及解题思路我都整理好了。这一阶段的题目小鹿会在后期不断的更新，这些题目你能够完全掌握，链表对你来说小菜一碟了。</p>
<br>

<h2 id="一、链表基础练习（阶段一）"><a href="#一、链表基础练习（阶段一）" class="headerlink" title="一、链表基础练习（阶段一）"></a>一、链表基础练习（阶段一）</h2><blockquote>
<p>自己首相尝试着一个个攻破下方的链表中最基础的操作，相关代码我也整理好了（先自己尝试着去解决哦）。</p>
</blockquote>
<ul>
<li><p>单链表的插入、删除、查找操作（<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/SinglyLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>）。</p>
</li>
<li><p>循环链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/CircularLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p>
</li>
<li><p>双向链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/DoubleLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p>
</li>
</ul>
<br>

<h2 id="二、链表进阶练习（阶段二）"><a href="#二、链表进阶练习（阶段二）" class="headerlink" title="二、链表进阶练习（阶段二）"></a>二、链表进阶练习（阶段二）</h2><h3 id="1、单链表从尾到头打印"><a href="#1、单链表从尾到头打印" class="headerlink" title="1、单链表从尾到头打印"></a>1、单链表从尾到头打印</h3><blockquote>
<p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。</p>
</blockquote>
<br>

<h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）看到题目第一想到的就是反转链表在打印输出，一种反转链表的方法，但是这种方法改变了原有的链表结构。</p>
<blockquote>
<p>缺点：使得链表的结构发生改变了。如果不改变链表结构应该怎么解决？</p>
</blockquote>
<p>2）从问题中可以得出，我们想要从尾到头打印链表，正常情况下是从头到尾打印的，我们就会想到最后的数据先打印，开始的数据最后打印，有种“先进后出”的特点，我们就能想到用“栈”这种结构，用栈来实现。</p>
<blockquote>
<p>缺点：代码不够简洁。</p>
<p>优点：鲁棒性好（在不确定的情况下，程序仍然可以正确的执行）。</p>
</blockquote>
<p>3）提到栈这种数据结构，我们就会想到“递归”的实现就是用栈这种数据结构实现的。既然栈能实现，那么递归也能实现。</p>
<blockquote>
<p>缺点：如果链表很长，递归深度很深，导致堆栈溢出。</p>
<p>优点：代码简洁、明了。</p>
</blockquote>
<br>

<h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote>
<p>得出以下几种实现方式：</p>
<ul>
<li>反转链表法</li>
<li>栈实现</li>
<li>递归实现</li>
</ul>
</blockquote>
<p>1）反转链表实现：</p>
<p>从尾到头输出链表的内容，一般的思路就是将链表反转过来，然后从头到尾输出数据。</p>
<p>2）栈实现:</p>
<p>从头到尾遍历单链表，将数据存储按照顺序存储到栈中。然后遍历整个栈，打印输出数据。</p>
<p>3）递归实现：</p>
<p>可以通过递归的方式来实现单链表从尾到头依次输出，递归过程涉及到“递”和“归”，反转链表输出数据，正式利用了循环“递”的过程，所以数据先从头部输出，那么递归采用的是“归”的过程来输出内容，输出当前结点先要输出当前节点的下一节点。</p>
<br>

<h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote>
<p>在写代码之前，要想好测试用例才能写出健全、鲁棒性的代码，也是为了考虑到边界情况，往往也是整个程序最致命的地方，如果考虑不全面，就会出现 bug，导致程序崩溃。</p>
</blockquote>
<p>测试用例：</p>
<p>1）输入空链表；</p>
<p>2）输入的链表只有一个结点；</p>
<p>3）输入的链表有多个结点。</p>
<h6 id="▉-代码实现：反转链表法"><a href="#▉-代码实现：反转链表法" class="headerlink" title="▉ 代码实现：反转链表法"></a>▉ 代码实现：反转链表法</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 功能：单链表反转</span></span><br><span class="line">    <span class="comment">// 步骤:</span></span><br><span class="line">    <span class="comment">// 1、定义三个指针(pre=null/next/current)</span></span><br><span class="line">    <span class="comment">// 2、判断链表是否可反转(头节点是否为空、是否有第二个结点)</span></span><br><span class="line">    <span class="comment">// 3、尾指针指向第一个结点的 next</span></span><br><span class="line">    <span class="comment">// 4、尾指针向前移动</span></span><br><span class="line">    <span class="comment">// 5、当前指针(current)向后移动</span></span><br><span class="line">    <span class="comment">// 6、将 head 指向单转好的结点</span></span><br><span class="line">    reverseList = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//声明三个指针</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">//当前指针指向头节点</span></span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span>;<span class="comment">//尾指针</span></span><br><span class="line">        <span class="keyword">let</span> next;<span class="comment">//指向当前指针的下一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断单链表是否符合反转的条件(一个结点以上)？</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span> || <span class="keyword">this</span>.head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始反转</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = pre;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码实现：循环栈"><a href="#▉-代码实现：循环栈" class="headerlink" title="▉ 代码实现：循环栈"></a>▉ 代码实现：循环栈</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法三：栈实现</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">currentNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">//遍历链表，将数据入栈</span></span><br><span class="line">    <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.data);</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈，数据出栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码实现：递归"><a href="#▉-代码实现：递归" class="headerlink" title="▉ 代码实现：递归"></a>▉ 代码实现：递归</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断是否为空链表</span></span><br><span class="line"><span class="comment">// 2、终止条件（下一结点为空）</span></span><br><span class="line"><span class="comment">// 3、递归打印下一结点信息</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 判断是否空链表</span></span><br><span class="line">	<span class="keyword">if</span>(head !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断下一结点是否为空</span></span><br><span class="line">	    <span class="keyword">if</span>(head.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 下一结点不为空，先输出下一结点</span></span><br><span class="line">	        tailToHeadOutput(head.next)</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">console</span>.log(head.data);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"空链表"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><p>反转链表实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(1)。不需要额外的栈存储空间，空间复杂度为 O(1)。</li>
</ul>
<p>循环栈实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li>
</ul>
<p>递归实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li>
</ul>
<br>

<h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考察内容"><a href="#▉-考察内容" class="headerlink" title="▉ 考察内容"></a>▉ 考察内容</h6><p>1）对单链表的基本操作。</p>
<p>2）代码的鲁棒性。</p>
<p>3）循环、递归、栈的灵活运用。</p>
<br>

<h6 id="▉-扩展思考：循环和递归"><a href="#▉-扩展思考：循环和递归" class="headerlink" title="▉ 扩展思考：循环和递归"></a>▉ 扩展思考：循环和递归</h6><p><strong>适用条件：</strong>如果需要进行多次计算相同的问题，将采用循环或递归的方式。</p>
<p><strong>递归的优点：</strong>代码简洁。</p>
<p><strong>递归的缺点：</strong></p>
<p>1）堆栈溢出：函数调用自身，函数的临时变量是压栈的操作，当函数执行完，栈才清空，如果递归的规模过大，在函数内部一直执行函数的自身调用，临时变量一直压栈，系统栈或虚拟机栈内存小，导致堆栈溢出。</p>
<p>2）重复计算：递归会出现很多的重复计算问题，重复计算对程序的性能有很大影响，导致消耗时间成指数增长，但是可以通过散列表的方式解决。</p>
<p>3）高空间复杂度：递归的每次函数调用都要涉及到在内存开辟空间，压栈、出栈等操作，即耗时又耗费空间，导致递归的效率并不如循环的效率。</p>
<p><strong>扩展：</strong></p>
<p>1）递归—栈：递归的本质是栈，通常用栈循环解决的问题适合于递归。</p>
<p>2）递归-动态规划：动态规划解决问题经常用递归的思路分析问题。关于递归重复计算问题，我们通常使用自下而上的解决思路（动态规划）来解决递归重复计算的问题。</p>
<p>※ 具体看这篇之前写的 8000 字的完整章节：<a href="https://github.com/luxiangqiang/Blog/blob/master/articel/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97.md" target="_blank" rel="noopener">数据结构与算法之递归系列</a></p>
<br>

<h6 id="▉-注意事项："><a href="#▉-注意事项：" class="headerlink" title="▉ 注意事项："></a>▉ 注意事项：</h6><p>1）涉及到循环解决的问题，可以想一想能不能使用递归来解决。</p>
<p>2）用递归解决一定要铭记递归的缺点带来的性能问题。</p>
<p>3）递归解决的问题，能不能用动态规划来解决，使得性能更高。</p>
<p>4）用到栈这种数据结构，想一想递归是否可以实现呢。</p>
<br>

<h3 id="2、删除链表结点"><a href="#2、删除链表结点" class="headerlink" title="2、删除链表结点"></a>2、删除链表结点</h3><blockquote>
<p>题目：在 O（1）的时间复杂度内删除链表节点。</p>
<p>给定单向链表的头指针和一个节点指针，定义一个函数在 O（1）时间内删除该节点。</p>
</blockquote>
<br>

<h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）想必看到单链表删除节点的题，第一想到的就是删除链表结点需要以 O（n）时间复杂度遍历链表找到该结点的前结点，然后以 O（1）时间复杂度进行删除，时间复杂度为O（n）。而题目中的确实整体要求时间复杂度为 O（1）。</p>
<p>2）怎么才能达到 O（1）的时间复杂度删除链表？如果不遍历不就可以了？如果直接删除的时间复杂度为 O（1），前提是我们需要知道前结点才能做到。我们就会想怎么做到不用遍历数据才能获取到前结点呢？而且必须保证时间复杂度为 O（1）。</p>
<p>3）但是必须让自己多想一步就是如果删除的结点是尾结点怎么操作，如果删除的链表结点只有一个结点，即是尾结点又是头结点怎么办？</p>
<br>

<h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>得出以下几种实现方式：</p>
<ul>
<li>交换结点法</li>
</ul>
<p>1）这一有种技巧很难想到，就是我把当前结点的数据与下一结点的数据进行交换，删除下一结点不就可以达到时间复杂度为O（1）了吗。而且我们知道当前结点就是下一结点的前节点，perfect。</p>
<p>2）针对以上两种特殊情况，如果是尾结点，没有下一结点，我们就从头遍历链表删除节点；如果即是尾结点又是头结点，那么删除头结点，并置于 null。</p>
<br>

<h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1)  输入空链表；</p>
<p>2）在多个结点链表中删除中间结点；</p>
<p>3）在多个链表中删除头结点；</p>
<p>4）在多个链表总删除尾结点；</p>
<p>5）在只有一个结点链表中删除唯一结点；</p>
<h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点(核心代码)</span></span><br><span class="line">    deleteNode = <span class="function"><span class="params">node</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前查找的结点是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 1、查找删除的结点</span></span><br><span class="line">        <span class="keyword">let</span> d_node = <span class="keyword">this</span>.findByValue(<span class="built_in">parseInt</span>(node.data))</span><br><span class="line">        <span class="comment">// 2、判断该结点是否为尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(d_node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 重新遍历链表</span></span><br><span class="line">            <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span>(current.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                p = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾结点置为 null</span></span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3、将删除结点的值与下一结点交换</span></span><br><span class="line">            d_node.data = d_node.next.data;</span><br><span class="line">            <span class="comment">// 4、删除下一结点</span></span><br><span class="line">            d_node.next = d_node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">1</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">sortedList1.insert(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">sortedList1.insert(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------删除指定结点----------------------------'</span>)</span><br><span class="line"><span class="keyword">let</span> dnode = <span class="keyword">new</span> Node(<span class="string">'1'</span>)</span><br><span class="line">sortedList1.deleteNode(dnode)</span><br><span class="line">sortedList1.print();</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li><p>时间复杂度：O（1）。经过上述的方法，删除一个链表的结点，除了删除一个链表的尾结点之外，其他删除节点的时间复杂度为 O（1），获取删除的结点的前一结点，时间复杂度为 O（1），删除节点的时间复杂度为 O（1）。只有删除尾结点才需要遍历整个链表，但大部分删除节点是 O（1）的。使用分析时间复杂度的一个方法摊还分析，将删除节点的时间复杂度平均分到其他大部分情况下，所以平均时间复杂度为 O（1）。</p>
</li>
<li><p>空间复杂度：O（1）。不需要额外的内存空间。</p>
</li>
</ul>
<br>

<h4 id="2-2-小结-1"><a href="#2-2-小结-1" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-内容考察"><a href="#▉-内容考察" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的删除基本操作。</p>
<p>2）对问题的有创新思维的解决能力：能不能将复杂问题的根源用另一种思维去优化。</p>
<p>3）问题考虑的全面性：考虑到问题出现的各种特殊情况，以及边界问题。</p>
<br>

<h3 id="3、链表中的倒数第-K-个结点"><a href="#3、链表中的倒数第-K-个结点" class="headerlink" title="3、链表中的倒数第 K 个结点"></a>3、链表中的倒数第 K 个结点</h3><blockquote>
<p>题目：输入一个链表，输出该链表中倒数第 K 个节点。为符合大多数人的习惯，从 1 开始计数，即链表的尾结点是倒数第一个节点。</p>
</blockquote>
<br>

<h4 id="3-1-问题分析与解决"><a href="#3-1-问题分析与解决" class="headerlink" title="3.1 问题分析与解决"></a>3.1 问题分析与解决</h4><h6 id="▉-问题分析-2"><a href="#▉-问题分析-2" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）看到这个题的第一想法就是从链表头遍历到链表尾部，然后尾部倒数 k 个数，因为是单链表，所以倒数并不能实现，想法行不通。</p>
<p>2）那我们只能将思路转移到头结点开始，怎么才能从头结点开始遍历到倒数第 k 个结点呢？大体我们可以得出至少需要遍历两次链表。</p>
<p>3）上述能不能再优化呢？遍历一次链表就可以完成查找？</p>
<br>

<h6 id="▉-算法思路-2"><a href="#▉-算法思路-2" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>得出以下几种实现方式：</p>
<ul>
<li>两次遍历法</li>
<li>一次遍历法</li>
</ul>
<p>前提条件：</p>
<p>1）<strong>不要忘记判断单链表是否为环型结构</strong></p>
<p>两次遍历法：</p>
<p>1）有一个规律就是链表的长度 n 减去 k 加 1 就是倒数第 k 个数据。所以需要遍历链表得到链表的长度，然后再遍历两次找到链表的倒数第 k 个数据。整个过程需要遍历两遍链表。</p>
<p>一次遍历法：</p>
<p>1）那我们就用到双指针，第一个指针指向第一个结点，第二个指针指向 k - 1 个结点，同时向前移动，直到第二个节点指向尾结点位置，第一个节点就指向了倒数第 k 结点。遍历一遍链表就完成查找。</p>
<br>

<h6 id="▉-测试用例-2"><a href="#▉-测试用例-2" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）k 的取值范围（0 &lt; k &lt; n）;输入不在范围内的数据。</p>
<p>2）输入空链表。</p>
<p>3）查找倒数第 k 结点为头结点/尾结点。    </p>
<br>

<h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测单链表是否为环</span></span><br><span class="line">    checkCircle = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span>) <span class="keyword">return</span> fast;</span><br><span class="line">        <span class="comment">// 定义快慢指针</span></span><br><span class="line">        <span class="keyword">let</span> fast = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">let</span> low = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="comment">//进行循环判断(当前 fast 结点/fast 移动两步后的结点是否为 null)</span></span><br><span class="line">        <span class="keyword">while</span>(fast !== <span class="literal">null</span> &amp;&amp; fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// fast 指针向前移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// low 指针向前移动一步</span></span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="comment">// 如果为环，总有一天会相遇</span></span><br><span class="line">            <span class="keyword">if</span>(fast === low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找倒数第 k 结点</span></span><br><span class="line">    findByIndexFromEnd = <span class="function"><span class="params">k</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//判断 k 是否大于0</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'k 的大小不在搜索范围内'</span>;</span><br><span class="line">        <span class="comment">// 检测是否为环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkCircle()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 定义两个指针进行遍历</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> fast = current;</span><br><span class="line">        <span class="keyword">let</span> low = current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= k - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// k 的大小超出链表大小的范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'k 的大小超出链表的范围'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// low 和 fast 指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回倒数第 k 结点</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.insert(<span class="string">'1'</span>,<span class="string">'head'</span>);</span><br><span class="line"><span class="comment">// list.insert('2','1');</span></span><br><span class="line"><span class="comment">// list.insert('3','2');</span></span><br><span class="line"><span class="comment">// list.insert('4','3');</span></span><br><span class="line"><span class="comment">// list.insert('5','4');</span></span><br><span class="line"><span class="comment">// list.insert('6','5');</span></span><br><span class="line">list.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------------------查找倒数第 k 结点----------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list.findByIndexFromEnd(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-2"><a href="#▉-性能分析-2" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><p>两次遍历法：</p>
<ul>
<li>时间复杂度：O（k*n）。当 k 趋近于 n 时，最坏时间复杂度为 O（n^2）。</li>
<li>空间复杂度：O（1）。不需要额外的内存空间。</li>
</ul>
<p>一次遍历法：</p>
<ul>
<li>时间复杂度：O（n）。只需要遍历一次单链表，所以时间复杂度为O（n）。</li>
<li>空间复杂度：O（1）。不需要额外的内存空间。</li>
</ul>
<br>

<h4 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 小结"></a>3.2 小结</h4><h6 id="▉-内容考察-1"><a href="#▉-内容考察-1" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的基本操作。</p>
<p>2）代码的全面性、鲁棒性。</p>
<br>

<h6 id="▉-注意事项"><a href="#▉-注意事项" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）当我们用一个指针不能解决时，想一想两个指针能否解决？</p>
<br>

<h6 id="▉-相关题目"><a href="#▉-相关题目" class="headerlink" title="▉ 相关题目"></a>▉ 相关题目</h6><p>1）求中间结点</p>
<p>2）求倒数第 k 个结点</p>
<p>3）检测环的存在</p>
<br>

<h3 id="4、反转链表"><a href="#4、反转链表" class="headerlink" title="4、反转链表"></a>4、反转链表</h3><blockquote>
<p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转链表的头结点。</p>
</blockquote>
<br>

<h4 id="4-1-问题分析与解决"><a href="#4-1-问题分析与解决" class="headerlink" title="4.1 问题分析与解决"></a>4.1 问题分析与解决</h4><h6 id="▉-问题分析-3"><a href="#▉-问题分析-3" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）反转链表的我们第一能够想到的方法就是最常用的方法，声明三个指针，把头结点变为尾结点，然后下一结点拼接到尾结点的头部，一次类推。说白了就是就是直接将链表指针反转就可以实现反转链表。</p>
<br>

<h6 id="▉-算法思路-3"><a href="#▉-算法思路-3" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>1）定义三个指针，分别为 Pnext、pre、current，current 存储当前结点， pre 指向反转好的结点的头结点，Pnext 存储下一结点信息。</p>
<p>2）判断当前结点是否可以反转（是否为空链表或链表大于 1 个结点）?</p>
<p><strong>步骤：</strong></p>
<p>1）Pnext 指针存储下一结点 。</p>
<p>2）当前结点的 next 结点是否为 null (为 null 的话当前结点就是最后的一个结点)，如果为 null，将当前节点赋值为 head 头指针（断裂处）。</p>
<p>3）将 pre 指针指向的结点赋值当前节点 current 的下一结点 next。</p>
<p>4）然后让 pre 指针指向当前节点 current。</p>
<p>5）current 继续遍历, 当前节点指向 current 指向 Pnext。</p>
<p><strong>递归法（重点分析）：</strong></p>
<p>1）先确定终止条件：当下一结点为  null  时，返回当前节点；</p>
<p>2）判断当前的链表是否为  null；</p>
<p>3）递归找到尾结点，将其存储为头结点。</p>
<p>4）此时递归的层次是第二层递归，所以要设置为头结点的下一结点就是当前第二层结点，并且将第二节点的下一结点设置为 bull。</p>
<br>

<h6 id="▉-测试用例-3"><a href="#▉-测试用例-3" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）链表是空链表。</p>
<p>2）当前链表的长度小于等于 1。</p>
<p>3）输入长度大于 1 的链表。</p>
<br>

<h6 id="▉-代码实现-2"><a href="#▉-代码实现-2" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义三个指针</span></span><br><span class="line">    <span class="keyword">let</span> [current,prev,next] = [head,<span class="literal">null</span>,<span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//1、存储下一结点</span></span><br><span class="line">        next = current.next;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-递归法"><a href="#▉-递归法" class="headerlink" title="▉ 递归法"></a>▉ 递归法</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//如果链表为空或者链表中只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//先反转后面的链表，走到链表的末端结点</span></span><br><span class="line">        <span class="keyword">let</span> newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//再将当前节点设置为后面节点的后续节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-3"><a href="#▉-性能分析-3" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li>时间复杂度：O(n)。只需遍历整个链表就可以完成反转，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(1)。只需要常量级的空间，空间复杂度为 O(1)。</li>
</ul>
<br>

<h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><h6 id="▉-内容考察-2"><a href="#▉-内容考察-2" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的基本操作。</p>
<p>2）对指针操作顺序的逻辑性考察。</p>
<p>3）考察思维的全面性以及代码的鲁棒性。</p>
<br>

<h6 id="▉-注意事项-1"><a href="#▉-注意事项-1" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）边界条件。</p>
<p>2）写代码之前想好测试用例，写完代码一一验证测试用例的正确性。</p>
<br>

<h3 id="5、合并两个有序链表"><a href="#5、合并两个有序链表" class="headerlink" title="5、合并两个有序链表"></a>5、合并两个有序链表</h3><blockquote>
<p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
</blockquote>
<br>

<h4 id="5-1-问题分析与解决"><a href="#5-1-问题分析与解决" class="headerlink" title="5.1 问题分析与解决"></a>5.1 问题分析与解决</h4><h6 id="▉-问题分析-4"><a href="#▉-问题分析-4" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）合并两个链表，经常犯的错误就是没有弄清除指针的指向，导致链表合并的时候断裂以及代码全面性考虑的不全，也就是代码的鲁棒性存在问题。</p>
<p>2）递归。每次都要比较两个结点大小，是否可以使用递归来解决呢？</p>
<br>

<h6 id="▉-算法思路-4"><a href="#▉-算法思路-4" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p><strong>一般解决法：</strong></p>
<p>1）合并两个链表，首先需要两个指针，分别指向两个链表。</p>
<p>2）比较两个指针指向结点元素的大小，小的结点添加到新链表，然后指针向后移动继续比较。</p>
<p>3）直到其中一个链表没有结点了，另一个链表存在结点，将剩余的结点加入到新链表的尾部，完成合并。</p>
<p><strong>递归法：（满足递归的三个条件）</strong></p>
<p>比较当前结点大小先比较下一结点的大小。</p>
<p>1）结点之间的比较可以分的子问题为每个节点的比较。</p>
<p>2）终止条件：其中一个链表结点为 null。</p>
<p>3）子问题和总问题具有相同的解决思路。</p>
<br>

<h6 id="▉-测试用例-4"><a href="#▉-测试用例-4" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）输入两个空链表。</p>
<p>2）其中一个链表为空链表。</p>
<p>3）输入两个完整的链表。</p>
<br>

<h6 id="▉-代码实现-3"><a href="#▉-代码实现-3" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能:两个有序链表的合并</span></span><br><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断两个链表是否为 null,并将链表赋予临时变量</span></span><br><span class="line"><span class="comment">// 2、声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line"><span class="comment">// 3、两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line"><span class="comment">// 4、将链表剩余数据添加到合并链表后边</span></span><br><span class="line"><span class="keyword">const</span> mergeSortList = <span class="function">(<span class="params">listA,listB</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(listA === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(listB === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> a = listA;</span><br><span class="line">    <span class="keyword">let</span> b = listB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line">    <span class="keyword">let</span> resultList = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">        resultList = a</span><br><span class="line">        a = a.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultList = b</span><br><span class="line">        b = b.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = resultList;</span><br><span class="line">    <span class="keyword">while</span> (a !== <span class="literal">null</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">            currentNode.next = a</span><br><span class="line">            a = a.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentNode.next = b</span><br><span class="line">            b = b.next</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode.next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表剩余数据添加到合并链表后边 </span></span><br><span class="line">    <span class="keyword">if</span>(a !== <span class="literal">null</span>)&#123;</span><br><span class="line">        currentNode.next = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        currentNode.next = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回合并链表</span></span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-递归实现"><a href="#▉-递归实现" class="headerlink" title="▉ 递归实现"></a>▉ 递归实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeTwoLists(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码测试"><a href="#▉-代码测试" class="headerlink" title="▉ 代码测试"></a>▉ 代码测试</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="keyword">var</span> mergeSortList = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeSortList(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeSortList(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">9</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">8</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">7</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">6</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line">sortedList2 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList2.insert(<span class="number">21</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">20</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">19</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">18</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------合并两个有序的链表----------------'</span>)</span><br><span class="line"><span class="keyword">let</span> resultList = mergeSortList(sortedList1.head.next,sortedList2.head.next)</span><br><span class="line"><span class="keyword">while</span> (resultList !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resultList.date);</span><br><span class="line">    resultList = resultList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-4"><a href="#▉-性能分析-4" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li>时间复杂度：O（n）。n 为较短的链表的长度。</li>
<li>空间复杂度：O（n+m）。需要额外的 n+m(两个链表长度之和) 大小的空间来存储合并的结点。</li>
</ul>
<br>

<h4 id="5-2-小结"><a href="#5-2-小结" class="headerlink" title="5.2 小结"></a>5.2 小结</h4><h6 id="▉-内容考察-3"><a href="#▉-内容考察-3" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对链表的基本操作。</p>
<p>2）写代码考虑问题的全面性和鲁棒性。</p>
<br>

<h6 id="▉-注意事项-2"><a href="#▉-注意事项-2" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）递归实现，注意递归解决问题的三个缺点。</p>
<ul>
<li>堆栈溢出</li>
<li>重复数据</li>
<li>高空间复杂度</li>
</ul>
<br>

<h2 id="三、LeetCode-加强练习阶段（阶段三）"><a href="#三、LeetCode-加强练习阶段（阶段三）" class="headerlink" title="三、LeetCode 加强练习阶段（阶段三）"></a>三、LeetCode 加强练习阶段（阶段三）</h2><blockquote>
<p>如果你对基本的链表操作已经掌握，想进一步提高对链表熟练度的操作，可以练习一下 LeetCode 题目。每道题我都做了详细的解析，如：问题分析、算法思路、代码实现、考查内容等，有关链表的相关题目会不断更新……</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表 I</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle.md" target="_blank" rel="noopener">题目解析</a> )</li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle2.md" target="_blank" rel="noopener">题目解析</a> )</li>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/MergekSortedLists.md" target="_blank" rel="noopener">题目解析</a> )</li>
</ul>
<br>

<h2 id="四、链表总结"><a href="#四、链表总结" class="headerlink" title="四、链表总结"></a>四、链表总结</h2><blockquote>
<p>做了大量有关链表的题型之后，对链表的操作做一个总结和复盘，对链表有一个整体的把握和重新的认识。</p>
</blockquote>
<br>

<h4 id="1、结构上"><a href="#1、结构上" class="headerlink" title="1、结构上"></a>1、结构上</h4><p>① 存储链表的内存空间是不连续的，所有需要使用指针将这些零碎内存空间连接起来，导致需要通过指针来进行操作，这也是为什么链表中大多数都是关于指针的操作的原因。</p>
<p>② 链表在结构上有两个特殊的地方就是链表头和链表尾，很多操作都要对链表头和链表尾进行特殊处理，所以我们可以借助哨兵思想（在链表头添加一个哨兵），这样带头的链表可以简化问题的解决。</p>
<br>

<h4 id="2、操作上"><a href="#2、操作上" class="headerlink" title="2、操作上"></a>2、操作上</h4><p>① 递归：链表中的很多操作都是可以用递归来进行解决的，因为链表的每个结点都有着相同的结构，再加上解决的问题可以分解为子问题进行解决。所以在链表中递归编程技巧还是非常常用的。如：从尾到头打印链表、合并两个有序链表、反转链表等。</p>
<p>② 双指针：链表中大部分都是进行指针操作，链表属于线性表结构（形如一条线的结构），很多问题可以使用双指针来解决，也是非常常用到的。如：查找倒数第K 结点、求链表的中间结点等。</p>
<br>

<h4 id="3、性能上"><a href="#3、性能上" class="headerlink" title="3、性能上"></a>3、性能上</h4><p>① 链表正是因为存储空间不连续，对 CPU 缓存不友好，随时访问只能从头遍历链表，时间复杂度为 O（n），但是链表的这种结构也有个好处就是。可以动态的申请内存空间，不需要提前申请。</p>
<p>② 指针的存储是需要额外的内存空间的，如果存储的数据远大于存储指针的内存空间，可以进行忽略。</p>
<hr>

<p><strong>作者：</strong>小鹿</p>
<p><strong>座右铭：</strong>追求平淡不平凡，一生追求做一个不甘平凡的码农!</p>
<p><strong>本文首发于 Github ，转载请说明出处：</strong><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之链表系列[题型篇].md" target="_blank" rel="noopener">https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之链表系列[题型篇].md</a></p>
<p><strong>个人公众号：「一个不甘平凡的码农」。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之二叉树系列[题型篇]</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/</url>
    <content><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>不知道你有没有这种困惑，虽然刷了很多算法题，当我去面试的时候，面试官让你手写一个算法，可能你对此算法很熟悉，知道实现思路，但是总是不知道该在什么地方写，而且很多边界条件想不全面，一紧张，代码写的乱七八糟。如果遇到没有做过的算法题，思路也不知道从何寻找，那么这篇文章就主要为你解决这几个问题。</p>
<p>《剑指 offer》是准备数据结构与算法面试的一本好书，里边很多面试手写算法很多的注意的问题，但是基本都是用 C++ 实现的，书中每章节的分类都是按照性能和消耗以及手写代码的注意的几大点进行了分类，针对每个不同的点，进行数据结构与算法的混合实现。</p>
<p>二遍刷题，发现了还可以根据自身情况进行整理和分类。全部代码是用 JS 书写，都经过 Leetcode 标准测试（小部分Leetcode 没有的题目），对所有的算法题的特点进行总结分类，手写算法中，如何考虑到全部的边界条件；如果快速多种思路解决，如何将思路快速的转化为代码，这是这一篇重点分享的地方。</p>
<p>二叉树题目共有 11 题，我把这 11 题书中对实现方法和思路有详细的讲解，但是对于个人来说，以后遇到陌生的二叉树的题目怎么进行解决，通过对 11 个题的分析、整理，得出以下几个步骤，首先先来看这 11 个二叉树经典算法题。</p>
<p><strong>PS：</strong>如果你已经做过这几道题，而且能够顺利的手写出来，不妨滑到最底部，希望最后的二叉树思路、测试用例以及代码编写的总结对你在面试中有所帮助（这篇文章精华所在）。</p>
<h3 id="一、面试题7：重建二叉树"><a href="#一、面试题7：重建二叉树" class="headerlink" title="一、面试题7：重建二叉树"></a>一、面试题7：重建二叉树</h3><blockquote>
<p>已知前序遍历为{1,2,4,7,3,5,6,8}，中序遍历为{4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？</p>
</blockquote>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h4><p>根据前、中序遍历的特点，（根左右、左根右），先根据前序遍历确定根节点，然后在中序遍历知道该根节点的左右树的数量，反推出前序遍历中左子树的结点有哪些。根据该思路进行递归即可完成二叉树的重建。</p>
<h4 id="2、测试用例"><a href="#2、测试用例" class="headerlink" title="2、测试用例"></a>2、测试用例</h4><ul>
<li><p>完全二叉树、非完全二叉树 —— 普通测试。</p>
</li>
<li><p>只有左子节点二叉树，只有右子节点、只有一个结点的二叉树 —— 特殊二叉树测试。</p>
</li>
<li><p>空树、前序和中序不匹配 —— 输入测试。</p>
</li>
</ul>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// 定义结点</span></span><br><span class="line"> <span class="number">2</span><span class="comment">// class TreeNode&#123;</span></span><br><span class="line"> <span class="number">3</span><span class="comment">//     constructor(data)&#123;</span></span><br><span class="line"> <span class="number">4</span><span class="comment">//         this.data = data;</span></span><br><span class="line"> <span class="number">5</span><span class="comment">//         this.left = null;</span></span><br><span class="line"> <span class="number">6</span><span class="comment">//         this.right = null;</span></span><br><span class="line"> <span class="number">7</span><span class="comment">//     &#125; </span></span><br><span class="line"> <span class="number">8</span><span class="comment">// &#125;</span></span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span><span class="comment">// 参数：前序遍历数组 ~ 中序遍历数组</span></span><br><span class="line"><span class="number">11</span><span class="keyword">const</span> reConstructBinaryTree = <span class="function">(<span class="params">pre, vin</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="number">12</span>    <span class="comment">// 判断前序数组和中序数组是否为空</span></span><br><span class="line"><span class="number">13</span>    <span class="keyword">if</span>(!pre || pre.length === <span class="number">0</span> || !vin || vin.length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">14</span>        <span class="keyword">return</span>;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line"><span class="number">16</span>    <span class="comment">// 新建二叉树的根节点</span></span><br><span class="line"><span class="number">17</span>    <span class="keyword">var</span> treeNode = &#123;</span><br><span class="line"><span class="number">18</span>        val: pre[<span class="number">0</span>]</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="comment">// 查找中序遍历中的根节点</span></span><br><span class="line"><span class="number">21</span>    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line"><span class="number">22</span>        <span class="keyword">if</span> (vin[i] === pre[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="number">23</span>            <span class="comment">// 将左子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">24</span>            treeNode.left = reConstructBinaryTree(pre.slice(<span class="number">1</span>, i+<span class="number">1</span>), vin.slice(<span class="number">0</span>, i));</span><br><span class="line"><span class="number">25</span>            <span class="comment">// 将右子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">26</span>            treeNode.right = reConstructBinaryTree(pre.slice(i+<span class="number">1</span>),vin.slice(i+<span class="number">1</span>));</span><br><span class="line"><span class="number">27</span>        &#125;</span><br><span class="line"><span class="number">28</span>    &#125;</span><br><span class="line"><span class="number">29</span>    <span class="comment">// 返回该根节点</span></span><br><span class="line"><span class="number">30</span>    <span class="keyword">return</span> treeNode;</span><br><span class="line"><span class="number">31</span>&#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span><span class="keyword">let</span> pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="number">34</span><span class="keyword">let</span> vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line"><span class="number">35</span><span class="built_in">console</span>.log(reConstructBinaryTree(pre,vin));</span><br></pre></td></tr></table></figure>



<h3 id="二、面试题8：二叉树的下一节点"><a href="#二、面试题8：二叉树的下一节点" class="headerlink" title="二、面试题8：二叉树的下一节点"></a>二、<strong>面试题8：二叉树的下一节点</strong></h3><blockquote>
<p>给定一个二叉树的节点，如何找出中序遍历的下一节点。有两个指向左右子树的指针，还有一个指向父节点的指针。</p>
</blockquote>
<h4 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h4><p>求中序遍历的下一节点，就要分各种情况（明确中序遍历下一结点在二叉树中的位置有哪些），然后对某种情况详细分析。</p>
<p>下一结点可能存在的情况：</p>
<ul>
<li>有右子节点<ul>
<li>右子节点有无左子节点<ul>
<li>无 —— 右子节点就是当前结点下一节</li>
<li>有 —— 递归寻找右子节点的左子节点就是下一节点</li>
</ul>
</li>
</ul>
</li>
<li>无右子节点<ul>
<li>无父节点 —— 无下一结点</li>
<li>有父节点<ul>
<li>当前结点作为父节点的左子节点 —— 下一结点为父节点</li>
<li>当前结点作为父节点的右子节点 —— 向父节点递归寻找作为左子节点的结点就是下一节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、测试用例"><a href="#二、测试用例" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通测试 —— 完全二叉树、非完全二叉树</li>
<li>特殊测试 —— 只要左子节点的二叉树、只有右子节点的二叉树、只有一个结点</li>
<li>输入测试 —— 空节点</li>
</ul>
<h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getNextNode = <span class="function">(<span class="params">pNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断该结点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前结点有右子树且左子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">        pNode = pNode.right;</span><br><span class="line">        <span class="comment">// 判断右子树是否有左子树</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前结点是否存在父节点(如果为空,没有下一结点)</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode == pNode.next.left)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有下一结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、面试题26：树的子结构"><a href="#三、面试题26：树的子结构" class="headerlink" title="三、面试题26：树的子结构"></a>三、面试题26：树的子结构</h3><blockquote>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p>
</blockquote>
<h4 id="一、思路-1"><a href="#一、思路-1" class="headerlink" title="一、思路"></a>一、思路</h4><p>通过判断两棵树的根节点否相同，如果相同，则递归判断树剩余的结点是否相同。如果不相同，则递归树的左右子节点进行对比找到相同的根节点。</p>
<h4 id="二、测试用例-1"><a href="#二、测试用例-1" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>是子结构、不是子结构 —— 普通测试。</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试。</li>
<li>空树 —— 输入测试。</li>
</ul>
<h4 id="三、代码实现-1"><a href="#三、代码实现-1" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TreeConstrutor = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断输入是否为 null</span></span><br><span class="line">    <span class="comment">// nodeA 为 null 不会有子结构</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 如果 nodeB 为 null,代表所有子结构比较完成</span></span><br><span class="line">    <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点相同，则进行子结构全部的验证,返回验证的结果</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA.data === nodeB.data)&#123;</span><br><span class="line">       result = match(nodeA, nodeB)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点不相同，继续递归遍历查找相同的根节点</span></span><br><span class="line">    <span class="keyword">return</span> TreeConstrutor(nodeA.left, nodeB) || TreeConstrutor(nodeA.right, nodeB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配根节点相同的子结构</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 判断匹配的当前结点是否相同</span></span><br><span class="line">     <span class="keyword">if</span>(nodeA.data == nodeB.data)&#123;</span><br><span class="line">         <span class="comment">// 递归匹配其他子节点</span></span><br><span class="line">    	<span class="keyword">return</span> match(nodeA.left, nodeB.left) &amp;&amp; match(nodeA.right, nodeB.right);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、面试题27：二叉树的镜像"><a href="#四、面试题27：二叉树的镜像" class="headerlink" title="四、面试题27：二叉树的镜像"></a>四、<strong>面试题27：二叉树的镜像</strong></h3><blockquote>
<p>请完成一个函数，如果一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<h4 id="一、思路-2"><a href="#一、思路-2" class="headerlink" title="一、思路"></a>一、思路</h4><p>根节点的左右子节点相互交换，继续递归遍历，将子节点的左右结点进行交换，知道遇到叶子节点。</p>
<h4 id="二、测试用例-2"><a href="#二、测试用例-2" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码实现-2"><a href="#三、代码实现-2" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     	<span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行结点交换</span></span><br><span class="line">    Let tempNode = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tempNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历剩余的子节点</span></span><br><span class="line">    insert(root.left);</span><br><span class="line">    insert(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、面试题28：对称二叉树"><a href="#五、面试题28：对称二叉树" class="headerlink" title="五、面试题28：对称二叉树"></a>五、<strong>面试题28：对称二叉树</strong></h3><h4 id="一、思路-3"><a href="#一、思路-3" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、首先，观察一个对称的二叉树有什么特点？</p>
<ul>
<li>结构上：在结构上实对称的，某一节点的左子节点和某一节点的右子节点对称。</li>
<li>规律上：我们如果进行前序遍历（根、左、右），然后对前序遍历进行改进（根、右、左），如果是对称的二叉树，他们的遍历结果是相同的。</li>
</ul>
<p>2、考虑其他情况</p>
<ul>
<li>结点数量不对称</li>
<li>结点值不对称</li>
</ul>
<h4 id="二、测试用例-3"><a href="#二、测试用例-3" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li><p>对称二叉树、不对称二叉树（结点数量不对称、结点结构不对称） —— 普通测试</p>
</li>
<li><p>所有结点值都相同的二叉树 —— 特殊测试</p>
</li>
<li><p>空二叉树 —— 输入测试</p>
</li>
</ul>
<h4 id="三、代码编写"><a href="#三、代码编写" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断二叉树是否为 null —— 输入测试，                                                     	  if(root == null)&#123;</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断输入的二叉树,从根节点开始判断是否是对称二叉树</span></span><br><span class="line">	<span class="keyword">var</span> Symmetric = <span class="function">(<span class="params">lNode, rNode</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断左右结点是否都为 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 判断其中一个为 null 另一个不是 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(lNode !== <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 判断两个结点的值是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(lNode.val !== rNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相同，继续递归判断其他的结点</span></span><br><span class="line">        <span class="keyword">return</span> Symmetric(lNode.left,rNode.right) &amp;&amp; Symmetric(lNode.right,rNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Symmetric(root.left,root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="六、面试题32：从上到下打印二叉树"><a href="#六、面试题32：从上到下打印二叉树" class="headerlink" title="六、面试题32：从上到下打印二叉树"></a>六、面试题32：从上到下打印二叉树</h3><blockquote>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。（按层遍历二叉树）</p>
</blockquote>
<h4 id="一、思路-4"><a href="#一、思路-4" class="headerlink" title="一、思路"></a>一、思路</h4><p>从根节点开始按层遍历打印结点（自左往右），下一层的遍历是上一层的字节点，但是我们发现想要获取到上层结点的子节点时，上层的父节点已经遍历过去可，想要在获取到，必须存储父节点。然后下层遍历的时候，自左往右取出父节点，依次打印子节点。</p>
<p>上方的解题思路中父节点的存储和遍历让我们想到一个熟悉的数据结构，对了，“先进先出”的思想，那就是队列。在遍历上一层结点的时候，先打印结点值，然后判断是够存在左右子树，如果存在，将给结点入队，直到该层的结点全部遍历完成。然后队列出队，分别打印结点，循环此步骤。</p>
<h4 id="二、测试用例-4"><a href="#二、测试用例-4" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左、右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-1"><a href="#三、代码编写-1" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：树的根节点。</li>
<li>判断是否为空。</li>
<li>打印结点值,判断该结点是否存在子节点，如果存在就入队。</li>
<li>出队，打印结点</li>
<li>循环上述步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = []; <span class="comment">// 存放遍历的结果</span></span><br><span class="line"> 	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明一个队列</span></span><br><span class="line">   <span class="keyword">let</span> queue = [];</span><br><span class="line">   queue.push(root)</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 出队，打印结结点、判断是否存在子节点</span></span><br><span class="line">   <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> temp = [];             <span class="comment">// 存储每层的结点</span></span><br><span class="line">       <span class="keyword">let</span> len = queue.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line">           <span class="comment">// 出队</span></span><br><span class="line">           <span class="keyword">let</span> tempNode = queue.shift(); </span><br><span class="line">           <span class="comment">// 存储结点值</span></span><br><span class="line">           temp.push(tempNode.val)		  </span><br><span class="line">           <span class="comment">// 判断出队的根节点是否有子节点</span></span><br><span class="line">           <span class="keyword">if</span>(tempVal.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(tempVal.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//存储每层的遍历的结点值</span></span><br><span class="line">       result.push(temp);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回结果集</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、面试题33：二叉树的后序遍历序列"><a href="#七、面试题33：二叉树的后序遍历序列" class="headerlink" title="七、面试题33：二叉树的后序遍历序列"></a>七、<strong>面试题33：二叉树的后序遍历序列</strong></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历。如果是返回 true，如果不是返回 false。假设输入的任意两个数字互不相同。</p>
<h4 id="一、思路-5"><a href="#一、思路-5" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>根据后续遍历的规律和二叉树具备的特点</strong>，可以找到的规律就是（左、右、根）序列的最后一个数为根节点，又根据二叉树的特点，左子节点小于根节点，右子节点大于根节点，分离出左右子节点，根据上边的规律，<strong>递归</strong>剩下的序列。</p>
<h4 id="二、测试用例-5"><a href="#二、测试用例-5" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、不完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-2"><a href="#三、代码编写-2" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：数组</li>
<li>判断数组是否为空</li>
<li>取数组的最后一个元素作为对比的根节点</li>
<li>根据根节点值的大小分割数组（分割数组的同时判断是否都满足小于根节点的要求）</li>
<li>判断分割数组是否是空</li>
<li>递归上方的步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPostorder = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">  	<span class="comment">// 判断数组是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取数组最后一个数字为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = arr[arr.length - <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索小于根节点的值,并记录该结点的下标(除根节点外)</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; rootVal)&#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索大于根节点的值（除根节点外）</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j &lt; arr.length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rootVal &gt; arr[j])&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子节点的值（先判断左子节点是够有值），默认返回 true</span></span><br><span class="line">     <span class="keyword">let</span> left = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         left = isPostorder(arr.slice(<span class="number">0</span>, i))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果右子树不为空，判断右子树为二叉搜索树</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">        right = isPostorder(arr.slice(i,arr.length - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、面试34：二叉树和为某一值路径"><a href="#八、面试34：二叉树和为某一值路径" class="headerlink" title="八、面试34：二叉树和为某一值路径"></a>八、<strong>面试34：二叉树和为某一值路径</strong></h3><blockquote>
<p> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输出整数的所有路径。从树的根节点开始往下一直到叶子节点所经过的节点形成一条路径。</p>
</blockquote>
<h4 id="一、思路-6"><a href="#一、思路-6" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>1、找规律：</strong>需要遍历树的所有结点：我们会想到前、中、后遍历</p>
<pre><code>:  需要存储遍历过的路径（节点值）：我们想到用数组存储</code></pre><p><strong>2、算法思想：</strong>前序遍历（根、左、右）的特点，从根到叶子节点，会从树自左向右依次遍历二叉树，所有可能的路径都会遍历到，所以使用前序遍历更佳。</p>
<p>每遍历一个结点就将其累加，然后判断累加的值是否等于目标值且子节点为叶子节点。如果是，则打印输出该路径；如果不是，则回退到上一父节点，此时数组中的数据结点进行删除，然后不断的遍历下一子节点，递归。</p>
<p><strong>3、综上所述，</strong>存储结点路径的时候，涉及到累加结点和删除节点，我们可以将其抽象成入栈和出栈。然后遍历二叉树的所有路径可以用到递归的过程，让出栈和入栈与递归的状态达成一致，这到题就不难了。</p>
<h4 id="二、测试用例-6"><a href="#二、测试用例-6" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树（有一条路径满足、有多条路径满足、都不满足）—— <strong>普通测试</strong>。</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个结点的二叉树 —— <strong>特殊测试</strong>。</li>
<li>空二叉树、输入负数 —— <strong>输入测试</strong>。</li>
</ul>
<h4 id="三、代码编写-3"><a href="#三、代码编写-3" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：二叉树、目标值</li>
<li>判断二叉树是否为空和目标是是否是负数</li>
<li>开始进行递归遍历二叉树进行查找满足条件的路径<ul>
<li>将当前递归的根节点进行累加</li>
<li>同时该结点入栈</li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treeSum = <span class="function">(<span class="params">root, targetSum</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断输入的二叉树和整数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span> || targetSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始进行递归遍历二叉树进行查找满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> result = [];    <span class="comment">// 存放最后满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> pathStack = []; <span class="comment">// 储存当前路径的栈</span></span><br><span class="line">    <span class="keyword">let</span> currentSum = <span class="number">0</span>; <span class="comment">// 当前累加的结果值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 进行路径查找</span></span><br><span class="line">    FindPath(root, targetSum, currentSum, pathStack, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FindPath = <span class="function">(<span class="params">root, targetSum, currentSum, pathStack, result</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 将当前跟根节点进行累加</span></span><br><span class="line">    	currentSum = currentSum + root.val;</span><br><span class="line">    	</span><br><span class="line">      <span class="comment">// 存储栈中</span></span><br><span class="line">      pathStack.push(root.val);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 判断目标值是否相等且是否为叶子节点</span></span><br><span class="line">    	<span class="keyword">if</span>(currentSum == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">// 打印路径</span></span><br><span class="line">          result.push(pathStack.slice(<span class="number">0</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 如果左子节点不为空</span></span><br><span class="line">      <span class="keyword">if</span>(root.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.left, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前结点还有右子树，继续遍历</span></span><br><span class="line">      <span class="keyword">if</span>(root.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.right, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 该路径遍历到叶子节点，还没有满足条件，则退回到父节点，进行下一结点的累加判断</span></span><br><span class="line">      pathStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h4><ul>
<li><p>当问题能够用递归去解决的时候，首先找到递归的点，比如二叉树的中的每个节点就是递归的点。</p>
</li>
<li><p>当使用递归解决满足条件的问题时，直接每层递归进行判断，如果满足条件就处理，否则，递归自动跳过 if 判断。</p>
</li>
</ul>
<h3 id="九、面试题37：序列化二叉树"><a href="#九、面试题37：序列化二叉树" class="headerlink" title="九、面试题37：序列化二叉树"></a>九、<strong>面试题37：序列化二叉树</strong></h3><p>请实现两个函数，分别用来序列化二叉树和反序列化二叉树。</p>
<h4 id="一、思路-7"><a href="#一、思路-7" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、序列化：遍历二叉树，遇到叶子节点，将其转化为 $ 表示。</p>
<p>2、反序列化：根据前序遍历的特点（根、左、右），进行二叉树的还原。</p>
<h4 id="二、测试用例-7"><a href="#二、测试用例-7" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个节点 —— 特殊测试</li>
<li>空数组、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-4"><a href="#三、代码编写-4" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        result.push(<span class="string">'$'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    result.push(root.val)</span><br><span class="line">    serialize(root.left)</span><br><span class="line">    serialize(root.right)</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">serialize(symmetricalTree);</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化二叉树</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈队判断</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> val = arr.shift();</span><br><span class="line">    <span class="keyword">if</span>(val !== <span class="string">'$'</span>)&#123;</span><br><span class="line">        node = &#123;</span><br><span class="line">            val: val</span><br><span class="line">        &#125;;</span><br><span class="line">        node.left = deserialize(arr);</span><br><span class="line">        node.right = deserialize(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'8,6,5,$,$,7,$,$,6,7,$,$,5,$,$'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(deserialize(str.split(<span class="string">','</span>)));</span><br></pre></td></tr></table></figure>



<h3 id="十、面试题54：二叉树的第-K-大节点"><a href="#十、面试题54：二叉树的第-K-大节点" class="headerlink" title="十、面试题54：二叉树的第 K 大节点"></a>十、<strong>面试题54：二叉树的第 K 大节点</strong></h3><blockquote>
<p>给定一棵二叉搜索树，请找出其中的第 K 大节点。</p>
</blockquote>
<h4 id="一、思路-8"><a href="#一、思路-8" class="headerlink" title="一、思路"></a>一、思路</h4><p>要想找到第 K 大结点必要要知道排序，二叉树的前、中、后遍历中的中序遍历就是从小到大排序。然后遍历的同时计数找到第 K 大节点。</p>
<h4 id="二、测试用例-8"><a href="#二、测试用例-8" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>K 的范围、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-5"><a href="#三、代码编写-5" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求二叉树中第 K 大节点</span></span><br><span class="line"><span class="keyword">var</span> kthTallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  <span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">      inorder(root.left);</span><br><span class="line">      res.push(root.val);</span><br><span class="line">      inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="keyword">return</span> res[res.length - k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="十一、面试题55：二叉树的深度"><a href="#十一、面试题55：二叉树的深度" class="headerlink" title="十一、面试题55：二叉树的深度"></a>十一、<strong>面试题55：二叉树的深度</strong></h3><p>  输入一棵二叉树的根节点，求该树的深度。从根节点到叶子节点依次经过的节点（包含根、叶子节点）形成树的一条路径，最长路径的长度树的深度。</p>
<h4 id="一、思路-9"><a href="#一、思路-9" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、思路一：按层遍历，对按层遍历的算法进行改进，每遍历一次层进行加一。</p>
<p>2、思路二：寻找最长路径，借助遍历最长路径的设计思路记性改进。只需记录两个子树最深的结点为主。</p>
<h4 id="二、测试用例-9"><a href="#二、测试用例-9" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点二叉树 ——  特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-6"><a href="#三、代码编写-6" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根节点为 null </span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 递归左子树</span></span><br><span class="line">    <span class="keyword">let</span> depthLeft  = maxDepth(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    <span class="keyword">let</span> depthRight  = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将子问题合并求总问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(depthLeft,depthRight) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一、解题思路总结"><a href="#一、解题思路总结" class="headerlink" title="一、解题思路总结"></a>一、解题思路总结</h3><h4 id="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"><a href="#1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。" class="headerlink" title="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"></a>1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。</h4><blockquote>
<p>通过二叉树的遍历来找到规律，从而找到解题思路。</p>
</blockquote>
<ul>
<li><p>重建二叉树</p>
<p>根据前、中序遍历，找到二叉树的根节点和左右子树的规律，然后递归构建二叉树。</p>
</li>
<li><p>二叉树的下一节点</p>
<p>根据中序遍历，找出包含任何节点的一下节点的所有可能情况，然后根据情况分别进行判断。</p>
</li>
<li><p>二叉树的后续遍历序列</p>
<p>通过中序遍历找到打印二叉树结点的规律，可以判断此后续遍历是否为二叉树。</p>
</li>
<li><p>二叉树和为某一值的路径</p>
<p>选择二叉树的遍历，对每个节点进行存储判断，然后根据二叉树叶子节点的特点，进行对问题的解决。</p>
</li>
<li><p>二叉树的第 K 大结点</p>
<p>中序遍历的结果是从小到大，然后倒数找到第 K 大数据。</p>
</li>
<li><p>序列化二叉树</p>
<p>遍历二叉树，遇到 null 转化为特殊符号。</p>
</li>
</ul>
<h4 id="2、根据树的结构寻找规律来解决问题"><a href="#2、根据树的结构寻找规律来解决问题" class="headerlink" title="2、根据树的结构寻找规律来解决问题"></a>2、根据树的结构寻找规律来解决问题</h4><blockquote>
<p>通过二叉树的特点：左子节点小于父节点、右子节点大于父节点、树的节点可以进行递归等，以上特点又是更好的帮我们解决思路。</p>
</blockquote>
<ul>
<li><p>树的子结构</p>
<p>根据子结构和主体树的特点，对其树的结构进行分析，可以找到解题的思路。</p>
</li>
<li><p>镜像二叉树</p>
<p>观察镜像二叉树的左右子节点交换特点，可以找到解题思路。</p>
</li>
<li><p>对称二叉树</p>
<p>观察对称二叉树有什么特点，在结构上和遍历上寻找特点和规律，可以找到解题思路。</p>
</li>
<li><p>按层遍历二叉树</p>
<p>根据二叉树每层节点的结构关系（父子关系），可以进行每层遍历，通过上层找到下层的遍历结点。</p>
</li>
<li><p>反序列化二叉树</p>
<p>根据遍历的规律和二叉树的规律，将遍历结果生成一棵二叉树。</p>
</li>
</ul>
<h3 id="二、测试用例-10"><a href="#二、测试用例-10" class="headerlink" title="二、测试用例"></a>二、测试用例</h3><p>通过以上题目中，我将测试用例分为三大种，测试代码的时候，在这三大种进行想就可以了。</p>
<ul>
<li><strong>普通测试</strong></li>
<li><strong>特殊测试</strong></li>
<li><strong>输入测试</strong></li>
</ul>
<h4 id="1、普通测试"><a href="#1、普通测试" class="headerlink" title="1、普通测试"></a>1、普通测试</h4><p>普通测试从两个方面去想，第一个方面就是问题的本身，比如对称二叉树的判断，普通测试就是分别输入一个对称二叉树和非对称二叉树进行测试。第二个方面就是问题本身没有什么可以找到的测试，比如按层遍历二叉树，它的普通测试就是分别输入完全二叉树（普通二叉树也可以），非完全二叉树进行测试。</p>
<h4 id="2、特殊测试"><a href="#2、特殊测试" class="headerlink" title="2、特殊测试"></a>2、特殊测试</h4><p>特殊测试强调的是树的特殊性，特殊的二叉树就那么几个，比如：只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树、没有结点的二叉树。</p>
<h4 id="3、输入测试"><a href="#3、输入测试" class="headerlink" title="3、输入测试"></a>3、输入测试</h4><p>输入测试，顾名思义，要对用户输入的参数进行判断，比如，你输入一棵树，要判断是否为空。再比如，求最大 K 结点，对 K 的取值范围进行判断。</p>
<h3 id="三、代码编写-7"><a href="#三、代码编写-7" class="headerlink" title="三、代码编写"></a>三、代码编写</h3><p>将二叉树的解题思路转化为代码除了熟练最基本的二叉树的增、删、改、查之外，最重要的就是二叉树的递归，因为二叉树的结构决定了用递归解决二叉树问题更加简便。但是递归的书写并不仅简单，因为它有递和归的过程，大脑并不能更好的去处理这些，可以去看之前总结递归的文章《<a href="https://github.com/luxiangqiang/Blog/blob/master/articel/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97.md" target="_blank" rel="noopener">数据结构与算法之递归系列</a>》。</p>
<p>书写二叉树递归问题有一点特别重要，不要尝试的去想那个递归的过程，而是先去寻找到递归的终止条件，然后对每次递归的结果进行判断，然后让他递归去吧，再次强调千万别去思考过程。</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之递归系列</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构与算法之递归系列"><a href="#数据结构与算法之递归系列" class="headerlink" title="数据结构与算法之递归系列"></a>数据结构与算法之递归系列</h1><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E5%AF%BC%E5%9B%BE.jpg" alt></p>
<br>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.png" alt></p>
<br>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。</p>
<p>然后自己又用了一个星期的时间去整理、分类，才有了这篇 8000 字有关递归知识的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的内容！</p>
<br>

<h2 id="为什么要写这篇递归文章"><a href="#为什么要写这篇递归文章" class="headerlink" title="为什么要写这篇递归文章"></a>为什么要写这篇递归文章</h2><p>看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。</p>
<p>另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。</p>
<p>接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。</p>
<p>什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。</p>
<br>

<h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><blockquote>
<p>递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。</p>
</blockquote>
<br>

<h2 id="为什么要学习递归？"><a href="#为什么要学习递归？" class="headerlink" title="为什么要学习递归？"></a>为什么要学习递归？</h2><p>我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。</p>
<p>从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。</p>
<p>后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。</p>
<br>

<h2 id="怎么理解递归的过程？"><a href="#怎么理解递归的过程？" class="headerlink" title="怎么理解递归的过程？"></a>怎么理解递归的过程？</h2><blockquote>
<p>上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。</p>
</blockquote>
<br>

<h4 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h4><blockquote>
<p>比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？</p>
</blockquote>
<br>

<h4 id="2、“递”"><a href="#2、“递”" class="headerlink" title="2、“递”"></a>2、“递”</h4><blockquote>
<p>于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？<strong>这个过程其实是就是一个递归中“递”的过程</strong>。</p>
</blockquote>
<br>

<h4 id="3、“归”"><a href="#3、“归”" class="headerlink" title="3、“归”"></a>3、“归”</h4><blockquote>
<p>然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。<strong>这个过程我们可以理解为递归中“归”的过程</strong>。</p>
</blockquote>
<br>

<h4 id="4、终止条件"><a href="#4、终止条件" class="headerlink" title="4、终止条件"></a>4、终止条件</h4><blockquote>
<p>“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为<strong>终止条件</strong>。</p>
</blockquote>
<br>

<h4 id="5、怎么理解递归？"><a href="#5、怎么理解递归？" class="headerlink" title="5、怎么理解递归？"></a>5、怎么理解递归？</h4><blockquote>
<p>1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。</p>
<p>2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，<strong>屏蔽掉递归的细节</strong>，具体看（五）分析。</p>
</blockquote>
<br>

<h2 id="满足递归的三个条件"><a href="#满足递归的三个条件" class="headerlink" title="满足递归的三个条件"></a>满足递归的三个条件</h2><blockquote>
<p>通过上方的例子，我们可以很容易的总结出满足递归的三个条件。</p>
</blockquote>
<br>

<h4 id="1、一个问题能不能分解成多个子问题来解决"><a href="#1、一个问题能不能分解成多个子问题来解决" class="headerlink" title="1、一个问题能不能分解成多个子问题来解决"></a>1、一个问题能不能分解成多个子问题来解决</h4><blockquote>
<p>想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。</p>
</blockquote>
<br>

<h4 id="2、该问题是否和子问题的解决思路相同"><a href="#2、该问题是否和子问题的解决思路相同" class="headerlink" title="2、该问题是否和子问题的解决思路相同"></a>2、该问题是否和子问题的解决思路相同</h4><blockquote>
<p>想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。</p>
</blockquote>
<br>

<h4 id="3、该问题是否有终止条件"><a href="#3、该问题是否有终止条件" class="headerlink" title="3、该问题是否有终止条件"></a>3、该问题是否有终止条件</h4><blockquote>
<p>第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。</p>
</blockquote>
<br>

<h2 id="怎么编写递归代码？"><a href="#怎么编写递归代码？" class="headerlink" title="怎么编写递归代码？"></a>怎么编写递归代码？</h2><blockquote>
<p>如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？</p>
</blockquote>
<br>

<h4 id="1、写出递推公式"><a href="#1、写出递推公式" class="headerlink" title="1、写出递推公式"></a>1、写出递推公式</h4><blockquote>
<p>写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？</p>
</blockquote>
<p>我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 <code>+1</code> 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f(n) 代表当前我在队伍中的位置</span></span><br><span class="line"><span class="comment">// f(n-1) 代表我前边那个人的位置</span></span><br><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>※ 注意：</strong>这个式子的含义就是 <code>f(n)</code> 求当前 n 这个人的位置， <code>f(n-1) + 1</code> 代表的就是前一个人的位置 <code>+ 1</code> 就是 <code>n</code> 的位置。</p>
</blockquote>
<br>

<h4 id="2、找到终止条件"><a href="#2、找到终止条件" class="headerlink" title="2、找到终止条件"></a>2、找到终止条件</h4><blockquote>
<p>递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？</p>
</blockquote>
<p>所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>※ 注意：</strong>有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。</p>
</blockquote>
<br>

<h4 id="3、转换递归代码"><a href="#3、转换递归代码" class="headerlink" title="3、转换递归代码"></a>3、转换递归代码</h4><blockquote>
<p>递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><blockquote>
<p>通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。</p>
</blockquote>
<br>

<h4 id="分类一：递归计算型"><a href="#分类一：递归计算型" class="headerlink" title="分类一：递归计算型"></a>分类一：递归计算型</h4><blockquote>
<p>将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，<strong>层层计算和并列计算</strong>。</p>
</blockquote>
<br>

<h5 id="1、层层计算"><a href="#1、层层计算" class="headerlink" title="1、层层计算"></a>1、层层计算</h5><blockquote>
<p>层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。</p>
</blockquote>
<br>

<p><strong>▉ 例子：</strong></p>
<blockquote>
<p>我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。</p>
</blockquote>
<p>层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 <code>+1</code>。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f(n) 为我所在的当前层</span></span><br><span class="line"><span class="comment">// f(n-1) 为我前边的人所在的当前层</span></span><br><span class="line"><span class="comment">// + 1 是层与层之间的计算关系</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结：</strong></p>
<blockquote>
<p>我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p>
<p><strong>问题一：</strong>有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。</p>
<p><strong>问题二：</strong>单链表从尾到头一次输出结点值，用递归实现。</p>
</blockquote>
<br>

<h5 id="2、并列计算"><a href="#2、并列计算" class="headerlink" title="2、并列计算"></a>2、并列计算</h5><blockquote>
<p>并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。</p>
</blockquote>
<br>

<p><strong>▉ 例子：</strong></p>
<blockquote>
<p>最经典的题型就是<strong>斐波那契数列</strong>。观察这样一组数据 0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：<code>2 = 1 + 1</code>，<code>8 = 3 + 5</code>，<code>34 = 21 + 13</code>）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。</p>
</blockquote>
<p>我也在这里稍微做一个分析。</p>
<p>1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。</p>
<p>2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 <code>0、1、1</code> 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。</p>
<p>3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 <code>f(n) = f(n-1) + f(n-2)</code>（n 为要求的第几个数字的值）。</p>
<p>4）转化为递归代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结：</strong></p>
<blockquote>
<p>我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 <code>f(n-1)</code> 和 <code>f(n-2)</code> 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p>
<p><strong>问题：</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。</p>
</blockquote>
<br>

<h4 id="分类二：递归枚举型"><a href="#分类二：递归枚举型" class="headerlink" title="分类二：递归枚举型"></a>分类二：递归枚举型</h4><blockquote>
<p>递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。</p>
</blockquote>
<p>回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。</p>
<br>

<h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><blockquote>
<p>在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？</p>
</blockquote>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E6%AD%A3%E7%A1%AE.png" alt></p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98error.png" alt></p>
<p><strong>▉ 问题分析：</strong></p>
<blockquote>
<p>要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。</p>
</blockquote>
<br>

<p><strong>▉ 算法思路：</strong></p>
<blockquote>
<p>我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？</p>
<p>1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。</p>
<p>2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。</p>
<p>3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。</p>
<p>4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。</p>
</blockquote>
<br>

<p><strong>▉ 代码实现：</strong></p>
<blockquote>
<p>虽然是用 <code>javascript</code> 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。</p>
</blockquote>
<br>

<p><strong>1、将问题分解为多个子问题</strong></p>
<blockquote>
<p>在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。</p>
</blockquote>
<br>

<p><strong>2、找出终止条件</strong></p>
<blockquote>
<p>当遍历到第八行的时候，递归结束。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 打印第 n 种满足的情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>3、写出递推公式</strong></p>
<blockquote>
<p><code>isOkCulomn()</code> 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 <code>true</code>，进入 <code>if</code> 判断，<code>row</code>行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，<code>column ++</code>，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一列的判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">    <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">    <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">        <span class="comment">// 保存皇后的位置</span></span><br><span class="line">        result[row] = column;</span><br><span class="line">        <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">        cal8queens(row + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 左上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>4、转换为递归代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。</span></span><br><span class="line"><span class="comment">// row 行  </span></span><br><span class="line"><span class="comment">// column 列</span></span><br><span class="line"><span class="comment">// n 计数满足条件的多少种</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> cal8queens = <span class="function">(<span class="params">row</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">        <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">        <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">            <span class="comment">// 保存皇后的位置</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 设置左上角</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有情况</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === j)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Q'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'*'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结</strong></p>
<blockquote>
<p>上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>如果你想练练手，可以自己实现图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 <code>Github</code> 上了。</p>
</blockquote>
<br>

<h4 id="分类三：递归选择型"><a href="#分类三：递归选择型" class="headerlink" title="分类三：递归选择型"></a>分类三：递归选择型</h4><blockquote>
<p>所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型「枚举所有情况」，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题，它也是一个回溯算法。</p>
</blockquote>
<br>

<h5 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 -1 背包问题"></a>0 -1 背包问题</h5><blockquote>
<p><code>0 - 1</code> 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在我们有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
</blockquote>
<br>

<p><strong>▉ 问题分析：</strong></p>
<blockquote>
<p>如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 <code>2^n</code>种，怎么才能不重复的穷举这些可能呢？</p>
</blockquote>
<br>

<p><strong>▉ 算法思路：</strong></p>
<blockquote>
<p>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>
</blockquote>
<br>

<p>▉ <strong>代码实现：</strong></p>
<blockquote>
<p>这里有个技巧就是设置了条件，自动筛选掉不满足条件的情况，提高了程序的执行效率。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存储背包中承受的最大重量</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">// i: 对第 i 个物品做出选择</span></span><br><span class="line"><span class="comment">// currentw: 当前背包的总重量</span></span><br><span class="line"><span class="comment">// goods：数组，存储每个物品的质量</span></span><br><span class="line"><span class="comment">// n: 物品的数量</span></span><br><span class="line"><span class="comment">// weight: 背包应承受的重量</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">i, currentw, goods, n, weight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(currentw === weight || i === n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentw &gt; max)&#123;</span><br><span class="line">            <span class="comment">// 保存满足条件的最大值</span></span><br><span class="line">            max = currentw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择跳过当前物品不装入背包</span></span><br><span class="line">    f(i+<span class="number">1</span>, currentw, goods, n, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前物品装入背包</span></span><br><span class="line">    <span class="comment">// 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了</span></span><br><span class="line">    <span class="keyword">if</span>(currentw + goods[i] &lt;= weight)&#123;</span><br><span class="line">        f(i+<span class="number">1</span> ,currentw + goods[i], goods, n, weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">f(<span class="number">0</span>,<span class="number">0</span>,a,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><blockquote>
<p>虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。</p>
</blockquote>
<br>

<h4 id="1、递归警惕堆栈溢出"><a href="#1、递归警惕堆栈溢出" class="headerlink" title="1、递归警惕堆栈溢出"></a>1、递归警惕堆栈溢出</h4><blockquote>
<p>你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。</p>
</blockquote>
<br>

<h5 id="▉-理解堆栈溢出"><a href="#▉-理解堆栈溢出" class="headerlink" title="▉ 理解堆栈溢出"></a>▉ 理解堆栈溢出</h5><blockquote>
<p>1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。</p>
<p>2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。</p>
<p>3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88.png" alt></p>
<h5 id="▉-解决办法"><a href="#▉-解决办法" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote>
<p>那么遇到这种情况，我们怎么解决呢？</p>
</blockquote>
<p>通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。还是那排队打饭的例子，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示递归深度变量</span></span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	depth++；</span><br><span class="line">    <span class="comment">// 如果超过递归深度，抛出错误</span></span><br><span class="line">	<span class="keyword">if</span>(depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> <span class="string">'error'</span>;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、递归警惕重复元素"><a href="#2、递归警惕重复元素" class="headerlink" title="2、递归警惕重复元素"></a>2、递归警惕重复元素</h4><blockquote>
<p>有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。</p>
</blockquote>
<p>如下图递归树中，求斐波那契数列 <code>f(5)</code>的值，需要多次递归求 <code>f(3)</code> 和 <code>f(2)</code> 的值。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E6%A0%91%E9%87%8D%E5%A4%8D.png" alt></p>
<h5 id="▉-解决办法-1"><a href="#▉-解决办法-1" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote>
<p>重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列改进后</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果散列表中存在当前计算的值，就直接返回，不再进行递归计算</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(n))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">let</span> num = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 将当前的值保存到散列表中</span></span><br><span class="line">    map.set(n,num)</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、递归高空间复杂度"><a href="#3、递归高空间复杂度" class="headerlink" title="3、递归高空间复杂度"></a>3、递归高空间复杂度</h4><blockquote>
<p>因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。</p>
</blockquote>
<p>比如：<code>f(n) = f(n-1)+1</code> ，空间复杂度并不是 <code>O(1)</code>，而是 <code>O(n)</code> 。</p>
<br>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>我们一起对递归做一个简单的总结吧，如果你还是没有完全明白，没关系，多看几遍，说实话，我这个人比较笨，前期看递归还不知道看了几十遍才想明白，吃饭想，睡觉之前想，相信最后总会想明白的。</p>
</blockquote>
<h4 id="1、满足递归的三个条件"><a href="#1、满足递归的三个条件" class="headerlink" title="1、满足递归的三个条件"></a>1、满足递归的三个条件</h4><ul>
<li>一个问题能不能分解成多个子问题来解决；</li>
<li>该问题是否和子问题的解决思路相同；</li>
<li>该问题是否有终止条件。</li>
</ul>
<h4 id="2、怎么写出递归代码"><a href="#2、怎么写出递归代码" class="headerlink" title="2、怎么写出递归代码"></a>2、怎么写出递归代码</h4><ul>
<li>寻找递归终止条件；</li>
<li>写出递推公式；</li>
<li>转化成递归代码。</li>
</ul>
<h4 id="3、怎么理解递归？"><a href="#3、怎么理解递归？" class="headerlink" title="3、怎么理解递归？"></a>3、怎么理解递归？</h4><blockquote>
<p>不要用大脑去想每一层递归的实现，记住这是计算机应该做的事情，我们要做的就是弄懂递归之间的关系，从而屏蔽掉层层递归的细节。</p>
</blockquote>
<h4 id="4、递归的缺点"><a href="#4、递归的缺点" class="headerlink" title="4、递归的缺点"></a>4、递归的缺点</h4><ul>
<li>递归警惕堆栈溢出</li>
<li>递归警惕重复计算</li>
<li>递归的高空间复杂度</li>
</ul>
<br>

<h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>最后可能说的比较打鸡血，很多人一遇到递归就会崩溃掉，比如我，哈哈。无论以后遇到什么困难，不要对它们产生恐惧，而是当做一种挑战，当你经过长时间的战斗，突破层层困难，最后突破挑战的时候，你会感激曾经的自己当初困难面前没有放弃。这一点我深有感触，有时候对于难题感到很无助，虽然自己没有在一所好的大学，没有好的资源，更没有人去专心的指导你，但是我一直相信这都是老天给我发出的挑战书，我会继续努力，写出更多高质量的文章。</p>
<p><strong>如果觉得本文对你有帮助，点个赞，我希望能够让更多处在递归困惑的人看到，谢谢各位支持！</strong>下一篇我打算出一篇完整关于链表的文章，终极目标：将数据结构与算法每个知识点写成一系列的文章。</p>
<hr>
**作者：**小鹿

<p><strong>座右铭：</strong>追求平淡不平凡，一生追求做一个不甘平凡的码农!</p>
<p><strong>本文首发于 Github ，转载请说明出处：</strong><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之递归系列.md" target="_blank" rel="noopener">https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之递归系列.md</a></p>
<p><strong>个人公众号：一个不甘平凡的码农。</strong></p>
<h3 id="其他链接："><a href="#其他链接：" class="headerlink" title="其他链接："></a>其他链接：</h3><h4 id="1、LeetCode-30-道经典题详细解析"><a href="#1、LeetCode-30-道经典题详细解析" class="headerlink" title="1、LeetCode 30 道经典题详细解析"></a><a href="https://github.com/luxiangqiang/JS-LeetCode" target="_blank" rel="noopener">1、LeetCode 30 道经典题详细解析</a></h4><h4 id="2、Github：入门必会的基本数据结构与算法代码剖析"><a href="#2、Github：入门必会的基本数据结构与算法代码剖析" class="headerlink" title="2、Github：入门必会的基本数据结构与算法代码剖析"></a><a href="https://github.com/luxiangqiang/Data-Structure-Coding" target="_blank" rel="noopener">2、Github：入门必会的基本数据结构与算法代码剖析</a></h4><h4 id="3、Github：公众号留言小程序开源项目"><a href="#3、Github：公众号留言小程序开源项目" class="headerlink" title="3、Github：公众号留言小程序开源项目"></a><a href="https://github.com/luxiangqiang/WeiXin_MessageApplet" target="_blank" rel="noopener">3、Github：公众号留言小程序开源项目</a></h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发Bug调试记录</title>
    <url>/2020/02/15/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91Bug%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="公众号基本信息："><a href="#公众号基本信息：" class="headerlink" title="公众号基本信息："></a>公众号基本信息：</h3><p>公众号名称：         大连拓扑伟业<br>公众号appId：        wxb6c7348e50d2d85b<br>公众号AppSecre：     38087a07eea5992e85cdc4172d3750ad   </p>
<h6 id="记录时间：2019-12-03-15-06"><a href="#记录时间：2019-12-03-15-06" class="headerlink" title="记录时间：2019/12/03 15:06"></a>记录时间：2019/12/03 15:06</h6><hr>
<p>==bug出错描述：==</p>
<ol>
<li>扫码绑定未能加载出二维码</li>
<li>加载出二维码微信扫码后无反应</li>
<li>出错解决办法：</li>
<li>F12查看调用接口是否正确</li>
<li>服务器上相关网站的配置是否正确：</li>
<li>heuwx.topedusoft.com：appsetting.json，</li>
<li>heuwxapi.topedusoft.com：web.config，db.config，</li>
<li>heuweb.topedusoft.com：web.config，global.js，custom.js</li>
<li>网络过慢，重启IIS或重启远程服务器（本次扫码后无反应，重启服务器后好使）</li>
</ol>
<h6 id="记录时间：2019-12-04-16-00"><a href="#记录时间：2019-12-04-16-00" class="headerlink" title="记录时间：2019/12/04 16:00"></a>记录时间：2019/12/04 16:00</h6><hr>
<p>==海事局问题：==</p>
<ol>
<li>文章点赞一直显示已评过，同时需要有接口返回是否已评过</li>
<li>评论留言的点赞和点踩一直显示已评过，同时需要有接口返回是否已评过</li>
<li>置顶，最新接口是否有？全部是按时间排的？？最新也是按照时间排的？？两者有什么区别？？</li>
<li>微信一个公众号两个网址，得另外配一个微信网站？配完网站之后，在manage网站里配才可以公众号菜单</li>
<li>开始扫码绑定，绑定成功之后才可以获取头像和昵称</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>剑指Offer题解</title>
    <url>/2020/02/15/1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库知识</title>
    <url>/2020/02/15/1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/02/14/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>name</title>
    <url>/2020/02/14/name/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java从入门到精通</title>
    <url>/2019/04/16/C#%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>###使用后台管理修改文章</p>
<p>字段解释：<br>这边title指的是文章的标题。<br>data指的是文章的创建时间，文章的排序规则也是根据这个字段来的，时间越后，排序越靠前。<br>tags指的是这个文章所对应的标签。<br>categories指的是文章所对应的分类。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
