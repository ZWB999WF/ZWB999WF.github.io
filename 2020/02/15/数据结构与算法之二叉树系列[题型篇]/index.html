<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="写在前边不知道你有没有这种困惑，虽然刷了很多算法题，当我去面试的时候，面试官让你手写一个算法，可能你对此算法很熟悉，知道实现思路，但是总是不知道该在什么地方写，而且很多边界条件想不全面，一紧张，代码写的乱七八糟。如果遇到没有做过的算法题，思路也不知道从何寻找，那么这篇文章就主要为你解决这几个问题。 《剑指 offer》是准备数据结构与算法面试的一本好书，里边很多面试手写算法很多的注意的问题，但是基">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法之二叉树系列[题型篇]">
<meta property="og:url" content="http://yoursite.com/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97[%E9%A2%98%E5%9E%8B%E7%AF%87]/index.html">
<meta property="og:site_name" content="ZWB@WF">
<meta property="og:description" content="写在前边不知道你有没有这种困惑，虽然刷了很多算法题，当我去面试的时候，面试官让你手写一个算法，可能你对此算法很熟悉，知道实现思路，但是总是不知道该在什么地方写，而且很多边界条件想不全面，一紧张，代码写的乱七八糟。如果遇到没有做过的算法题，思路也不知道从何寻找，那么这篇文章就主要为你解决这几个问题。 《剑指 offer》是准备数据结构与算法面试的一本好书，里边很多面试手写算法很多的注意的问题，但是基">
<meta property="article:published_time" content="2020-02-15T03:25:26.923Z">
<meta property="article:modified_time" content="2019-11-24T10:11:26.000Z">
<meta property="article:author" content="ZWB">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":20,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":5},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/02/15/数据结构与算法之二叉树系列[题型篇]/"/>





  <title>数据结构与算法之二叉树系列[题型篇] | ZWB@WF</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?70315e4dcd5713e8cc65f04eda22788d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/zwb999wf" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZWB@WF</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZWB">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/wechat-head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZWB@WF">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构与算法之二叉树系列[题型篇]</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-15T11:25:26+08:00">
                2020-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/" class="leancloud_visitors" data-flag-title="数据结构与算法之二叉树系列[题型篇]">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  22  分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>不知道你有没有这种困惑，虽然刷了很多算法题，当我去面试的时候，面试官让你手写一个算法，可能你对此算法很熟悉，知道实现思路，但是总是不知道该在什么地方写，而且很多边界条件想不全面，一紧张，代码写的乱七八糟。如果遇到没有做过的算法题，思路也不知道从何寻找，那么这篇文章就主要为你解决这几个问题。</p>
<p>《剑指 offer》是准备数据结构与算法面试的一本好书，里边很多面试手写算法很多的注意的问题，但是基本都是用 C++ 实现的，书中每章节的分类都是按照性能和消耗以及手写代码的注意的几大点进行了分类，针对每个不同的点，进行数据结构与算法的混合实现。</p>
<p>二遍刷题，发现了还可以根据自身情况进行整理和分类。全部代码是用 JS 书写，都经过 Leetcode 标准测试（小部分Leetcode 没有的题目），对所有的算法题的特点进行总结分类，手写算法中，如何考虑到全部的边界条件；如果快速多种思路解决，如何将思路快速的转化为代码，这是这一篇重点分享的地方。</p>
<p>二叉树题目共有 11 题，我把这 11 题书中对实现方法和思路有详细的讲解，但是对于个人来说，以后遇到陌生的二叉树的题目怎么进行解决，通过对 11 个题的分析、整理，得出以下几个步骤，首先先来看这 11 个二叉树经典算法题。</p>
<p><strong>PS：</strong>如果你已经做过这几道题，而且能够顺利的手写出来，不妨滑到最底部，希望最后的二叉树思路、测试用例以及代码编写的总结对你在面试中有所帮助（这篇文章精华所在）。</p>
<h3 id="一、面试题7：重建二叉树"><a href="#一、面试题7：重建二叉树" class="headerlink" title="一、面试题7：重建二叉树"></a>一、面试题7：重建二叉树</h3><blockquote>
<p>已知前序遍历为{1,2,4,7,3,5,6,8}，中序遍历为{4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？</p>
</blockquote>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h4><p>根据前、中序遍历的特点，（根左右、左根右），先根据前序遍历确定根节点，然后在中序遍历知道该根节点的左右树的数量，反推出前序遍历中左子树的结点有哪些。根据该思路进行递归即可完成二叉树的重建。</p>
<h4 id="2、测试用例"><a href="#2、测试用例" class="headerlink" title="2、测试用例"></a>2、测试用例</h4><ul>
<li><p>完全二叉树、非完全二叉树 —— 普通测试。</p>
</li>
<li><p>只有左子节点二叉树，只有右子节点、只有一个结点的二叉树 —— 特殊二叉树测试。</p>
</li>
<li><p>空树、前序和中序不匹配 —— 输入测试。</p>
</li>
</ul>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// 定义结点</span></span><br><span class="line"> <span class="number">2</span><span class="comment">// class TreeNode&#123;</span></span><br><span class="line"> <span class="number">3</span><span class="comment">//     constructor(data)&#123;</span></span><br><span class="line"> <span class="number">4</span><span class="comment">//         this.data = data;</span></span><br><span class="line"> <span class="number">5</span><span class="comment">//         this.left = null;</span></span><br><span class="line"> <span class="number">6</span><span class="comment">//         this.right = null;</span></span><br><span class="line"> <span class="number">7</span><span class="comment">//     &#125; </span></span><br><span class="line"> <span class="number">8</span><span class="comment">// &#125;</span></span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span><span class="comment">// 参数：前序遍历数组 ~ 中序遍历数组</span></span><br><span class="line"><span class="number">11</span><span class="keyword">const</span> reConstructBinaryTree = <span class="function">(<span class="params">pre, vin</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="number">12</span>    <span class="comment">// 判断前序数组和中序数组是否为空</span></span><br><span class="line"><span class="number">13</span>    <span class="keyword">if</span>(!pre || pre.length === <span class="number">0</span> || !vin || vin.length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">14</span>        <span class="keyword">return</span>;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line"><span class="number">16</span>    <span class="comment">// 新建二叉树的根节点</span></span><br><span class="line"><span class="number">17</span>    <span class="keyword">var</span> treeNode = &#123;</span><br><span class="line"><span class="number">18</span>        val: pre[<span class="number">0</span>]</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="comment">// 查找中序遍历中的根节点</span></span><br><span class="line"><span class="number">21</span>    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line"><span class="number">22</span>        <span class="keyword">if</span> (vin[i] === pre[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="number">23</span>            <span class="comment">// 将左子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">24</span>            treeNode.left = reConstructBinaryTree(pre.slice(<span class="number">1</span>, i+<span class="number">1</span>), vin.slice(<span class="number">0</span>, i));</span><br><span class="line"><span class="number">25</span>            <span class="comment">// 将右子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">26</span>            treeNode.right = reConstructBinaryTree(pre.slice(i+<span class="number">1</span>),vin.slice(i+<span class="number">1</span>));</span><br><span class="line"><span class="number">27</span>        &#125;</span><br><span class="line"><span class="number">28</span>    &#125;</span><br><span class="line"><span class="number">29</span>    <span class="comment">// 返回该根节点</span></span><br><span class="line"><span class="number">30</span>    <span class="keyword">return</span> treeNode;</span><br><span class="line"><span class="number">31</span>&#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span><span class="keyword">let</span> pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="number">34</span><span class="keyword">let</span> vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line"><span class="number">35</span><span class="built_in">console</span>.log(reConstructBinaryTree(pre,vin));</span><br></pre></td></tr></table></figure>



<h3 id="二、面试题8：二叉树的下一节点"><a href="#二、面试题8：二叉树的下一节点" class="headerlink" title="二、面试题8：二叉树的下一节点"></a>二、<strong>面试题8：二叉树的下一节点</strong></h3><blockquote>
<p>给定一个二叉树的节点，如何找出中序遍历的下一节点。有两个指向左右子树的指针，还有一个指向父节点的指针。</p>
</blockquote>
<h4 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h4><p>求中序遍历的下一节点，就要分各种情况（明确中序遍历下一结点在二叉树中的位置有哪些），然后对某种情况详细分析。</p>
<p>下一结点可能存在的情况：</p>
<ul>
<li>有右子节点<ul>
<li>右子节点有无左子节点<ul>
<li>无 —— 右子节点就是当前结点下一节</li>
<li>有 —— 递归寻找右子节点的左子节点就是下一节点</li>
</ul>
</li>
</ul>
</li>
<li>无右子节点<ul>
<li>无父节点 —— 无下一结点</li>
<li>有父节点<ul>
<li>当前结点作为父节点的左子节点 —— 下一结点为父节点</li>
<li>当前结点作为父节点的右子节点 —— 向父节点递归寻找作为左子节点的结点就是下一节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、测试用例"><a href="#二、测试用例" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通测试 —— 完全二叉树、非完全二叉树</li>
<li>特殊测试 —— 只要左子节点的二叉树、只有右子节点的二叉树、只有一个结点</li>
<li>输入测试 —— 空节点</li>
</ul>
<h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getNextNode = <span class="function">(<span class="params">pNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断该结点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前结点有右子树且左子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">        pNode = pNode.right;</span><br><span class="line">        <span class="comment">// 判断右子树是否有左子树</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前结点是否存在父节点(如果为空,没有下一结点)</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode == pNode.next.left)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有下一结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、面试题26：树的子结构"><a href="#三、面试题26：树的子结构" class="headerlink" title="三、面试题26：树的子结构"></a>三、面试题26：树的子结构</h3><blockquote>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p>
</blockquote>
<h4 id="一、思路-1"><a href="#一、思路-1" class="headerlink" title="一、思路"></a>一、思路</h4><p>通过判断两棵树的根节点否相同，如果相同，则递归判断树剩余的结点是否相同。如果不相同，则递归树的左右子节点进行对比找到相同的根节点。</p>
<h4 id="二、测试用例-1"><a href="#二、测试用例-1" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>是子结构、不是子结构 —— 普通测试。</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试。</li>
<li>空树 —— 输入测试。</li>
</ul>
<h4 id="三、代码实现-1"><a href="#三、代码实现-1" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TreeConstrutor = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断输入是否为 null</span></span><br><span class="line">    <span class="comment">// nodeA 为 null 不会有子结构</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 如果 nodeB 为 null,代表所有子结构比较完成</span></span><br><span class="line">    <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点相同，则进行子结构全部的验证,返回验证的结果</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA.data === nodeB.data)&#123;</span><br><span class="line">       result = match(nodeA, nodeB)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点不相同，继续递归遍历查找相同的根节点</span></span><br><span class="line">    <span class="keyword">return</span> TreeConstrutor(nodeA.left, nodeB) || TreeConstrutor(nodeA.right, nodeB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配根节点相同的子结构</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 判断匹配的当前结点是否相同</span></span><br><span class="line">     <span class="keyword">if</span>(nodeA.data == nodeB.data)&#123;</span><br><span class="line">         <span class="comment">// 递归匹配其他子节点</span></span><br><span class="line">    	<span class="keyword">return</span> match(nodeA.left, nodeB.left) &amp;&amp; match(nodeA.right, nodeB.right);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、面试题27：二叉树的镜像"><a href="#四、面试题27：二叉树的镜像" class="headerlink" title="四、面试题27：二叉树的镜像"></a>四、<strong>面试题27：二叉树的镜像</strong></h3><blockquote>
<p>请完成一个函数，如果一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<h4 id="一、思路-2"><a href="#一、思路-2" class="headerlink" title="一、思路"></a>一、思路</h4><p>根节点的左右子节点相互交换，继续递归遍历，将子节点的左右结点进行交换，知道遇到叶子节点。</p>
<h4 id="二、测试用例-2"><a href="#二、测试用例-2" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码实现-2"><a href="#三、代码实现-2" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     	<span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行结点交换</span></span><br><span class="line">    Let tempNode = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tempNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历剩余的子节点</span></span><br><span class="line">    insert(root.left);</span><br><span class="line">    insert(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、面试题28：对称二叉树"><a href="#五、面试题28：对称二叉树" class="headerlink" title="五、面试题28：对称二叉树"></a>五、<strong>面试题28：对称二叉树</strong></h3><h4 id="一、思路-3"><a href="#一、思路-3" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、首先，观察一个对称的二叉树有什么特点？</p>
<ul>
<li>结构上：在结构上实对称的，某一节点的左子节点和某一节点的右子节点对称。</li>
<li>规律上：我们如果进行前序遍历（根、左、右），然后对前序遍历进行改进（根、右、左），如果是对称的二叉树，他们的遍历结果是相同的。</li>
</ul>
<p>2、考虑其他情况</p>
<ul>
<li>结点数量不对称</li>
<li>结点值不对称</li>
</ul>
<h4 id="二、测试用例-3"><a href="#二、测试用例-3" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li><p>对称二叉树、不对称二叉树（结点数量不对称、结点结构不对称） —— 普通测试</p>
</li>
<li><p>所有结点值都相同的二叉树 —— 特殊测试</p>
</li>
<li><p>空二叉树 —— 输入测试</p>
</li>
</ul>
<h4 id="三、代码编写"><a href="#三、代码编写" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断二叉树是否为 null —— 输入测试，                                                     	  if(root == null)&#123;</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断输入的二叉树,从根节点开始判断是否是对称二叉树</span></span><br><span class="line">	<span class="keyword">var</span> Symmetric = <span class="function">(<span class="params">lNode, rNode</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断左右结点是否都为 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 判断其中一个为 null 另一个不是 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(lNode !== <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 判断两个结点的值是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(lNode.val !== rNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相同，继续递归判断其他的结点</span></span><br><span class="line">        <span class="keyword">return</span> Symmetric(lNode.left,rNode.right) &amp;&amp; Symmetric(lNode.right,rNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Symmetric(root.left,root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="六、面试题32：从上到下打印二叉树"><a href="#六、面试题32：从上到下打印二叉树" class="headerlink" title="六、面试题32：从上到下打印二叉树"></a>六、面试题32：从上到下打印二叉树</h3><blockquote>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。（按层遍历二叉树）</p>
</blockquote>
<h4 id="一、思路-4"><a href="#一、思路-4" class="headerlink" title="一、思路"></a>一、思路</h4><p>从根节点开始按层遍历打印结点（自左往右），下一层的遍历是上一层的字节点，但是我们发现想要获取到上层结点的子节点时，上层的父节点已经遍历过去可，想要在获取到，必须存储父节点。然后下层遍历的时候，自左往右取出父节点，依次打印子节点。</p>
<p>上方的解题思路中父节点的存储和遍历让我们想到一个熟悉的数据结构，对了，“先进先出”的思想，那就是队列。在遍历上一层结点的时候，先打印结点值，然后判断是够存在左右子树，如果存在，将给结点入队，直到该层的结点全部遍历完成。然后队列出队，分别打印结点，循环此步骤。</p>
<h4 id="二、测试用例-4"><a href="#二、测试用例-4" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左、右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-1"><a href="#三、代码编写-1" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：树的根节点。</li>
<li>判断是否为空。</li>
<li>打印结点值,判断该结点是否存在子节点，如果存在就入队。</li>
<li>出队，打印结点</li>
<li>循环上述步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = []; <span class="comment">// 存放遍历的结果</span></span><br><span class="line"> 	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明一个队列</span></span><br><span class="line">   <span class="keyword">let</span> queue = [];</span><br><span class="line">   queue.push(root)</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 出队，打印结结点、判断是否存在子节点</span></span><br><span class="line">   <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> temp = [];             <span class="comment">// 存储每层的结点</span></span><br><span class="line">       <span class="keyword">let</span> len = queue.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line">           <span class="comment">// 出队</span></span><br><span class="line">           <span class="keyword">let</span> tempNode = queue.shift(); </span><br><span class="line">           <span class="comment">// 存储结点值</span></span><br><span class="line">           temp.push(tempNode.val)		  </span><br><span class="line">           <span class="comment">// 判断出队的根节点是否有子节点</span></span><br><span class="line">           <span class="keyword">if</span>(tempVal.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(tempVal.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//存储每层的遍历的结点值</span></span><br><span class="line">       result.push(temp);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回结果集</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、面试题33：二叉树的后序遍历序列"><a href="#七、面试题33：二叉树的后序遍历序列" class="headerlink" title="七、面试题33：二叉树的后序遍历序列"></a>七、<strong>面试题33：二叉树的后序遍历序列</strong></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历。如果是返回 true，如果不是返回 false。假设输入的任意两个数字互不相同。</p>
<h4 id="一、思路-5"><a href="#一、思路-5" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>根据后续遍历的规律和二叉树具备的特点</strong>，可以找到的规律就是（左、右、根）序列的最后一个数为根节点，又根据二叉树的特点，左子节点小于根节点，右子节点大于根节点，分离出左右子节点，根据上边的规律，<strong>递归</strong>剩下的序列。</p>
<h4 id="二、测试用例-5"><a href="#二、测试用例-5" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、不完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-2"><a href="#三、代码编写-2" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：数组</li>
<li>判断数组是否为空</li>
<li>取数组的最后一个元素作为对比的根节点</li>
<li>根据根节点值的大小分割数组（分割数组的同时判断是否都满足小于根节点的要求）</li>
<li>判断分割数组是否是空</li>
<li>递归上方的步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isPostorder = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">  	<span class="comment">// 判断数组是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取数组最后一个数字为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = arr[arr.length - <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索小于根节点的值,并记录该结点的下标(除根节点外)</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; rootVal)&#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索大于根节点的值（除根节点外）</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j &lt; arr.length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rootVal &gt; arr[j])&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子节点的值（先判断左子节点是够有值），默认返回 true</span></span><br><span class="line">     <span class="keyword">let</span> left = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         left = isPostorder(arr.slice(<span class="number">0</span>, i))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果右子树不为空，判断右子树为二叉搜索树</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">        right = isPostorder(arr.slice(i,arr.length - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、面试34：二叉树和为某一值路径"><a href="#八、面试34：二叉树和为某一值路径" class="headerlink" title="八、面试34：二叉树和为某一值路径"></a>八、<strong>面试34：二叉树和为某一值路径</strong></h3><blockquote>
<p> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输出整数的所有路径。从树的根节点开始往下一直到叶子节点所经过的节点形成一条路径。</p>
</blockquote>
<h4 id="一、思路-6"><a href="#一、思路-6" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>1、找规律：</strong>需要遍历树的所有结点：我们会想到前、中、后遍历</p>
<pre><code>:  需要存储遍历过的路径（节点值）：我们想到用数组存储</code></pre><p><strong>2、算法思想：</strong>前序遍历（根、左、右）的特点，从根到叶子节点，会从树自左向右依次遍历二叉树，所有可能的路径都会遍历到，所以使用前序遍历更佳。</p>
<p>每遍历一个结点就将其累加，然后判断累加的值是否等于目标值且子节点为叶子节点。如果是，则打印输出该路径；如果不是，则回退到上一父节点，此时数组中的数据结点进行删除，然后不断的遍历下一子节点，递归。</p>
<p><strong>3、综上所述，</strong>存储结点路径的时候，涉及到累加结点和删除节点，我们可以将其抽象成入栈和出栈。然后遍历二叉树的所有路径可以用到递归的过程，让出栈和入栈与递归的状态达成一致，这到题就不难了。</p>
<h4 id="二、测试用例-6"><a href="#二、测试用例-6" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树（有一条路径满足、有多条路径满足、都不满足）—— <strong>普通测试</strong>。</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个结点的二叉树 —— <strong>特殊测试</strong>。</li>
<li>空二叉树、输入负数 —— <strong>输入测试</strong>。</li>
</ul>
<h4 id="三、代码编写-3"><a href="#三、代码编写-3" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：二叉树、目标值</li>
<li>判断二叉树是否为空和目标是是否是负数</li>
<li>开始进行递归遍历二叉树进行查找满足条件的路径<ul>
<li>将当前递归的根节点进行累加</li>
<li>同时该结点入栈</li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeSum = <span class="function">(<span class="params">root, targetSum</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断输入的二叉树和整数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span> || targetSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始进行递归遍历二叉树进行查找满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> result = [];    <span class="comment">// 存放最后满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> pathStack = []; <span class="comment">// 储存当前路径的栈</span></span><br><span class="line">    <span class="keyword">let</span> currentSum = <span class="number">0</span>; <span class="comment">// 当前累加的结果值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 进行路径查找</span></span><br><span class="line">    FindPath(root, targetSum, currentSum, pathStack, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FindPath = <span class="function">(<span class="params">root, targetSum, currentSum, pathStack, result</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 将当前跟根节点进行累加</span></span><br><span class="line">    	currentSum = currentSum + root.val;</span><br><span class="line">    	</span><br><span class="line">      <span class="comment">// 存储栈中</span></span><br><span class="line">      pathStack.push(root.val);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 判断目标值是否相等且是否为叶子节点</span></span><br><span class="line">    	<span class="keyword">if</span>(currentSum == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">// 打印路径</span></span><br><span class="line">          result.push(pathStack.slice(<span class="number">0</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 如果左子节点不为空</span></span><br><span class="line">      <span class="keyword">if</span>(root.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.left, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前结点还有右子树，继续遍历</span></span><br><span class="line">      <span class="keyword">if</span>(root.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.right, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 该路径遍历到叶子节点，还没有满足条件，则退回到父节点，进行下一结点的累加判断</span></span><br><span class="line">      pathStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h4><ul>
<li><p>当问题能够用递归去解决的时候，首先找到递归的点，比如二叉树的中的每个节点就是递归的点。</p>
</li>
<li><p>当使用递归解决满足条件的问题时，直接每层递归进行判断，如果满足条件就处理，否则，递归自动跳过 if 判断。</p>
</li>
</ul>
<h3 id="九、面试题37：序列化二叉树"><a href="#九、面试题37：序列化二叉树" class="headerlink" title="九、面试题37：序列化二叉树"></a>九、<strong>面试题37：序列化二叉树</strong></h3><p>请实现两个函数，分别用来序列化二叉树和反序列化二叉树。</p>
<h4 id="一、思路-7"><a href="#一、思路-7" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、序列化：遍历二叉树，遇到叶子节点，将其转化为 $ 表示。</p>
<p>2、反序列化：根据前序遍历的特点（根、左、右），进行二叉树的还原。</p>
<h4 id="二、测试用例-7"><a href="#二、测试用例-7" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个节点 —— 特殊测试</li>
<li>空数组、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-4"><a href="#三、代码编写-4" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        result.push(<span class="string">'$'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    result.push(root.val)</span><br><span class="line">    serialize(root.left)</span><br><span class="line">    serialize(root.right)</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">serialize(symmetricalTree);</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化二叉树</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈队判断</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> val = arr.shift();</span><br><span class="line">    <span class="keyword">if</span>(val !== <span class="string">'$'</span>)&#123;</span><br><span class="line">        node = &#123;</span><br><span class="line">            val: val</span><br><span class="line">        &#125;;</span><br><span class="line">        node.left = deserialize(arr);</span><br><span class="line">        node.right = deserialize(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'8,6,5,$,$,7,$,$,6,7,$,$,5,$,$'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(deserialize(str.split(<span class="string">','</span>)));</span><br></pre></td></tr></table></figure>



<h3 id="十、面试题54：二叉树的第-K-大节点"><a href="#十、面试题54：二叉树的第-K-大节点" class="headerlink" title="十、面试题54：二叉树的第 K 大节点"></a>十、<strong>面试题54：二叉树的第 K 大节点</strong></h3><blockquote>
<p>给定一棵二叉搜索树，请找出其中的第 K 大节点。</p>
</blockquote>
<h4 id="一、思路-8"><a href="#一、思路-8" class="headerlink" title="一、思路"></a>一、思路</h4><p>要想找到第 K 大结点必要要知道排序，二叉树的前、中、后遍历中的中序遍历就是从小到大排序。然后遍历的同时计数找到第 K 大节点。</p>
<h4 id="二、测试用例-8"><a href="#二、测试用例-8" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>K 的范围、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-5"><a href="#三、代码编写-5" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求二叉树中第 K 大节点</span></span><br><span class="line"><span class="keyword">var</span> kthTallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  <span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">      inorder(root.left);</span><br><span class="line">      res.push(root.val);</span><br><span class="line">      inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="keyword">return</span> res[res.length - k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="十一、面试题55：二叉树的深度"><a href="#十一、面试题55：二叉树的深度" class="headerlink" title="十一、面试题55：二叉树的深度"></a>十一、<strong>面试题55：二叉树的深度</strong></h3><p>  输入一棵二叉树的根节点，求该树的深度。从根节点到叶子节点依次经过的节点（包含根、叶子节点）形成树的一条路径，最长路径的长度树的深度。</p>
<h4 id="一、思路-9"><a href="#一、思路-9" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、思路一：按层遍历，对按层遍历的算法进行改进，每遍历一次层进行加一。</p>
<p>2、思路二：寻找最长路径，借助遍历最长路径的设计思路记性改进。只需记录两个子树最深的结点为主。</p>
<h4 id="二、测试用例-9"><a href="#二、测试用例-9" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点二叉树 ——  特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-6"><a href="#三、代码编写-6" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根节点为 null </span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 递归左子树</span></span><br><span class="line">    <span class="keyword">let</span> depthLeft  = maxDepth(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    <span class="keyword">let</span> depthRight  = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将子问题合并求总问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(depthLeft,depthRight) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一、解题思路总结"><a href="#一、解题思路总结" class="headerlink" title="一、解题思路总结"></a>一、解题思路总结</h3><h4 id="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"><a href="#1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。" class="headerlink" title="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"></a>1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。</h4><blockquote>
<p>通过二叉树的遍历来找到规律，从而找到解题思路。</p>
</blockquote>
<ul>
<li><p>重建二叉树</p>
<p>根据前、中序遍历，找到二叉树的根节点和左右子树的规律，然后递归构建二叉树。</p>
</li>
<li><p>二叉树的下一节点</p>
<p>根据中序遍历，找出包含任何节点的一下节点的所有可能情况，然后根据情况分别进行判断。</p>
</li>
<li><p>二叉树的后续遍历序列</p>
<p>通过中序遍历找到打印二叉树结点的规律，可以判断此后续遍历是否为二叉树。</p>
</li>
<li><p>二叉树和为某一值的路径</p>
<p>选择二叉树的遍历，对每个节点进行存储判断，然后根据二叉树叶子节点的特点，进行对问题的解决。</p>
</li>
<li><p>二叉树的第 K 大结点</p>
<p>中序遍历的结果是从小到大，然后倒数找到第 K 大数据。</p>
</li>
<li><p>序列化二叉树</p>
<p>遍历二叉树，遇到 null 转化为特殊符号。</p>
</li>
</ul>
<h4 id="2、根据树的结构寻找规律来解决问题"><a href="#2、根据树的结构寻找规律来解决问题" class="headerlink" title="2、根据树的结构寻找规律来解决问题"></a>2、根据树的结构寻找规律来解决问题</h4><blockquote>
<p>通过二叉树的特点：左子节点小于父节点、右子节点大于父节点、树的节点可以进行递归等，以上特点又是更好的帮我们解决思路。</p>
</blockquote>
<ul>
<li><p>树的子结构</p>
<p>根据子结构和主体树的特点，对其树的结构进行分析，可以找到解题的思路。</p>
</li>
<li><p>镜像二叉树</p>
<p>观察镜像二叉树的左右子节点交换特点，可以找到解题思路。</p>
</li>
<li><p>对称二叉树</p>
<p>观察对称二叉树有什么特点，在结构上和遍历上寻找特点和规律，可以找到解题思路。</p>
</li>
<li><p>按层遍历二叉树</p>
<p>根据二叉树每层节点的结构关系（父子关系），可以进行每层遍历，通过上层找到下层的遍历结点。</p>
</li>
<li><p>反序列化二叉树</p>
<p>根据遍历的规律和二叉树的规律，将遍历结果生成一棵二叉树。</p>
</li>
</ul>
<h3 id="二、测试用例-10"><a href="#二、测试用例-10" class="headerlink" title="二、测试用例"></a>二、测试用例</h3><p>通过以上题目中，我将测试用例分为三大种，测试代码的时候，在这三大种进行想就可以了。</p>
<ul>
<li><strong>普通测试</strong></li>
<li><strong>特殊测试</strong></li>
<li><strong>输入测试</strong></li>
</ul>
<h4 id="1、普通测试"><a href="#1、普通测试" class="headerlink" title="1、普通测试"></a>1、普通测试</h4><p>普通测试从两个方面去想，第一个方面就是问题的本身，比如对称二叉树的判断，普通测试就是分别输入一个对称二叉树和非对称二叉树进行测试。第二个方面就是问题本身没有什么可以找到的测试，比如按层遍历二叉树，它的普通测试就是分别输入完全二叉树（普通二叉树也可以），非完全二叉树进行测试。</p>
<h4 id="2、特殊测试"><a href="#2、特殊测试" class="headerlink" title="2、特殊测试"></a>2、特殊测试</h4><p>特殊测试强调的是树的特殊性，特殊的二叉树就那么几个，比如：只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树、没有结点的二叉树。</p>
<h4 id="3、输入测试"><a href="#3、输入测试" class="headerlink" title="3、输入测试"></a>3、输入测试</h4><p>输入测试，顾名思义，要对用户输入的参数进行判断，比如，你输入一棵树，要判断是否为空。再比如，求最大 K 结点，对 K 的取值范围进行判断。</p>
<h3 id="三、代码编写-7"><a href="#三、代码编写-7" class="headerlink" title="三、代码编写"></a>三、代码编写</h3><p>将二叉树的解题思路转化为代码除了熟练最基本的二叉树的增、删、改、查之外，最重要的就是二叉树的递归，因为二叉树的结构决定了用递归解决二叉树问题更加简便。但是递归的书写并不仅简单，因为它有递和归的过程，大脑并不能更好的去处理这些，可以去看之前总结递归的文章《<a href="https://github.com/luxiangqiang/Blog/blob/master/articel/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97.md" target="_blank" rel="noopener">数据结构与算法之递归系列</a>》。</p>
<p>书写二叉树递归问题有一点特别重要，不要尝试的去想那个递归的过程，而是先去寻找到递归的终止条件，然后对每次递归的结果进行判断，然后让他递归去吧，再次强调千万别去思考过程。</p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="ZWB wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客!</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/" rel="next" title="数据结构与算法之递归系列">
                <i class="fa fa-chevron-left"></i> 数据结构与算法之递归系列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/" rel="prev" title="数据结构与算法之链表系列[题型篇]">
                数据结构与算法之链表系列[题型篇] <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/wechat-head.jpg"
                alt="ZWB" />
            
              <p class="site-author-name" itemprop="name">ZWB</p>
              <p class="site-description motion-element" itemprop="description">菜鸟程序员的自我修炼之路</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ZWB999WF" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5381379716/home?wvr=5" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/chen-feng-de-lan-yi" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1643054079@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#写在前边"><span class="nav-number">1.</span> <span class="nav-text">写在前边</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、面试题7：重建二叉树"><span class="nav-number">1.1.</span> <span class="nav-text">一、面试题7：重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、思路"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、测试用例"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、代码实现"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、面试题8：二叉树的下一节点"><span class="nav-number">1.2.</span> <span class="nav-text">二、面试题8：二叉树的下一节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路"><span class="nav-number">1.2.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例"><span class="nav-number">1.2.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码实现"><span class="nav-number">1.2.3.</span> <span class="nav-text">三、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、面试题26：树的子结构"><span class="nav-number">1.3.</span> <span class="nav-text">三、面试题26：树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码实现-1"><span class="nav-number">1.3.3.</span> <span class="nav-text">三、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、面试题27：二叉树的镜像"><span class="nav-number">1.4.</span> <span class="nav-text">四、面试题27：二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码实现-2"><span class="nav-number">1.4.3.</span> <span class="nav-text">三、代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、面试题28：对称二叉树"><span class="nav-number">1.5.</span> <span class="nav-text">五、面试题28：对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-3"><span class="nav-number">1.5.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-3"><span class="nav-number">1.5.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写"><span class="nav-number">1.5.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、面试题32：从上到下打印二叉树"><span class="nav-number">1.6.</span> <span class="nav-text">六、面试题32：从上到下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-4"><span class="nav-number">1.6.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-4"><span class="nav-number">1.6.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-1"><span class="nav-number">1.6.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、面试题33：二叉树的后序遍历序列"><span class="nav-number">1.7.</span> <span class="nav-text">七、面试题33：二叉树的后序遍历序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-5"><span class="nav-number">1.7.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-5"><span class="nav-number">1.7.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-2"><span class="nav-number">1.7.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八、面试34：二叉树和为某一值路径"><span class="nav-number">1.8.</span> <span class="nav-text">八、面试34：二叉树和为某一值路径</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-6"><span class="nav-number">1.8.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-6"><span class="nav-number">1.8.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-3"><span class="nav-number">1.8.3.</span> <span class="nav-text">三、代码编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、小结"><span class="nav-number">1.8.4.</span> <span class="nav-text">四、小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、面试题37：序列化二叉树"><span class="nav-number">1.9.</span> <span class="nav-text">九、面试题37：序列化二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-7"><span class="nav-number">1.9.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-7"><span class="nav-number">1.9.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-4"><span class="nav-number">1.9.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十、面试题54：二叉树的第-K-大节点"><span class="nav-number">1.10.</span> <span class="nav-text">十、面试题54：二叉树的第 K 大节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-8"><span class="nav-number">1.10.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-8"><span class="nav-number">1.10.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-5"><span class="nav-number">1.10.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十一、面试题55：二叉树的深度"><span class="nav-number">1.11.</span> <span class="nav-text">十一、面试题55：二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、思路-9"><span class="nav-number">1.11.1.</span> <span class="nav-text">一、思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、测试用例-9"><span class="nav-number">1.11.2.</span> <span class="nav-text">二、测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、代码编写-6"><span class="nav-number">1.11.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、解题思路总结"><span class="nav-number">2.1.</span> <span class="nav-text">一、解题思路总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、根据树的结构寻找规律来解决问题"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、根据树的结构寻找规律来解决问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、测试用例-10"><span class="nav-number">2.2.</span> <span class="nav-text">二、测试用例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、普通测试"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、普通测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、特殊测试"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、特殊测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、输入测试"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、输入测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、代码编写-7"><span class="nav-number">2.3.</span> <span class="nav-text">三、代码编写</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZWB</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("35zjuv8Uz0k48OJOv8HW0dMd-gzGzoHsz", "Tebt91HLjsPhciulunLSsNa7");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
