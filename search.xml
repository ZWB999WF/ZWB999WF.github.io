<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java多线程</title>
    <url>/2020/02/18/ava%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><ul>
<li>进程：操作系统进行资源分配和调度的一个独立单位</li>
<li>线程：cpu 调度和分派的基本单位，是比进程更小的可以独立运行的基本单位</li>
<li>进程在运行时各自内存单元相互独立，线程在运行时之间内存共享  </li>
<li>比如网易云音乐和腾讯视频是两个不同的进程；而网易云音乐中你可以听歌的同时发表对歌曲的评论，这是两个不同的线程</li>
</ul>
<h3 id="启动一个线程是调用-run-方法还是-start-方法"><a href="#启动一个线程是调用-run-方法还是-start-方法" class="headerlink" title="启动一个线程是调用 run()方法还是 start()方法"></a>启动一个线程是调用 run()方法还是 start()方法</h3><ul>
<li>启动一个线程是调用 start()方法</li>
<li>start()执行后使线程处于可运行状态，这意味着它可以由 JVM 调度并执行，但不表示线程就会立即运行</li>
<li>run()方法是线程启动后(真正执行后)要进行回调的方法</li>
</ul>
<h3 id="同步线程及线程调度相关的方法"><a href="#同步线程及线程调度相关的方法" class="headerlink" title="同步线程及线程调度相关的方法"></a>同步线程及线程调度相关的方法</h3><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁   </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常   </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，</li>
<li>而是由 JVM 确定唤醒哪个线程，而且与优先级无关  </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</li>
</ul>
<h3 id="java-中-wait-和-sleep-方法的不同"><a href="#java-中-wait-和-sleep-方法的不同" class="headerlink" title="java 中 wait 和 sleep 方法的不同"></a>java 中 wait 和 sleep 方法的不同</h3><ul>
<li>wait 会释放锁，wait 通常被用于线程间交互</li>
<li>sleep 一直持有锁，sleep 通常被用于暂停执行</li>
</ul>
<h3 id="synchronized-和-volatile-关键字的作用和区别"><a href="#synchronized-和-volatile-关键字的作用和区别" class="headerlink" title="synchronized 和 volatile 关键字的作用和区别"></a>synchronized 和 volatile 关键字的作用和区别</h3><ul>
<li>volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。  </li>
<li>volatile 仅能使用在变量级别，仅能实现变量的修改可见性，并不能保证原子性</li>
<li>volatile 不会造成线程的阻塞</li>
<li>synchronized 可以使用在变量、方法、和类级别 ，synchronized 可以保证变量的修改可见性和原子性</li>
<li>synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="线程池的理解"><a href="#线程池的理解" class="headerlink" title="线程池的理解"></a>线程池的理解</h2><p>（如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略）</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节<br>省了开辟子线程的时间，提高的代码执行效率。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任常务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ol>
<h3 id="常见线程池"><a href="#常见线程池" class="headerlink" title="常见线程池"></a>常见线程池</h3><ol>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。  </li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。    </li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。  </li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求   </li>
</ol>
<h3 id="JDK-的-java-util-concurrent-Executors-中提供了生成多种线程池的静态方法"><a href="#JDK-的-java-util-concurrent-Executors-中提供了生成多种线程池的静态方法" class="headerlink" title="JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法"></a>JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法</h3><pre><code>1. ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();
2. ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);
3. ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);
4. ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();</code></pre><h3 id="线程池的执行策略"><a href="#线程池的执行策略" class="headerlink" title="线程池的执行策略"></a>线程池的执行策略</h3><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义###"></a>死锁定义###</h3><p>指多个线程因竞争资源而造成的一种僵局（互相等待）</p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol>
<li>互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待</li>
<li>不剥夺条件：资源不可被剥夺，即只能由获得该资源的线程自己来释放（只能是主动释放)</li>
<li>请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</li>
<li>循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ul>
<li>控制加锁顺序（线程按照一定的顺序加锁）</li>
<li>控制加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>
</ul>
<h3 id="多线程间的通信怎么实现"><a href="#多线程间的通信怎么实现" class="headerlink" title="多线程间的通信怎么实现"></a>多线程间的通信怎么实现</h3><ol>
<li>共享变量：线程间通信可以通过发送信号，发送信号的一个简单方式是在共享对象的变量里设置信号值</li>
<li>wait/notify机制：以资源为例，生产者生产一个资源，通知消费者就消费掉一个资源，生产者继续生产资源，消费者消费资源</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/2020/02/18/Java%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="java异常分类"><a href="#java异常分类" class="headerlink" title="java异常分类"></a>java异常分类</h3><ul>
<li>异常的根类为 java.lang.Throwable，Throwable 下面又派生了两个子类：Error 和 Exception。   </li>
<li>Error 一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。  </li>
<li>Exception 表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常。  </li>
<li>系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；  </li>
<li>普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够</li>
</ul>
<h3 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h3><ul>
<li>Error类异常的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</li>
<li>Exception类应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li>
<li>Exception中的普通异常必须 try..catch 处理或用 throws 声明继<br>续抛给上层调用方法处理，否则编译不会通过，所以普通异常也称为 checked 异常</li>
<li>Exception中的系统异常，可以处理也可以不处理，编译时不会报错，但运行可能出错</li>
</ul>
<h3 id="最常见的-5-个-RuntimeException"><a href="#最常见的-5-个-RuntimeException" class="headerlink" title="最常见的 5 个 RuntimeException"></a>最常见的 5 个 RuntimeException</h3><ol>
<li>java.lang.NullPointerException 空指针异常</li>
<li>java.lang.IndexOutOfBoundsException 数组角标越界异常</li>
<li>java.lang.ClassCastException 数据类型转换异常</li>
<li>java.lang.NumberFormatException 字符串转换为数字异常</li>
<li>SQLException SQL 异常，常见于操作数据库时的 SQL 语句错误</li>
<li>java.lang.IllegalArgumentException 方法传递参数错误</li>
</ol>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><ol>
<li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。</li>
<li>throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。  <h4 id="throws："><a href="#throws：" class="headerlink" title="throws："></a>throws：</h4></li>
<li>throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。  </li>
<li>throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。 </li>
<li>throws 表示出现异常的一种可能性，并不一定会发生这种异常。</li>
</ol>
<h3 id="调用下面的方法，得到的返回值是什么？"><a href="#调用下面的方法，得到的返回值是什么？" class="headerlink" title="调用下面的方法，得到的返回值是什么？"></a>调用下面的方法，得到的返回值是什么？</h3><blockquote>
<pre><code>1.public int getNum(){
2. try {
3. int a = 1/0;
4. return 1;
5. } catch (Exception e) {
6. return 2;
7. }finally{
8. return 3;
9. }</code></pre></blockquote>
<p>方法执行完返回3<br>在 catch 中遇到了 return 或者异常等能使该函数终止的话<br>那么有 finally 就必须先执行完 finally 代码块里面的代码</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/02/18/Java%E4%B9%8B%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h1><p><strong>final：java中的关键字，修饰符</strong></p>
<p>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.</p>
<ul>
<li>被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 </li>
<li>被声明final的方法只能使用，不能重载。</li>
</ul>
<p><strong>finally：java的一种异常处理机制。</strong></p>
<p>finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</p>
<p><strong>finalize：Java中的一个方法名</strong></p>
<p>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。<strong>finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p>
<p>  <strong>对象的销毁过程</strong> </p>
<p>在对象的销毁过程中，按照对象的finalize的执行情况，可以分为以下几种，系统会记录对象的对应状态：</p>
<ul>
<li>unfinalized 没有执行finalize，系统也不准备执行。 </li>
<li>finalizable 可以执行finalize了，系统会在随后的某个时间执行finalize。 </li>
<li>finalized 该对象的finalize已经被执行了。 </li>
</ul>
<p>GC怎么来保持对finalizable的对象的追踪呢。GC有一个Queue，叫做F-Queue，所有对象在变为finalizable的时候会加入到该Queue，然后等待GC执行它的finalize方法。 </p>
<p>这时我们引入了对对象的另外一种记录分类，系统可以检查到一个对象属于哪一种。<br>reachable 从活动的对象引用链可以到达的对象。包括所有线程当前栈的局部变量，所有的静态变量等等。<br>finalizer-reachable 除了reachable外，从F-Queue可以通过引用到达的对象。<br>unreachable 其它的对象。 </p>
<p>1 首先，所有的对象都是从Reachable+Unfinalized走向死亡之路的。 </p>
<p>2 当从当前活动集到对象不可达时，对象可以从Reachable状态变到F-Reachable或者Unreachable状态。 </p>
<p>3 当对象为非Reachable+Unfinalized时，GC会把它移入F-Queue，状态变为F-Reachable+Finalizable。 </p>
<p>4 好了，关键的来了，任何时候，GC都可以从F-Queue中拿到一个Finalizable的对象，标记它为Finalized，然后执行它的finalize方法，由于该对象在这个线程中又可达了，于是该对象变成Reachable了（并且Finalized）。而finalize方法执行时，又有可能把其它的F-Reachable的对象变为一个Reachable的，这个叫做对象再生。 </p>
<p>5 当一个对象在Unreachable+Unfinalized时，如果该对象使用的是默认的Object的finalize，或者虽然重写了，但是新的实现什么也不干。为了性能，GC可以把该对象之间变到Reclaimed状态直接销毁，而不用加入到F-Queue等待GC做进一步处理。 </p>
<p>6 从状态图看出，不管怎么折腾，任意一个对象的finalize只至多执行一次，一旦对象变为Finalized，就怎么也不会在回到F-Queue去了。当然没有机会再执行finalize了。 </p>
<p>7 当对象处于Unreachable+Finalized时，该对象离真正的死亡不远了。GC可以安全的回收该对象的内存了。进入Reclaimed。 </p>
<h1 id="二、Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#二、Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="二、Java中的String，StringBuilder，StringBuffer三者的区别"></a>二、Java中的String，StringBuilder，StringBuffer三者的区别</h1><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> System.out.println(str);</span><br><span class="line"><span class="number">3</span> str=str+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">4</span> System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，<strong>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</strong></p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">2</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line"><span class="number">3</span> System.out.println(str);</span><br><span class="line"><span class="number">4</span> System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>

<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">2 String str2&#x3D;&quot;de&quot;;</span><br><span class="line">3 String str&#x3D;str1+str2;</span><br></pre></td></tr></table></figure>

<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>　　2. 再来说线程安全</p>
<p>　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>　　3. 总结一下<br>　　<strong>String：适用于少量的字符串操作的情况</strong></p>
<p>　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
<h1 id="三、Arrays-sort-实现原理和-Collections-sort-实现原理"><a href="#三、Arrays-sort-实现原理和-Collections-sort-实现原理" class="headerlink" title="三、Arrays.sort 实现原理和 Collections.sort 实现原理"></a>三、Arrays.sort 实现原理和 Collections.sort 实现原理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://mycsdnblog.work/201919061054-m.png" alt="1551191608732"></p>
<h1 id="四、Java中boolean占几个字节"><a href="#四、Java中boolean占几个字节" class="headerlink" title="四、Java中boolean占几个字节"></a>四、Java中boolean占几个字节</h1><p>JVM规范指出boolean当做int处理，也就是4字节，boolean数组当做byte数组处理，这样我们可以得出boolean类型占了单独使用是4个字节，在数组中是确定的1个字节。</p>
<h1 id="五、Java基本类型所占的字节"><a href="#五、Java基本类型所占的字节" class="headerlink" title="五、Java基本类型所占的字节"></a>五、Java基本类型所占的字节</h1><p><img src="/.com//1551592963527.png" alt="1551592963527"></p>
<h1 id="六、Java的虚函数"><a href="#六、Java的虚函数" class="headerlink" title="六、Java的虚函数"></a>六、Java的虚函数</h1><p><strong>java类中普通成员函数就是虚函数。</strong></p>
<p>JAVA中的函数，除非声明为static或final，都可以看做是虚的，因为它们都是动态绑定的</p>
<p><strong>会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape1 = circle;</span><br><span class="line">        Shape shape2 = square;</span><br><span class="line">        shape1.draw();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、“方法”"><a href="#七、“方法”" class="headerlink" title="七、“方法”"></a>七、“方法”</h1><h2 id="7-1-Object中的方法"><a href="#7-1-Object中的方法" class="headerlink" title="7.1 Object中的方法"></a>7.1 Object中的方法</h2><p><img src="/.com//1561973717974.png" alt="1551439525914"></p>
<h2 id="7-2-String中常用的方法"><a href="#7-2-String中常用的方法" class="headerlink" title="7.2 String中常用的方法"></a>7.2 String中常用的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类中的方法。</span><br><span class="line">length()</span><br><span class="line">isEmpty()</span><br><span class="line">equals()</span><br><span class="line">toCharArray()</span><br><span class="line">valueOf()</span><br><span class="line">intern()</span><br><span class="line">compareTo()</span><br><span class="line">subString()</span><br><span class="line">contains()</span><br><span class="line">split()</span><br><span class="line">trim()</span><br><span class="line">toLowerCase()</span><br><span class="line">toUpperCase()</span><br><span class="line">startsWith()</span><br></pre></td></tr></table></figure>

<h1 id="八、Java中的浅拷贝和深拷贝"><a href="#八、Java中的浅拷贝和深拷贝" class="headerlink" title="八、Java中的浅拷贝和深拷贝"></a>八、Java中的浅拷贝和深拷贝</h1><h2 id="8-1-浅拷贝"><a href="#8-1-浅拷贝" class="headerlink" title="8.1 浅拷贝"></a>8.1 浅拷贝</h2><h3 id="8-1-1-基本概念"><a href="#8-1-1-基本概念" class="headerlink" title="8.1.1 基本概念"></a>8.1.1 基本概念</h3><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p>
<p>②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>具体模型如图所示：可以看到基本数据类型的成员变量，对其值创建了新的拷贝。而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。</p>
<p><img src="http://mycsdnblog.work/201919141921-T.png" alt></p>
<h3 id="8-1-2-实现方式"><a href="#8-1-2-实现方式" class="headerlink" title="8.1.2 实现方式"></a>8.1.2 实现方式</h3><blockquote>
<p><strong>通过拷贝构造方法实现浅拷贝</strong></p>
</blockquote>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(p1);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = person.age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = person.age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://mycsdnblog.work/201919141948-H.png" alt></p>
<p>结果分析：</p>
<p><strong>age为引用类型，age2为基本类型</strong></p>
<p>修改p1的age，p2的age也随之改变</p>
<p>修改p1的age2，p2的age2不变。</p>
<blockquote>
<p><strong>通过重写clone()方法进行浅拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919141953-J.png" alt></p>
<h2 id="8-2-深拷贝"><a href="#8-2-深拷贝" class="headerlink" title="8.2 深拷贝"></a>8.2 深拷贝</h2><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。<strong>那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象</strong>。<strong>也就是说，对象进行深拷贝要对整个对象图进行拷贝！</strong></p>
<p><strong>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</strong></p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="http://mycsdnblog.work/201919141955-9.png" alt></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h3 id="8-2-2-实现方式"><a href="#8-2-2-实现方式" class="headerlink" title="8.2.2 实现方式"></a>8.2.2 实现方式</h3><blockquote>
<p><strong>通过重写clone方法来实现深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        person.setAge((Age) person.getAge().clone());</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142004-2.png" alt></p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<blockquote>
<p><strong>通过序列化的方式进行深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(p1);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        Person p2 = (Person) objectInputStream.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142017-F.png" alt></p>
<h1 id="九、Java中的权限"><a href="#九、Java中的权限" class="headerlink" title="九、Java中的权限"></a>九、Java中的权限</h1><p>​       1、私有权限（private）</p>
<p>　　private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。</p>
<p>　　2、默认权限（default）</p>
<p>　　类，数据成员，构造方法，方法成员，都能够使用默认权限，<strong>即不写任何关键字</strong>。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。</p>
<p>　　3、受保护权限（protected）</p>
<p>　　protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</p>
<p>　　4、公共权限（public）</p>
<p>　　public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。  </p>
<h1 id="十、一个class文件中可以有几个类"><a href="#十、一个class文件中可以有几个类" class="headerlink" title="十、一个class文件中可以有几个类"></a>十、一个class文件中可以有几个类</h1><p>可以有多个类，但是：</p>
<p>1.public 权限的类只能有一个（也可以一个都没有，但最多只有1个）<br>2.这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）<br>3.若这个文件中没有public的类，则文件名随便是一个类的名字即可<br>4.你用Javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件</p>
<h1 id="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"><a href="#十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类" class="headerlink" title="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"></a>十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类</h1><p>1.抽象类和接口类的对比：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>抽象类</strong></th>
<th align="center"><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与正常Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center"><strong>它比接口速度要快</strong></td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>2.什么时候使用抽象类和接口</p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<p>3.Java8的改进</p>
<p>接口中可以声明default方法。default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</p>
<p>如果一个类实现了两个接口（可以看做是“多继承”），这两个接口又同时都包含了一个名字相同的default方法，那么会发生什么情况？ 在这样的情况下，编译器会报错。让我用例子来解释一下：</p>
<p><img src="http://mycsdnblog.work/201919122049-L.png" alt></p>
<h1 id="十二、自然排序和定制排序"><a href="#十二、自然排序和定制排序" class="headerlink" title="十二、自然排序和定制排序"></a>十二、自然排序和定制排序</h1><p>自然排序是通过实现了的Comparable来进行的</p>
<p>定制排序是实现Comparator</p>
<h1 id="十四、equals和hashcode的区别以及联系"><a href="#十四、equals和hashcode的区别以及联系" class="headerlink" title="十四、equals和hashcode的区别以及联系"></a>十四、equals和hashcode的区别以及联系</h1><p>1.equals方法</p>
<p>自反性 ： x.equals(x) 结果应该返回true。</p>
<p>对称性 ： x.equals(y) 结果返回true当且仅当y.equals(x)也应该返回true。</p>
<p>传递性 ： x.equals(y) 返回true，并且y.equals(z) 返回true，那么x.equals(z) 也应该返回true。</p>
<p>一致性 ： x.equals(y)的第一次调用为true，那么x.equals(y)的第二次，第三次等多次调用也应该为true，但是前提条件是在进行比较之前，x和y都没有被修改。</p>
<p>x.equals(null) 应该返回false。</p>
<p>这个方法返回true当且仅当x和y指向了同样的对象(x==y)，这句话也就是说明了在默认情况下，<strong>Object类中的equals方法默认比较的是对象的地址，因为只有是相同的地址才会相等(x == y)，如果没有重写equals方法，那么默认就是比较的是地址。</strong>注意：<strong>无论何时这个equals方法被重写那么都是有必要去重写hashCode方法，这个是因为为了维持hashCode的一种约定，相同的对象必须要有相同的hashCode值。</strong></p>
<p>2.hashcode</p>
<p>在同一次的java程序应用过程中，对应同样的对象多次调用hashCode方法，hashCode方法必须一致性的返回同样的一个地址值，前提是这个对象不能改变</p>
<p>两个对象相同是依据equals方法来的，那么其中的每一个对象调用hashCode方法都必须返回相同的一个integer值，也就是对象的地址。equals方法相等，那么hashCode方法也必须相等。</p>
<p>如果两个对象依据equals方法返回的结果不相等，那么对于其中的每一个对象调用hashCode方法返回的结果也不是一定必须得相等（也就是说，equals方法的结果为false，那么hashCode方法返回的结果可以相同也可以不相同），但是，对于我们开发者来说，针对两个对象的不相等如果生成相同的hashCode则可以提高应用程序的性能。</p>
<p>​         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p>
<p>​         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
<p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 </p>
<p><strong>并不是所有重写equals()的时候都要重写hashCode()，如果不涉及到哈希表的话，就不需要了。</strong></p>
<h1 id="十五：自动装箱与拆箱"><a href="#十五：自动装箱与拆箱" class="headerlink" title="十五：自动装箱与拆箱"></a>十五：自动装箱与拆箱</h1><h2 id="15-1-基本概念"><a href="#15-1-基本概念" class="headerlink" title="15.1 基本概念"></a>15.1 基本概念</h2><p>装箱：将基本类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>如何实现?</p>
<p>拿Integer来举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = integer; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p><strong>装箱：主要调用的是Integer的valueOf(int)方法</strong></p>
<p><strong>拆箱：自动调用Integer的intValue方法</strong></p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
<ol>
<li><p>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。</p>
</li>
<li><p><strong>Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。</strong></p>
</li>
<li><p>new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。</p>
</li>
</ol>
<h2 id="15-2-实战"><a href="#15-2-实战" class="headerlink" title="15.2 实战"></a>15.2 实战</h2><h3 id="15-2-1-示例1"><a href="#15-2-1-示例1" class="headerlink" title="15.2.1 示例1"></a>15.2.1 示例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果为：</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-示例2"><a href="#15-2-2-示例2" class="headerlink" title="15.2.2 示例2"></a>15.2.2 示例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double a = <span class="number">100.0</span>;</span><br><span class="line">        Double b = <span class="number">100.0</span>;</span><br><span class="line">        Double c = <span class="number">200.0</span>;</span><br><span class="line">        Double d = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>false<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。</p>
<p>很简单：<strong>在某个范围内的整型数值的个数是有限的，而浮点数却不是</strong>。</p>
<p>注意：</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double、Float的valueOf方法的实现是类似的。</li>
</ul>
<h1 id="十六、equals和"><a href="#十六、equals和" class="headerlink" title="十六、equals和=="></a>十六、equals和==</h1><p>==：判断两个对象的地址是否相等，基本类型就是判断值是否相等</p>
<p>equals：类没有重写equals方法，等价于==；覆盖的话就是比较两个对象的内容</p>
<h1 id="十七：Java闭包和回调"><a href="#十七：Java闭包和回调" class="headerlink" title="十七：Java闭包和回调"></a>十七：Java闭包和回调</h1><ul>
<li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</li>
<li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。</li>
</ul>
<p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p>
<p>在Java中，闭包是 通过“接口与内部类实现的”</p>
<p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”来实现，因为对于非静态内部类而言，它不仅记录了其外部类的详细信息，还保留了一个创建非静态内部类的引用，通过它可以访问外部类的私有成员，因此可以把非静态内部类当成面向对象领域的闭包。那么，通过这种仿闭包的非静态内部类可以很方便地实现回调，这是一种非常灵活的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-13 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 测试闭包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClosure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> Food();</span><br><span class="line">        food.getEat().eat();</span><br><span class="line">        food.getNum();</span><br><span class="line"></span><br><span class="line">        Food pub = <span class="keyword">new</span> Food();</span><br><span class="line">        Food.EatActive eatActive = pub.<span class="keyword">new</span> EatActive();</span><br><span class="line">        eatActive.eat();</span><br><span class="line">        pub.getNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"food"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"my food"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Active <span class="title">getEat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatActive</span> <span class="keyword">implements</span> <span class="title">Active</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"no"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Active</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包(closure)是一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域.</p>
<h1 id="十八、hashCode"><a href="#十八、hashCode" class="headerlink" title="十八、hashCode"></a>十八、hashCode</h1><p>hashCode就是根据存储在一个对象实例中的所有数据，提取出一个<strong>32</strong>位的整数，该整数的目的是用来标示该实例的唯一性，有点类似于MD5码，每个文件都能通过MD5算法生成一个唯一的MD5码。</p>
<h1 id="十九、Math-abs"><a href="#十九、Math-abs" class="headerlink" title="十九、Math.abs"></a>十九、Math.abs</h1><p>Java的API文档中说，对abs(int a)运算，“如果参数等于 Integer.MIN_VALUE 的值(即能够表示的最小负 int 值)，那么结果与该值相同且为负。</p>
<h1 id="二十、static关键字"><a href="#二十、static关键字" class="headerlink" title="二十、static关键字"></a>二十、static关键字</h1><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，<strong>它当且仅当在类初次加载时会被初始化</strong>。<strong>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</strong>。</p>
<p><strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong>。</p>
<h1 id="二十一、Collection和Collections的区别"><a href="#二十一、Collection和Collections的区别" class="headerlink" title="二十一、Collection和Collections的区别"></a>二十一、Collection和Collections的区别</h1><p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p> Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p>
<p>2、Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<h1 id="二十二、Overload和Override的区别？"><a href="#二十二、Overload和Override的区别？" class="headerlink" title="二十二、Overload和Override的区别？"></a>二十二、Overload和Override的区别？</h1><p> Overload是重载的意思，Override是覆盖的意思，也就是重写。</p>
<p>​    重载Overload：在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。</p>
<p>​    重载的特点：与返回值类型无关，只看参数列表。</p>
<p>​    重写Override表示子类中的方法可以与父类中的某个方法的<strong>名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中定义的那个完全相同的方法给覆盖掉了，这也是面向对象编程的多态的一种表现。子类覆盖父类方法时只能抛出父类的异常或者异常的子类或者父类异常的子集，因为子类可以解决父类的一些问题，但不能比父类有更多的问题。还有，子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，则子类中根本不存在覆盖，即子类中和父类的private的同名的方法没有覆盖的关系，因为private的访问权限只限于同一类中，而子类就不会访问到private的方法，所以是子类中增加的一个全新的方法。</p>
<p>​    <strong>重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法是可以改变返回值类型的</strong>。所以，如果两个方法的参数列表完全一样，是不能通过让他们的返回值类型不同来实现重载的。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<h1 id="二十三、Java参数是值传递还是引用传递"><a href="#二十三、Java参数是值传递还是引用传递" class="headerlink" title="二十三、Java参数是值传递还是引用传递"></a>二十三、Java参数是值传递还是引用传递</h1><p><strong>值传递</strong></p>
<p><strong>Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</strong></p>
<h1 id="二十四、final关键字对类、方法和成员变量的修饰"><a href="#二十四、final关键字对类、方法和成员变量的修饰" class="headerlink" title="二十四、final关键字对类、方法和成员变量的修饰"></a>二十四、final关键字对类、方法和成员变量的修饰</h1><ol>
<li>final修饰类 </li>
</ol>
<p>被修饰的类不能被继承，也没有子类。假如随意创建这些类的子类，子类可能会错误的修改父类的实现细节、出于安全原因，类的实现细节不允许有任何改动、在创建对象模型的时候，确信这个类不会再被扩展。<strong>注：如果对一个已经被final修饰的类进行继承操作，则会在编译的期间直接出现错误</strong></p>
<ol start="2">
<li>final修饰方法</li>
</ol>
<p>final修饰的方法表示此方法已经是“最后的、最终的”含义，<strong>亦即此方法不能被重写</strong>，（但是可以载多个final修饰的方法）。</p>
<p>需要注意的一点是: 重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法的访问权限是private，将会导致子类不能直接继承到此方法，这时候再在子类中定义相同的方法名和参数，不会产生重写与final之间出现的矛盾，而是在子类中定义了新的方法。</p>
<ol start="3">
<li>final修饰变量</li>
</ol>
<p><strong>final修饰的变量表示此变量是“最后的、最终的”,一旦定义了final变量，并在首次为其显示进行了初始化之后，final修饰的变量值不可被再修改。</strong></p>
<p>final修饰的变量，无论是类属性、对象属性、形参还是局部变量，这些变量都是需要进行显示初始化（即为其显示指定初始值）。</p>
<p><strong>另外，无论对于基本数据类型还是引用数据类型，final修饰的变量都是首次初始化后值都不能修改。对于基本数据类型，很好理解。对于引用数据类型，引用变量指向的是实际的对象，但其存储的是所指向对象的地址，因此，其值不能修改并不意味着其所指向的对象不能修改。</strong> </p>
<h1 id="二十五、整型转字符串"><a href="#二十五、整型转字符串" class="headerlink" title="二十五、整型转字符串"></a>二十五、整型转字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">String string = String.valueOf(i);</span><br><span class="line">String string2 = <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">String string3 = i.toString();</span><br></pre></td></tr></table></figure>

<h1 id="二十六、Java中的异常"><a href="#二十六、Java中的异常" class="headerlink" title="二十六、Java中的异常"></a>二十六、Java中的异常</h1><p>采用的设计模式是：<strong>责任链模式</strong></p>
<p>Java有两种异常类型：<strong>受检查异常和运行时异常</strong></p>
<p>检查异常：<strong>这些异常从程序的角度来说是必须经过捕捉处理的，否则编译通不过，</strong>比如IOException，SQLException。</p>
<p>运行时异常（不受检查异常）：Error和运行时异常</p>
<p>Error是程序无法处理的，如：OutOfMemmoryError，如果出现Error，Java虚拟机就会终止线程。</p>
<p><strong>运行时异常：如RunTimeException，IndexOutOfBoundsException，NullPointerException，这些异常一般是由程序的逻辑错误引起的，解决此类异常应该仔细排查程序，不需要进行检查。</strong></p>
<p><strong>两者的区别：</strong></p>
<p>非检查异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。</p>
<p><strong>受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。</strong></p>
<p>对于运行异常，建议不要用 try…catch…捕获处理，应该在程序开发调试的过程中尽量的避免，当然有一些必须要处理的，自己知道了那个部分会出现异常，而这种异常你要把它处理的你想要的结果，例如：空值处理。</p>
<p><img src="http://mycsdnblog.work/201919152249-a.png" alt></p>
<p>1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；</p>
<p><img src="http://mycsdnblog.work/201919152250-n.png" alt></p>
<p>2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；</p>
<p><img src="http://mycsdnblog.work/201919152250-9.png" alt></p>
<p>3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）</p>
<p><img src="http://mycsdnblog.work/201919152251-y.png" alt></p>
<p>4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获<strong>（就算我们没写异常捕获语句运行时也会抛出错误！！）</strong>，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<p><img src="http://mycsdnblog.work/201919152252-T.png" alt></p>
<p>5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>，这也是我们学习java异常语句中主要处理的异常对象。</p>
<p><img src="http://mycsdnblog.work/201919152253-t.png" alt></p>
<h1 id="二十七、Enum"><a href="#二十七、Enum" class="headerlink" title="二十七、Enum"></a>二十七、Enum</h1><h3 id="27-1-什么是Enum"><a href="#27-1-什么是Enum" class="headerlink" title="27.1 什么是Enum"></a>27.1 什么是Enum</h3><p>Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量</p>
<h3 id="27-2-Enum的特性"><a href="#27-2-Enum的特性" class="headerlink" title="27.2 Enum的特性"></a>27.2 Enum的特性</h3><ul>
<li>Enum常量隐式的加上了static和final，一旦被创建就无法修改</li>
<li>Enum提供了是类型安全的(type-safe)</li>
<li>Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量</li>
<li>两个Enum常量可以使用 <code>==</code>或<code>equals()</code>方法比较</li>
<li>Enum可以用在switch语句中，就像int，String。</li>
<li>Enum有自己的名称空间</li>
<li>Enum可以实现Java接口</li>
<li>可以在Enum中定义构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-04-26 20:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-3-Enum面试问题"><a href="#27-3-Enum面试问题" class="headerlink" title="27.3 Enum面试问题"></a>27.3 Enum面试问题</h3><ol>
<li>说说Enum的继承<br>所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口</li>
<li>Enum的values,ordinal,valueOf方法<br>enums默认有values()，ordinal()和valueOf()方法。<br>values()方法返回所有在enum中定义的常量值，以数组形式返回。<br>ordinal()方法返回每个常量的索引下标，就像数组的下标<br>valueOf()方法传入字符串参数，如果enum中存在对应字符串的常量值，则返回对应的enum常量</li>
</ol>
<h1 id="二十八、Java数组复制的方法"><a href="#二十八、Java数组复制的方法" class="headerlink" title="二十八、Java数组复制的方法"></a>二十八、Java数组复制的方法</h1><h2 id="28-1-for循环"><a href="#28-1-for循环" class="headerlink" title="28.1 for循环"></a>28.1 for循环</h2><p>代码灵活，效率低</p>
<h2 id="28-2-System-arraycopy-方法"><a href="#28-2-System-arraycopy-方法" class="headerlink" title="28.2 System.arraycopy()方法"></a>28.2 System.arraycopy()方法</h2><p>通过源码可以看到，其为native方法，即原生态方法。自然效率更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">* <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">* <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">* <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">* <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="28-3-Arrays-copyOf"><a href="#28-3-Arrays-copyOf" class="headerlink" title="28.3 Arrays.copyOf()"></a>28.3 Arrays.copyOf()</h2><p>实现还是基于System.arraycopy()，所以效率自然低于System.arraycpoy()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-4-Object-clone"><a href="#28-4-Object-clone" class="headerlink" title="28.4 Object.clone()"></a>28.4 Object.clone()</h2><p>从源码来看同样也是native方法，但返回为Object类型，所以赋值时将发生强转，所以效率不如之前两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二十九、Java中的泛型"><a href="#二十九、Java中的泛型" class="headerlink" title="二十九、Java中的泛型"></a>二十九、Java中的泛型</h1><h1 id="三十、Java中的迭代器"><a href="#三十、Java中的迭代器" class="headerlink" title="三十、Java中的迭代器"></a>三十、Java中的迭代器</h1><p>迭代器模式：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。</p>
<p>Iterator遍历时不可以删除集合中的元素问题</p>
<h1 id="三十一、Java中的内部类作用"><a href="#三十一、Java中的内部类作用" class="headerlink" title="三十一、Java中的内部类作用"></a>三十一、Java中的内部类作用</h1><p><strong>1.内部类可以很好的实现隐藏</strong></p>
<p> <strong>一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</strong></p>
<p><strong>2.内部类拥有外围类的所有元素的访问权限</strong></p>
<p><strong>3.可实现多重继承</strong></p>
<p><strong>4.可以避免修改接口而实现同一个类中两种同名方法的调用。</strong></p>
<p>如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。</p>
<h1 id="三十二、如何解析JSON"><a href="#三十二、如何解析JSON" class="headerlink" title="三十二、如何解析JSON"></a>三十二、如何解析JSON</h1><h1 id="三十三、不用中间变量交换两个数"><a href="#三十三、不用中间变量交换两个数" class="headerlink" title="三十三、不用中间变量交换两个数"></a>三十三、不用中间变量交换两个数</h1><p>a=a+b b=a-b a=a-b</p>
<p>a= a ^ b b = a ^ b a = a ^ b</p>
<h1 id="三十四、Java中对象的大小"><a href="#三十四、Java中对象的大小" class="headerlink" title="三十四、Java中对象的大小"></a>三十四、Java中对象的大小</h1><h2 id="34-1-Java对象结构"><a href="#34-1-Java对象结构" class="headerlink" title="34.1 Java对象结构"></a>34.1 Java对象结构</h2><p><img src="http://mycsdnblog.work/201919111010-0.png" alt></p>
<ol>
<li>Mark Word：存储对象运行时记录信息（<strong>存储对象的HashCode、分代年龄和锁标记位</strong>），占用内存大小与机器位数一样，即<strong>32位机占4字节，64位机占8字节</strong></li>
<li>元数据指针：指向描述类型的Klass对象（Java类的C++对等体）的指针，Klass对象包含了实例对象所属类型的元数据，因此该字段被称为元数据指针，JVM在运行时将频繁使用这个指针定位到位于方法区内的类型信息。<strong>占用内存大小与机器位数一样</strong>。</li>
<li>数组长度：数组对象特有，4个字节</li>
<li>实例数据：实例数据就是8大基本数据类型byte、short、int、long、float、double、char、boolean（对象类型也是由这8大基本数据类型复合而成），每种数据类型占多少字节就不一一例举了</li>
<li>填充：不定，<strong>HotSpot的对齐方式为8字节对齐，即一个对象必须为8字节的整数倍</strong>，因此如果最后前面的数据大小为17则填充7，前面的数据大小为18则填充6，以此类推</li>
</ol>
<p>为了保证效率，Java编译期在编译Java对象的时候，通过字段类型对Java对象的字段会进行排序，具体顺序如下表所示：</p>
<p><img src="http://mycsdnblog.work/201919111012-s.png" alt></p>
<p>元数据指针的大小。元数据指针是一个引用类型，因此正常来说64位机元数据指针应当为8字节，32位机元数据指针应当为4字节，<strong>但是HotSpot中有一项优化是对元数据类型指针进行压缩存储</strong>，使用JVM参数：</p>
<ul>
<li>-XX:+UseCompressedOops开启压缩</li>
<li>-XX:-UseCompressedOops关闭压缩</li>
</ul>
<p>HotSpot默认是前者，即开启元数据指针压缩，当开启压缩的时候，64位机上的元数据指针将占据4个字节的大小。换句话说就是<strong>当开启压缩的时候，64位机上的引用将占据4个字节，否则是正常的8字节</strong>。</p>
<h2 id="34-2-Java对象内存大小计算"><a href="#34-2-Java对象内存大小计算" class="headerlink" title="34.2 Java对象内存大小计算"></a>34.2 Java对象内存大小计算</h2><p>首先是Object对象的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 = 12字节，由于12字节不是8的倍数，因此填充4字节，对象Object占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，对象Object占据16字节内存</li>
</ol>
<p>接着是字符’a’的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 2字节char = 14字节，由于14字节不是8的倍数，因此填充2字节，字符’a’占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，字符’a’占据24字节内存</li>
</ol>
<p>接着是整型1的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节int = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，整型1占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 4字节int = 20字节，由于20字节正好是8的倍数，因此填充4字节，整型1占据24字节内存</li>
</ol>
<p>接着是字符串”aaaaa”的大小，所有静态字段不需要管，只关注实例字段，String对象中实例字段有”char value[]”与”int hash”，由此可知：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节引用 + 4字节int = 20字节，由于20字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据24字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 8字节引用 + 4字节int = 28字节，由于28字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据32字节内存</li>
</ol>
<p>最后是长度为1的char型数组的大小：</p>
<ol>
<li>开启指针压缩时，8字节的Mark Word + 4字节的元数据指针 + 4字节的数组大小引用 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，长度为1的char型数组占据24字节内存</li>
<li>关闭指针压缩时，8字节的Mark Word + 8字节的元数据指针 + 8字节的数组大小引用 + 2字节char = 26字节，由于26字节不是8的倍数，因此填充6字节，长度为1的char型数组占据32字节内存</li>
</ol>
<h1 id="三十五、Class-forName-和ClassLoader-loadClass的区别"><a href="#三十五、Class-forName-和ClassLoader-loadClass的区别" class="headerlink" title="三十五、Class.forName()和ClassLoader.loadClass的区别"></a>三十五、Class.forName()和ClassLoader.loadClass的区别</h1><h2 id="35-1-Java类的装载过程"><a href="#35-1-Java类的装载过程" class="headerlink" title="35.1 Java类的装载过程"></a>35.1 Java类的装载过程</h2><p><img src="http://mycsdnblog.work/201919160937-r.png" alt></p>
<p>1.装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象； </p>
<p>2.链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； </p>
<ul>
<li>校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证） </li>
<li>准备：给类的静态变量分配并初始化存储空间； </li>
<li>解析：将常量池中的符号引用转成直接引用； </li>
</ul>
<p>3.初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
<h2 id="35-2-Class-forName-和ClassLoader-loadClass"><a href="#35-2-Class-forName-和ClassLoader-loadClass" class="headerlink" title="35.2 Class.forName()和ClassLoader.loadClass"></a>35.2 <strong>Class.forName()和ClassLoader.loadClass</strong></h2><p>Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);</p>
<p>第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。</p>
<p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。</p>
<p>ClassLoader.getSystemClassLoader().loadClass(className)方法，内部实际调用的方法是  ClassLoader.getSystemClassLoader().loadClass(className,false);</p>
<p>第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，</p>
<p>不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</p>
<h2 id="35-3-为什么数据库连接要使用Class-forName-className"><a href="#35-3-为什么数据库连接要使用Class-forName-className" class="headerlink" title="35.3 为什么数据库连接要使用Class.forName(className)"></a>35.3 为什么数据库连接要使用Class.forName(className)</h2><p>JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-4-Class-forName，Class-class，getClass-的区别"><a href="#35-4-Class-forName，Class-class，getClass-的区别" class="headerlink" title="35.4 Class.forName，Class.class，getClass()的区别"></a>35.4 Class.forName，Class.class，getClass()的区别</h2><p>Class.forName：会触发静态初始化</p>
<p>Class.class：将类装载进JVM中，不做初始化工作</p>
<p>getClass()：对类进行静态和非静态初始化</p>
<h1 id="三十六、序列化版本号serialVersionUID的作用"><a href="#三十六、序列化版本号serialVersionUID的作用" class="headerlink" title="三十六、序列化版本号serialVersionUID的作用"></a>三十六、序列化版本号serialVersionUID的作用</h1><p>Java中序列化，实现Serializable接口</p>
<p>serialVersionUID的主要作用有以下两个：</p>
<p>1、能够成功反序列化</p>
<p>2、版本控制</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 </li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </li>
</ul>
<h1 id="三十七、MVC和MVVM"><a href="#三十七、MVC和MVVM" class="headerlink" title="三十七、MVC和MVVM"></a>三十七、MVC和MVVM</h1><p>MVC，Model View Controller，是软件架构中最常见的一种框架，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。</p>
<p><img src="http://mycsdnblog.work/201919041924-a.png" alt></p>
<h1 id="三十八、Java中char可以表示一个汉字吗？"><a href="#三十八、Java中char可以表示一个汉字吗？" class="headerlink" title="三十八、Java中char可以表示一个汉字吗？"></a>三十八、Java中char可以表示一个汉字吗？</h1><p>在uft8编码下占三个字节；<br><strong>在GBK编码下占2个字节；</strong><br>但是如果 char表示英文字母：<br>在uft8编码下占一个字节；<br><strong>在GBK编码下还是占2个字节；</strong> </p>
<p><strong>所以char类型的值不管是英文还是中文都是统一两个字节！</strong> </p>
<h1 id="三十九、Java对象的生命周期"><a href="#三十九、Java对象的生命周期" class="headerlink" title="三十九、Java对象的生命周期"></a>三十九、Java对象的生命周期</h1><p>在Java中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li><p>创建阶段(Created)</p>
</li>
<li><p>应用阶段(In Use)</p>
</li>
<li><p>不可见阶段(Invisible)</p>
<p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。</p>
</li>
<li><p>不可达阶段(Unreachable)</p>
<p>对象处于不可达阶段是指该对象不再被任何强引用所持有</p>
<p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>
</li>
<li><p>收集阶段(Collected)</p>
<p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)</p>
<p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)</p>
<p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ol>
<h1 id="四十、理解Java中的各种O"><a href="#四十、理解Java中的各种O" class="headerlink" title="四十、理解Java中的各种O"></a>四十、理解Java中的各种O</h1><p><strong>1、PO(persistant object) 持久对象</strong> </p>
<p>对应于DAO层中操作的对象</p>
<ul>
<li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录，多个记录可以用PO的集合。</li>
<li>在o/r 映射的时候出现的概念,如果没有o/r映射,就没有这个概念存在了。</li>
<li>PO中应该不包含任何对数据库的操作。</li>
</ul>
<p><strong>2、VO(value object) 值对象</strong> </p>
<p>对应View层，用于显示的Java Bean</p>
<ul>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不（大部分情况是表所有字段集合的子集），这根据业务的需要。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的web service传输中而VO用于界面的展示，可以把DTO转化为VO提供给前台。</p>
</li>
</ul>
<p><strong>3、DTO(Data Transfer Object)，数据传输对象</strong> </p>
<p>在应用程序不同tie(关系)之间传输的对象 </p>
<p>对应Controller层中，接收和返回的Java Bean。</p>
<ul>
<li>用在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li>
</ul>
<p><strong>4、BO(business object) 业务对象</strong> </p>
<p>对应Service中的Java Bean </p>
<ul>
<li><p>从业务模型的角度看,见UML元件领域模型中的领域对象.封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ul>
<p>关于BO主要有三种概念</p>
<ul>
<li>只包含业务对象的属性</li>
<li>只包含业务方法</li>
<li>两者都包含</li>
</ul>
<p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<p><strong>5、DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO,<br>提供数据库的CRUD操作…   </p>
<p><strong>6、POJO(plain ordinary java object) 简单无规则java对象</strong><br>纯的传统意义的java对象。就是说在一些Object/Relation<br>Mapping工具中，能够做到维护数据库表记录的persisent<br>object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java<br>Bean，只有属性字段及setter和getter方法！。 </p>
<p><img src="http://mycsdnblog.work/201919161441-u.png" alt></p>
<h1 id="四十一、Spring-Boot中的classpath"><a href="#四十一、Spring-Boot中的classpath" class="headerlink" title="四十一、Spring Boot中的classpath"></a>四十一、Spring Boot中的classpath</h1><p>springboot项目创建完成后，会生成该项目名称+iml后缀的文件。该文件位于项目的根目录下。<br>打开后，在name=”NewModuleRootManager”的component声明中，会有几个默认content声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/resources"</span> <span class="attr">type</span>=<span class="string">"java-resource"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/test/java"</span> <span class="attr">isTestSource</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/target"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中sourceFolder 中声明的就是classpath，只是类型不同。对应的工程文件目录：</p>
<p><img src="http://mycsdnblog.work/201919171559-E.png" alt></p>
<p>其中蓝色的java目录：保存项目的java文件。<br> resources是项目的资源目录，里面通常包含static与templates目录<br> 绿色的test/java目录是编写的测试类的目录。</p>
<ul>
<li>工程编译后，会将src/main/java中的.java文件按照包文件结构编译成.class存入target/classes目录。</li>
<li>工程编译后，会将src/main/resources中的static、templates目录里的文件分别拷贝入classes/static 与classes/template 中。结构保持一致。</li>
<li>工程编译后，会将test/java 中的文件编译进classes/test-classes目录中。</li>
</ul>
<p><strong>可以根据项目需要，修改.iml文件的content，来添加不同的资源路径。</strong></p>
<h1 id="四十二、静态内部类的和普通内部类的区别"><a href="#四十二、静态内部类的和普通内部类的区别" class="headerlink" title="四十二、静态内部类的和普通内部类的区别"></a>四十二、静态内部类的和普通内部类的区别</h1><p>定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明 为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是<strong>外部类可以访问内部类的所有方法与属性，包括私有方法与属性</strong>。</p>
<h2 id="42-1-创建实例"><a href="#42-1-创建实例" class="headerlink" title="42.1 创建实例"></a>42.1 创建实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass.InnerClass innerClass = OutClass.getInstance().<span class="keyword">new</span> InnerClass();</span><br><span class="line"></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-2-内部类中的this"><a href="#42-2-内部类中的this" class="headerlink" title="42.2 内部类中的this"></a>42.2 内部类中的this</h2><p> 内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，于是能访问外围类的所有成员，不需任何特殊条件，可理 解为内部类链接到外部类。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。</p>
<h2 id="42-3-外部类访问内部类"><a href="#42-3-外部类访问内部类" class="headerlink" title="42.3 外部类访问内部类"></a>42.3 外部类访问内部类</h2><p>内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。内部类对象通过‘外部类名.this.xxx’的形式访问外部类的属性与方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-4-内部类向上转型"><a href="#42-4-内部类向上转型" class="headerlink" title="42.4 内部类向上转型"></a>42.4 内部类向上转型</h2><p>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类访问，从而完全隐藏实现的细节。</p>
<h2 id="42-5-方法内的类"><a href="#42-5-方法内的类" class="headerlink" title="42.5 方法内的类"></a>42.5 方法内的类</h2><p>方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-6-静态内部类"><a href="#42-6-静态内部类" class="headerlink" title="42.6 静态内部类"></a>42.6 静态内部类</h2><p>定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。</p>
<p>通常称为<strong>嵌套类</strong>，当内部类是static时，意味着：</p>
<p>   [1]<strong>要创建嵌套类的对象，并不需要其外围类的对象</strong>；</p>
<p>   [2]<strong>不能从嵌套类的对象中访问非静态的外围类对象</strong>（不能够从静态内部类的对象中访问外部类的非静态成员）；</p>
<p>嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，<strong>所以普通的内部类不能有static数据和static字段</strong>， 也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。<strong>也就是说，在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这 个类中定义静态的成员变量与成员方法。</strong></p>
<p>另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的 对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于 该类的对象，更不属于其他外部类的对象。</p>
<h2 id="42-7-内部类标识符"><a href="#42-7-内部类标识符" class="headerlink" title="42.7 内部类标识符"></a>42.7 内部类标识符</h2><p>每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：<strong>外围类的名字，加上$,再加上内部类名字</strong>。</p>
<h2 id="42-8-为什么使用内部类"><a href="#42-8-为什么使用内部类" class="headerlink" title="42.8 为什么使用内部类"></a>42.8 为什么使用内部类</h2><p><strong>内部类一般只为其外部类使用；</strong></p>
<p><strong>内部类提供了某种进入外部类的窗户；</strong></p>
<p><strong>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。</strong></p>
<h1 id="四十三、接口的幂等性"><a href="#四十三、接口的幂等性" class="headerlink" title="四十三、接口的幂等性"></a>四十三、接口的幂等性</h1><p>同步锁</p>
<p>分布式锁</p>
<p>业务字段加唯一约束</p>
<p>令牌表+唯一约束</p>
<p>mysql的insert ignore或者on duplicate key update</p>
<p>共享锁+普通索引</p>
<p>利用MQ或者Redis扩展</p>
<p>使用redis去重</p>
<h1 id="四十四、Java自动类型转换"><a href="#四十四、Java自动类型转换" class="headerlink" title="四十四、Java自动类型转换"></a>四十四、Java自动类型转换</h1><p><img src="http://mycsdnblog.work/201919011617-G.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/2020/02/18/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、final、finally、finalize的区别"><a href="#一、final、finally、finalize的区别" class="headerlink" title="一、final、finally、finalize的区别"></a>一、final、finally、finalize的区别</h1><p><strong>final：java中的关键字，修饰符</strong></p>
<p>A).如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>B).如果将变量或者方法声明为final，可以保证它们在使用中不被改变.</p>
<ul>
<li>被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 </li>
<li>被声明final的方法只能使用，不能重载。</li>
</ul>
<p><strong>finally：java的一种异常处理机制。</strong></p>
<p>finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</p>
<p><strong>finalize：Java中的一个方法名</strong></p>
<p>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。<strong>finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</strong></p>
<p>  <strong>对象的销毁过程</strong> </p>
<p>在对象的销毁过程中，按照对象的finalize的执行情况，可以分为以下几种，系统会记录对象的对应状态：</p>
<ul>
<li>unfinalized 没有执行finalize，系统也不准备执行。 </li>
<li>finalizable 可以执行finalize了，系统会在随后的某个时间执行finalize。 </li>
<li>finalized 该对象的finalize已经被执行了。 </li>
</ul>
<p>GC怎么来保持对finalizable的对象的追踪呢。GC有一个Queue，叫做F-Queue，所有对象在变为finalizable的时候会加入到该Queue，然后等待GC执行它的finalize方法。 </p>
<p>这时我们引入了对对象的另外一种记录分类，系统可以检查到一个对象属于哪一种。<br>reachable 从活动的对象引用链可以到达的对象。包括所有线程当前栈的局部变量，所有的静态变量等等。<br>finalizer-reachable 除了reachable外，从F-Queue可以通过引用到达的对象。<br>unreachable 其它的对象。 </p>
<p>1 首先，所有的对象都是从Reachable+Unfinalized走向死亡之路的。 </p>
<p>2 当从当前活动集到对象不可达时，对象可以从Reachable状态变到F-Reachable或者Unreachable状态。 </p>
<p>3 当对象为非Reachable+Unfinalized时，GC会把它移入F-Queue，状态变为F-Reachable+Finalizable。 </p>
<p>4 好了，关键的来了，任何时候，GC都可以从F-Queue中拿到一个Finalizable的对象，标记它为Finalized，然后执行它的finalize方法，由于该对象在这个线程中又可达了，于是该对象变成Reachable了（并且Finalized）。而finalize方法执行时，又有可能把其它的F-Reachable的对象变为一个Reachable的，这个叫做对象再生。 </p>
<p>5 当一个对象在Unreachable+Unfinalized时，如果该对象使用的是默认的Object的finalize，或者虽然重写了，但是新的实现什么也不干。为了性能，GC可以把该对象之间变到Reclaimed状态直接销毁，而不用加入到F-Queue等待GC做进一步处理。 </p>
<p>6 从状态图看出，不管怎么折腾，任意一个对象的finalize只至多执行一次，一旦对象变为Finalized，就怎么也不会在回到F-Queue去了。当然没有机会再执行finalize了。 </p>
<p>7 当对象处于Unreachable+Finalized时，该对象离真正的死亡不远了。GC可以安全的回收该对象的内存了。进入Reclaimed。 </p>
<h1 id="二、Java中的String，StringBuilder，StringBuffer三者的区别"><a href="#二、Java中的String，StringBuilder，StringBuffer三者的区别" class="headerlink" title="二、Java中的String，StringBuilder，StringBuffer三者的区别"></a>二、Java中的String，StringBuilder，StringBuffer三者的区别</h1><p>这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。</p>
<ol>
<li>首先说运行速度，或者说是执行速度，<strong>在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String</strong></li>
</ol>
<p>　　<strong>String最慢的原因：</strong></p>
<p>　　<strong>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。</strong>以下面一段代码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>;</span><br><span class="line"><span class="number">2</span> System.out.println(str);</span><br><span class="line"><span class="number">3</span> str=str+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">4</span> System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>　　如果运行这段代码会发现先输出“abc”，然后又输出“abcde”，好像是str这个对象被更改了，其实，这只是一种假象罢了，JVM对于这几行代码是这样处理的，首先创建一个String对象str，并把“abc”赋值给str，然后在第三行中，其实JVM又创建了一个新的对象也名为str，然后再把原来的str的值和“de”加起来再赋值给新的str，而原来的str就会被JVM的垃圾回收机制（GC）给回收掉了，所以，str实际上并没有被更改，也就是前面说的String对象一旦创建之后就不可更改了。所以，<strong>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。</strong></p>
<p>　　而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p>
<p>　　另外，有时候我们会这样对字符串进行赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> String str=<span class="string">"abc"</span>+<span class="string">"de"</span>;</span><br><span class="line"><span class="number">2</span> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder().append(<span class="string">"abc"</span>).append(<span class="string">"de"</span>);</span><br><span class="line"><span class="number">3</span> System.out.println(str);</span><br><span class="line"><span class="number">4</span> System.out.println(stringBuilder.toString());</span><br></pre></td></tr></table></figure>

<p>　　这样输出结果也是“abcde”和“abcde”，但是String的速度却比StringBuilder的反应速度要快很多，这是因为第1行中的操作和</p>
<p>　　String str=”abcde”;</p>
<p>　　是完全一样的，所以会很快，而如果写成下面这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 String str1&#x3D;&quot;abc&quot;;</span><br><span class="line">2 String str2&#x3D;&quot;de&quot;;</span><br><span class="line">3 String str&#x3D;str1+str2;</span><br></pre></td></tr></table></figure>

<p>　　那么JVM就会像上面说的那样，不断的创建、回收对象来进行这个操作了。速度就会很慢。</p>
<p>　　2. 再来说线程安全</p>
<p>　　<strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong></p>
<p>　　如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p>
<p>　　3. 总结一下<br>　　<strong>String：适用于少量的字符串操作的情况</strong></p>
<p>　　<strong>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</strong></p>
<p>　　<strong>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</strong></p>
<h1 id="三、Arrays-sort-实现原理和-Collections-sort-实现原理"><a href="#三、Arrays-sort-实现原理和-Collections-sort-实现原理" class="headerlink" title="三、Arrays.sort 实现原理和 Collections.sort 实现原理"></a>三、Arrays.sort 实现原理和 Collections.sort 实现原理</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="http://mycsdnblog.work/201919061054-m.png" alt="1551191608732"></p>
<h1 id="四、Java中boolean占几个字节"><a href="#四、Java中boolean占几个字节" class="headerlink" title="四、Java中boolean占几个字节"></a>四、Java中boolean占几个字节</h1><p>JVM规范指出boolean当做int处理，也就是4字节，boolean数组当做byte数组处理，这样我们可以得出boolean类型占了单独使用是4个字节，在数组中是确定的1个字节。</p>
<h1 id="五、Java基本类型所占的字节"><a href="#五、Java基本类型所占的字节" class="headerlink" title="五、Java基本类型所占的字节"></a>五、Java基本类型所占的字节</h1><p><img src="/.com//1551592963527.png" alt="1551592963527"></p>
<h1 id="六、Java的虚函数"><a href="#六、Java的虚函数" class="headerlink" title="六、Java的虚函数"></a>六、Java的虚函数</h1><p><strong>java类中普通成员函数就是虚函数。</strong></p>
<p>JAVA中的函数，除非声明为static或final，都可以看做是虚的，因为它们都是动态绑定的</p>
<p><strong>会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"square"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.test2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-12 20:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line">        Square square = <span class="keyword">new</span> Square();</span><br><span class="line">        square.draw();</span><br><span class="line"></span><br><span class="line">        Shape shape1 = circle;</span><br><span class="line">        Shape shape2 = square;</span><br><span class="line">        shape1.draw();</span><br><span class="line">        shape2.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、“方法”"><a href="#七、“方法”" class="headerlink" title="七、“方法”"></a>七、“方法”</h1><h2 id="7-1-Object中的方法"><a href="#7-1-Object中的方法" class="headerlink" title="7.1 Object中的方法"></a>7.1 Object中的方法</h2><p><img src="/.com//1561973717974.png" alt="1551439525914"></p>
<h2 id="7-2-String中常用的方法"><a href="#7-2-String中常用的方法" class="headerlink" title="7.2 String中常用的方法"></a>7.2 String中常用的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object类中的方法。</span><br><span class="line">length()</span><br><span class="line">isEmpty()</span><br><span class="line">equals()</span><br><span class="line">toCharArray()</span><br><span class="line">valueOf()</span><br><span class="line">intern()</span><br><span class="line">compareTo()</span><br><span class="line">subString()</span><br><span class="line">contains()</span><br><span class="line">split()</span><br><span class="line">trim()</span><br><span class="line">toLowerCase()</span><br><span class="line">toUpperCase()</span><br><span class="line">startsWith()</span><br></pre></td></tr></table></figure>

<h1 id="八、Java中的浅拷贝和深拷贝"><a href="#八、Java中的浅拷贝和深拷贝" class="headerlink" title="八、Java中的浅拷贝和深拷贝"></a>八、Java中的浅拷贝和深拷贝</h1><h2 id="8-1-浅拷贝"><a href="#8-1-浅拷贝" class="headerlink" title="8.1 浅拷贝"></a>8.1 浅拷贝</h2><h3 id="8-1-1-基本概念"><a href="#8-1-1-基本概念" class="headerlink" title="8.1.1 基本概念"></a>8.1.1 基本概念</h3><p>①对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。因为是两份不同的数据，所以对其中一个对象的该成员变量值进行修改，不会影响另一个对象拷贝得到的数据。</p>
<p>②对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</p>
<p>具体模型如图所示：可以看到基本数据类型的成员变量，对其值创建了新的拷贝。而引用数据类型的成员变量的实例仍然是只有一份，两个对象的该成员变量都指向同一个实例。</p>
<p><img src="http://mycsdnblog.work/201919141921-T.png" alt></p>
<h3 id="8-1-2-实现方式"><a href="#8-1-2-实现方式" class="headerlink" title="8.1.2 实现方式"></a>8.1.2 实现方式</h3><blockquote>
<p><strong>通过拷贝构造方法实现浅拷贝</strong></p>
</blockquote>
<p>拷贝构造方法指的是该类的构造方法参数为该类的对象。使用拷贝构造方法可以很好地完成浅拷贝，直接通过一个现有的对象创建出与该对象属性相同的新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(p1);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = person.age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = person.age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://mycsdnblog.work/201919141948-H.png" alt></p>
<p>结果分析：</p>
<p><strong>age为引用类型，age2为基本类型</strong></p>
<p>修改p1的age，p2的age也随之改变</p>
<p>修改p1的age2，p2的age2不变。</p>
<blockquote>
<p><strong>通过重写clone()方法进行浅拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919141953-J.png" alt></p>
<h2 id="8-2-深拷贝"><a href="#8-2-深拷贝" class="headerlink" title="8.2 深拷贝"></a>8.2 深拷贝</h2><h3 id="8-2-1-基本概念"><a href="#8-2-1-基本概念" class="headerlink" title="8.2.1 基本概念"></a>8.2.1 基本概念</h3><p>首先介绍对象图的概念。设想一下，一个类有一个对象，其成员变量中又有一个对象，该对象指向另一个对象，另一个对象又指向另一个对象，直到一个确定的实例。这就形成了对象图。<strong>那么，对于深拷贝来说，不仅要复制对象的所有基本数据类型的成员变量值，还要为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象</strong>。<strong>也就是说，对象进行深拷贝要对整个对象图进行拷贝！</strong></p>
<p><strong>简单地说，深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间。</strong></p>
<p>深拷贝模型如图所示：可以看到所有的成员变量都进行了复制。</p>
<p><img src="http://mycsdnblog.work/201919141955-9.png" alt></p>
<p>因为创建内存空间和拷贝整个对象图，所以深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h3 id="8-2-2-实现方式"><a href="#8-2-2-实现方式" class="headerlink" title="8.2.2 实现方式"></a>8.2.2 实现方式</h3><blockquote>
<p><strong>通过重写clone方法来实现深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj;</span><br><span class="line">        obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        person.setAge((Age) person.getAge().clone());</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142004-2.png" alt></p>
<p>分析结果可以验证：进行了深拷贝之后，无论是什么类型的属性值的修改，都不会影响另一个对象的属性值。</p>
<blockquote>
<p><strong>通过序列化的方式进行深拷贝</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> copy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-14 19:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Copy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Age age = <span class="keyword">new</span> Age(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(age,<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(byteArrayOutputStream);</span><br><span class="line">        outputStream.writeObject(p1);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        Person p2 = (Person) objectInputStream.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line"></span><br><span class="line">        p1.setAge2(<span class="number">999</span>);</span><br><span class="line">        age.setAge(<span class="number">99</span>);</span><br><span class="line">        p1.setAge(age);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Age age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Age age, <span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Age <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Age age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge2</span><span class="params">(<span class="keyword">int</span> age2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age2 = age2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">", age2="</span> + age2 +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Age</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Age&#123;"</span> +</span><br><span class="line">                <span class="string">"age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://mycsdnblog.work/201919142017-F.png" alt></p>
<h1 id="九、Java中的权限"><a href="#九、Java中的权限" class="headerlink" title="九、Java中的权限"></a>九、Java中的权限</h1><p>​       1、私有权限（private）</p>
<p>　　private可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。</p>
<p>　　2、默认权限（default）</p>
<p>　　类，数据成员，构造方法，方法成员，都能够使用默认权限，<strong>即不写任何关键字</strong>。默认权限即同包权限，同包权限的元素只能在定义它们的类中，以及同包的类中被调用。</p>
<p>　　3、受保护权限（protected）</p>
<p>　　protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</p>
<p>　　4、公共权限（public）</p>
<p>　　public可以修饰类，数据成员，构造方法，方法成员。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符。  </p>
<h1 id="十、一个class文件中可以有几个类"><a href="#十、一个class文件中可以有几个类" class="headerlink" title="十、一个class文件中可以有几个类"></a>十、一个class文件中可以有几个类</h1><p>可以有多个类，但是：</p>
<p>1.public 权限的类只能有一个（也可以一个都没有，但最多只有1个）<br>2.这个.java文件的文件名必须是public类的类名（一般的情况下，这里放置main方法是程序的入口。）<br>3.若这个文件中没有public的类，则文件名随便是一个类的名字即可<br>4.你用Javac 编译这个.java文件的时候，它会给每一个类生成一个.class文件</p>
<h1 id="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"><a href="#十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类" class="headerlink" title="十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类"></a>十一、Abstract类与接口类的区别，为什么有了接口类还要用抽象类</h1><p>1.抽象类和接口类的对比：</p>
<table>
<thead>
<tr>
<th align="center"><strong>参数</strong></th>
<th align="center"><strong>抽象类</strong></th>
<th align="center"><strong>接口</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认的方法实现</td>
<td align="center">它可以有默认的方法实现</td>
<td align="center">接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td align="center">子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td align="center">构造器</td>
<td align="center">抽象类可以有构造器</td>
<td align="center">接口不能有构造器</td>
</tr>
<tr>
<td align="center">与正常Java类的区别</td>
<td align="center">除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td align="center">接口是完全不同的类型</td>
</tr>
<tr>
<td align="center">访问修饰符</td>
<td align="center">抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td align="center">接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td align="center">main方法</td>
<td align="center">抽象方法可以有main方法并且我们可以运行它</td>
<td align="center">接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td align="center">多继承</td>
<td align="center">抽象方法可以继承一个类和实现多个接口</td>
<td align="center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center"><strong>它比接口速度要快</strong></td>
<td align="center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td align="center">添加新方法</td>
<td align="center">如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td align="center">如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
</tbody></table>
<p>2.什么时候使用抽象类和接口</p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
</ul>
<p>3.Java8的改进</p>
<p>接口中可以声明default方法。default方法是指，在接口内部包含了一些默认的方法实现（也就是接口中可以包含方法体，这打破了Java之前版本对接口的语法限制），从而使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码。</p>
<p>如果一个类实现了两个接口（可以看做是“多继承”），这两个接口又同时都包含了一个名字相同的default方法，那么会发生什么情况？ 在这样的情况下，编译器会报错。让我用例子来解释一下：</p>
<p><img src="http://mycsdnblog.work/201919122049-L.png" alt></p>
<h1 id="十二、自然排序和定制排序"><a href="#十二、自然排序和定制排序" class="headerlink" title="十二、自然排序和定制排序"></a>十二、自然排序和定制排序</h1><p>自然排序是通过实现了的Comparable来进行的</p>
<p>定制排序是实现Comparator</p>
<h1 id="十四、equals和hashcode的区别以及联系"><a href="#十四、equals和hashcode的区别以及联系" class="headerlink" title="十四、equals和hashcode的区别以及联系"></a>十四、equals和hashcode的区别以及联系</h1><p>1.equals方法</p>
<p>自反性 ： x.equals(x) 结果应该返回true。</p>
<p>对称性 ： x.equals(y) 结果返回true当且仅当y.equals(x)也应该返回true。</p>
<p>传递性 ： x.equals(y) 返回true，并且y.equals(z) 返回true，那么x.equals(z) 也应该返回true。</p>
<p>一致性 ： x.equals(y)的第一次调用为true，那么x.equals(y)的第二次，第三次等多次调用也应该为true，但是前提条件是在进行比较之前，x和y都没有被修改。</p>
<p>x.equals(null) 应该返回false。</p>
<p>这个方法返回true当且仅当x和y指向了同样的对象(x==y)，这句话也就是说明了在默认情况下，<strong>Object类中的equals方法默认比较的是对象的地址，因为只有是相同的地址才会相等(x == y)，如果没有重写equals方法，那么默认就是比较的是地址。</strong>注意：<strong>无论何时这个equals方法被重写那么都是有必要去重写hashCode方法，这个是因为为了维持hashCode的一种约定，相同的对象必须要有相同的hashCode值。</strong></p>
<p>2.hashcode</p>
<p>在同一次的java程序应用过程中，对应同样的对象多次调用hashCode方法，hashCode方法必须一致性的返回同样的一个地址值，前提是这个对象不能改变</p>
<p>两个对象相同是依据equals方法来的，那么其中的每一个对象调用hashCode方法都必须返回相同的一个integer值，也就是对象的地址。equals方法相等，那么hashCode方法也必须相等。</p>
<p>如果两个对象依据equals方法返回的结果不相等，那么对于其中的每一个对象调用hashCode方法返回的结果也不是一定必须得相等（也就是说，equals方法的结果为false，那么hashCode方法返回的结果可以相同也可以不相同），但是，对于我们开发者来说，针对两个对象的不相等如果生成相同的hashCode则可以提高应用程序的性能。</p>
<p>​         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</p>
<p>​         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
<p>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值 </p>
<p><strong>并不是所有重写equals()的时候都要重写hashCode()，如果不涉及到哈希表的话，就不需要了。</strong></p>
<h1 id="十五：自动装箱与拆箱"><a href="#十五：自动装箱与拆箱" class="headerlink" title="十五：自动装箱与拆箱"></a>十五：自动装箱与拆箱</h1><h2 id="15-1-基本概念"><a href="#15-1-基本概念" class="headerlink" title="15.1 基本概念"></a>15.1 基本概念</h2><p>装箱：将基本类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>如何实现?</p>
<p>拿Integer来举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer integer = <span class="number">10</span>; <span class="comment">//装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = integer; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<p><strong>装箱：主要调用的是Integer的valueOf(int)方法</strong></p>
<p><strong>拆箱：自动调用Integer的intValue方法</strong></p>
<p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</p>
<ol>
<li><p>int 和Integer在进行比较的时候，Integer会进行拆箱，转为int值与int进行比较。</p>
</li>
<li><p><strong>Integer与Integer比较的时候，由于直接赋值的时候会进行自动的装箱，那么这里就需要注意两个问题，一个是-128&lt;= x&lt;=127的整数，将会直接缓存在IntegerCache中，那么当赋值在这个区间的时候，不会创建新的Integer对象，而是从缓存中获取已经创建好的Integer对象。二：当大于这个范围的时候，直接new Integer来创建Integer对象。</strong></p>
</li>
<li><p>new Integer(1) 和Integer a = 1不同，前者会创建对象，存储在堆中，而后者因为在-128到127的范围内，不会创建新的对象，而是从IntegerCache中获取的。那么Integer a = 128, 大于该范围的话才会直接通过new Integer（128）创建对象，进行装箱。</p>
</li>
</ol>
<h2 id="15-2-实战"><a href="#15-2-实战" class="headerlink" title="15.2 实战"></a>15.2 实战</h2><h3 id="15-2-1-示例1"><a href="#15-2-1-示例1" class="headerlink" title="15.2.1 示例1"></a>15.2.1 示例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">100</span>;</span><br><span class="line">        Integer b = <span class="number">100</span>;</span><br><span class="line">        Integer c = <span class="number">200</span>;</span><br><span class="line">        Integer d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果为：</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2-2-示例2"><a href="#15-2-2-示例2" class="headerlink" title="15.2.2 示例2"></a>15.2.2 示例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-01 20:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double a = <span class="number">100.0</span>;</span><br><span class="line">        Double b = <span class="number">100.0</span>;</span><br><span class="line">        Double c = <span class="number">200.0</span>;</span><br><span class="line">        Double d = <span class="number">200.0</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        System.out.println(a == b);</span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<blockquote>
<p>false<br>false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。</p>
<p>很简单：<strong>在某个范围内的整型数值的个数是有限的，而浮点数却不是</strong>。</p>
<p>注意：</p>
<ul>
<li>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">    <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">        <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Double、Float的valueOf方法的实现是类似的。</li>
</ul>
<h1 id="十六、equals和"><a href="#十六、equals和" class="headerlink" title="十六、equals和=="></a>十六、equals和==</h1><p>==：判断两个对象的地址是否相等，基本类型就是判断值是否相等</p>
<p>equals：类没有重写equals方法，等价于==；覆盖的话就是比较两个对象的内容</p>
<h1 id="十七：Java闭包和回调"><a href="#十七：Java闭包和回调" class="headerlink" title="十七：Java闭包和回调"></a>十七：Java闭包和回调</h1><ul>
<li><strong>闭包</strong>是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</li>
<li>是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。</li>
</ul>
<p><strong>闭包</strong>能够将一个<strong>方法</strong>作为一个<strong>变量</strong>去存储，这个方法有能力去访问所在类的<strong>自由变量</strong>。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数，持有上下文数据，作为第一级对象进行传递和保存。闭包广泛用于回调函数、函数式编程中。</p>
<p>在Java中，闭包是 通过“接口与内部类实现的”</p>
<p>闭包（Closure）是一种能被调用的对象，它保存了创建它的作用域的信息。JAVA并不能显式地支持闭包，但是在JAVA中，闭包可以通过“接口+内部类”来实现，因为对于非静态内部类而言，它不仅记录了其外部类的详细信息，还保留了一个创建非静态内部类的引用，通过它可以访问外部类的私有成员，因此可以把非静态内部类当成面向对象领域的闭包。那么，通过这种仿闭包的非静态内部类可以很方便地实现回调，这是一种非常灵活的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-03-13 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>: 测试闭包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClosure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> Food();</span><br><span class="line">        food.getEat().eat();</span><br><span class="line">        food.getNum();</span><br><span class="line"></span><br><span class="line">        Food pub = <span class="keyword">new</span> Food();</span><br><span class="line">        Food.EatActive eatActive = pub.<span class="keyword">new</span> EatActive();</span><br><span class="line">        eatActive.eat();</span><br><span class="line">        pub.getNum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"food"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"my food"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Active <span class="title">getEat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EatActive();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EatActive</span> <span class="keyword">implements</span> <span class="title">Active</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"no"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(<span class="string">"yes"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Active</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包(closure)是一个可调用的对象,它记录了一些信息,这些信息来自于创建它的作用域.</p>
<h1 id="十八、hashCode"><a href="#十八、hashCode" class="headerlink" title="十八、hashCode"></a>十八、hashCode</h1><p>hashCode就是根据存储在一个对象实例中的所有数据，提取出一个<strong>32</strong>位的整数，该整数的目的是用来标示该实例的唯一性，有点类似于MD5码，每个文件都能通过MD5算法生成一个唯一的MD5码。</p>
<h1 id="十九、Math-abs"><a href="#十九、Math-abs" class="headerlink" title="十九、Math.abs"></a>十九、Math.abs</h1><p>Java的API文档中说，对abs(int a)运算，“如果参数等于 Integer.MIN_VALUE 的值(即能够表示的最小负 int 值)，那么结果与该值相同且为负。</p>
<h1 id="二十、static关键字"><a href="#二十、static关键字" class="headerlink" title="二十、static关键字"></a>二十、static关键字</h1><p>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，<strong>它当且仅当在类初次加载时会被初始化</strong>。<strong>而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响</strong>。</p>
<p><strong>static成员变量的初始化顺序按照定义的顺序进行初始化</strong>。</p>
<h1 id="二十一、Collection和Collections的区别"><a href="#二十一、Collection和Collections的区别" class="headerlink" title="二十一、Collection和Collections的区别"></a>二十一、Collection和Collections的区别</h1><p>1、java.util.Collection 是一个<strong>集合接口（集合类的一个顶级接口）</strong>。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>
<p> Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set</p>
<p>2、Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>
<h1 id="二十二、Overload和Override的区别？"><a href="#二十二、Overload和Override的区别？" class="headerlink" title="二十二、Overload和Override的区别？"></a>二十二、Overload和Override的区别？</h1><p> Overload是重载的意思，Override是覆盖的意思，也就是重写。</p>
<p>​    重载Overload：在同一个类中，允许存在一个以上的同名函数，只要他们的参数个数或者参数类型不同即可。</p>
<p>​    重载的特点：与返回值类型无关，只看参数列表。</p>
<p>​    重写Override表示子类中的方法可以与父类中的某个方法的<strong>名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中定义的方法，这相当于把父类中定义的那个完全相同的方法给覆盖掉了，这也是面向对象编程的多态的一种表现。子类覆盖父类方法时只能抛出父类的异常或者异常的子类或者父类异常的子集，因为子类可以解决父类的一些问题，但不能比父类有更多的问题。还有，子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，则子类中根本不存在覆盖，即子类中和父类的private的同名的方法没有覆盖的关系，因为private的访问权限只限于同一类中，而子类就不会访问到private的方法，所以是子类中增加的一个全新的方法。</p>
<p>​    <strong>重载overload的特点就是与返回值无关，只看参数列表，所以重载的方法是可以改变返回值类型的</strong>。所以，如果两个方法的参数列表完全一样，是不能通过让他们的返回值类型不同来实现重载的。我们可以用反证法来说明这个问题，因为我们有时候调用一个方法时也可以不定义返回结果变量，即不要关心其返回结果，例如，我们调用map.remove(key)方法时，虽然remove方法有返回值，但是我们通常都不会定义接收返回结果的变量，这时候假设该类中有两个名称和参数列表完全相同的方法，仅仅是返回类型不同，java就无法确定编程者倒底是想调用哪个方法了，因为它无法通过返回结果类型来判断。</p>
<h1 id="二十三、Java参数是值传递还是引用传递"><a href="#二十三、Java参数是值传递还是引用传递" class="headerlink" title="二十三、Java参数是值传递还是引用传递"></a>二十三、Java参数是值传递还是引用传递</h1><p><strong>值传递</strong></p>
<p><strong>Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</strong></p>
<h1 id="二十四、final关键字对类、方法和成员变量的修饰"><a href="#二十四、final关键字对类、方法和成员变量的修饰" class="headerlink" title="二十四、final关键字对类、方法和成员变量的修饰"></a>二十四、final关键字对类、方法和成员变量的修饰</h1><ol>
<li>final修饰类 </li>
</ol>
<p>被修饰的类不能被继承，也没有子类。假如随意创建这些类的子类，子类可能会错误的修改父类的实现细节、出于安全原因，类的实现细节不允许有任何改动、在创建对象模型的时候，确信这个类不会再被扩展。<strong>注：如果对一个已经被final修饰的类进行继承操作，则会在编译的期间直接出现错误</strong></p>
<ol start="2">
<li>final修饰方法</li>
</ol>
<p>final修饰的方法表示此方法已经是“最后的、最终的”含义，<strong>亦即此方法不能被重写</strong>，（但是可以载多个final修饰的方法）。</p>
<p>需要注意的一点是: 重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法的访问权限是private，将会导致子类不能直接继承到此方法，这时候再在子类中定义相同的方法名和参数，不会产生重写与final之间出现的矛盾，而是在子类中定义了新的方法。</p>
<ol start="3">
<li>final修饰变量</li>
</ol>
<p><strong>final修饰的变量表示此变量是“最后的、最终的”,一旦定义了final变量，并在首次为其显示进行了初始化之后，final修饰的变量值不可被再修改。</strong></p>
<p>final修饰的变量，无论是类属性、对象属性、形参还是局部变量，这些变量都是需要进行显示初始化（即为其显示指定初始值）。</p>
<p><strong>另外，无论对于基本数据类型还是引用数据类型，final修饰的变量都是首次初始化后值都不能修改。对于基本数据类型，很好理解。对于引用数据类型，引用变量指向的是实际的对象，但其存储的是所指向对象的地址，因此，其值不能修改并不意味着其所指向的对象不能修改。</strong> </p>
<h1 id="二十五、整型转字符串"><a href="#二十五、整型转字符串" class="headerlink" title="二十五、整型转字符串"></a>二十五、整型转字符串</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">String string = String.valueOf(i);</span><br><span class="line">String string2 = <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line">String string3 = i.toString();</span><br></pre></td></tr></table></figure>

<h1 id="二十六、Java中的异常"><a href="#二十六、Java中的异常" class="headerlink" title="二十六、Java中的异常"></a>二十六、Java中的异常</h1><p>采用的设计模式是：<strong>责任链模式</strong></p>
<p>Java有两种异常类型：<strong>受检查异常和运行时异常</strong></p>
<p>检查异常：<strong>这些异常从程序的角度来说是必须经过捕捉处理的，否则编译通不过，</strong>比如IOException，SQLException。</p>
<p>运行时异常（不受检查异常）：Error和运行时异常</p>
<p>Error是程序无法处理的，如：OutOfMemmoryError，如果出现Error，Java虚拟机就会终止线程。</p>
<p><strong>运行时异常：如RunTimeException，IndexOutOfBoundsException，NullPointerException，这些异常一般是由程序的逻辑错误引起的，解决此类异常应该仔细排查程序，不需要进行检查。</strong></p>
<p><strong>两者的区别：</strong></p>
<p>非检查异常表示无法让程序恢复运行的异常，导致这种异常的原因通常是由于执行了错误的操作。一旦出现错误，建议让程序终止。</p>
<p><strong>受检查异常表示程序可以处理的异常。如果抛出异常的方法本身不处理或者不能处理它，那么方法的调用者就必须去处理该异常，否则调用会出错，连编译也无法通过。</strong></p>
<p>对于运行异常，建议不要用 try…catch…捕获处理，应该在程序开发调试的过程中尽量的避免，当然有一些必须要处理的，自己知道了那个部分会出现异常，而这种异常你要把它处理的你想要的结果，例如：空值处理。</p>
<p><img src="http://mycsdnblog.work/201919152249-a.png" alt></p>
<p>1.Java中的所有不正常类都继承于Throwable类。Throwable主要包括两个大类，一个是Error类，另一个是Exception类；</p>
<p><img src="http://mycsdnblog.work/201919152250-n.png" alt></p>
<p>2.其中Error类中包括虚拟机错误和线程死锁，一旦Error出现了，程序就彻底的挂了，被称为程序终结者；</p>
<p><img src="http://mycsdnblog.work/201919152250-9.png" alt></p>
<p>3.Exception类，也就是通常所说的“异常”。主要指编码、环境、用户操作输入出现问题，Exception主要包括两大类，非检查异常（RuntimeException）和检查异常（其他的一些异常）</p>
<p><img src="http://mycsdnblog.work/201919152251-y.png" alt></p>
<p>4.RuntimeException异常主要包括以下四种异常（其实还有很多其他异常，这里不一一列出）：空指针异常、数组下标越界异常、类型转换异常、算术异常。RuntimeException异常会由java虚拟机自动抛出并自动捕获<strong>（就算我们没写异常捕获语句运行时也会抛出错误！！）</strong>，此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。</p>
<p><img src="http://mycsdnblog.work/201919152252-T.png" alt></p>
<p>5.检查异常，引起该异常的原因多种多样，比如说文件不存在、或者是连接错误等等。跟它的“兄弟”RuntimeException运行异常不同，<strong>该异常我们必须手动在代码里添加捕获语句来处理该异常</strong>，这也是我们学习java异常语句中主要处理的异常对象。</p>
<p><img src="http://mycsdnblog.work/201919152253-t.png" alt></p>
<h1 id="二十七、Enum"><a href="#二十七、Enum" class="headerlink" title="二十七、Enum"></a>二十七、Enum</h1><h3 id="27-1-什么是Enum"><a href="#27-1-什么是Enum" class="headerlink" title="27.1 什么是Enum"></a>27.1 什么是Enum</h3><p>Enum是一个Java的关键字，用于表示一个固定的常用值。例如，每周的天数，每年的月数等。Enum是一种类型，就像Class和Interface可以用于定义一系列的Enum常量</p>
<h3 id="27-2-Enum的特性"><a href="#27-2-Enum的特性" class="headerlink" title="27.2 Enum的特性"></a>27.2 Enum的特性</h3><ul>
<li>Enum常量隐式的加上了static和final，一旦被创建就无法修改</li>
<li>Enum提供了是类型安全的(type-safe)</li>
<li>Enum隐式的加上了values()方法，返回一个数组包含所有的Enum常量</li>
<li>两个Enum常量可以使用 <code>==</code>或<code>equals()</code>方法比较</li>
<li>Enum可以用在switch语句中，就像int，String。</li>
<li>Enum有自己的名称空间</li>
<li>Enum可以实现Java接口</li>
<li>可以在Enum中定义构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.design.pattern.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-04-26 20:42</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">todo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="27-3-Enum面试问题"><a href="#27-3-Enum面试问题" class="headerlink" title="27.3 Enum面试问题"></a>27.3 Enum面试问题</h3><ol>
<li>说说Enum的继承<br>所有的enums隐式的extend了java.lang.Enum类，因为一个类只能extend一个父亲，所以enum不能extend其它的类。但是Enum可以实现许多接口</li>
<li>Enum的values,ordinal,valueOf方法<br>enums默认有values()，ordinal()和valueOf()方法。<br>values()方法返回所有在enum中定义的常量值，以数组形式返回。<br>ordinal()方法返回每个常量的索引下标，就像数组的下标<br>valueOf()方法传入字符串参数，如果enum中存在对应字符串的常量值，则返回对应的enum常量</li>
</ol>
<h1 id="二十八、Java数组复制的方法"><a href="#二十八、Java数组复制的方法" class="headerlink" title="二十八、Java数组复制的方法"></a>二十八、Java数组复制的方法</h1><h2 id="28-1-for循环"><a href="#28-1-for循环" class="headerlink" title="28.1 for循环"></a>28.1 for循环</h2><p>代码灵活，效率低</p>
<h2 id="28-2-System-arraycopy-方法"><a href="#28-2-System-arraycopy-方法" class="headerlink" title="28.2 System.arraycopy()方法"></a>28.2 System.arraycopy()方法</h2><p>通过源码可以看到，其为native方法，即原生态方法。自然效率更高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* <span class="meta">@param</span>      src      the source array.</span><br><span class="line">* <span class="meta">@param</span>      srcPos   starting position in the source array.</span><br><span class="line">* <span class="meta">@param</span>      dest     the destination array.</span><br><span class="line">* <span class="meta">@param</span>      destPos  starting position in the destination data.</span><br><span class="line">* <span class="meta">@param</span>      length   the number of array elements to be copied.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="28-3-Arrays-copyOf"><a href="#28-3-Arrays-copyOf" class="headerlink" title="28.3 Arrays.copyOf()"></a>28.3 Arrays.copyOf()</h2><p>实现还是基于System.arraycopy()，所以效率自然低于System.arraycpoy()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyOf(<span class="keyword">int</span>[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[newLength];</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-4-Object-clone"><a href="#28-4-Object-clone" class="headerlink" title="28.4 Object.clone()"></a>28.4 Object.clone()</h2><p>从源码来看同样也是native方法，但返回为Object类型，所以赋值时将发生强转，所以效率不如之前两种。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<h1 id="二十九、Java中的泛型"><a href="#二十九、Java中的泛型" class="headerlink" title="二十九、Java中的泛型"></a>二十九、Java中的泛型</h1><h1 id="三十、Java中的迭代器"><a href="#三十、Java中的迭代器" class="headerlink" title="三十、Java中的迭代器"></a>三十、Java中的迭代器</h1><p>迭代器模式：就是提供一种方法对一个容器对象中的各个元素进行访问，而又不暴露该对象容器的内部细节。</p>
<p>Iterator遍历时不可以删除集合中的元素问题</p>
<h1 id="三十一、Java中的内部类作用"><a href="#三十一、Java中的内部类作用" class="headerlink" title="三十一、Java中的内部类作用"></a>三十一、Java中的内部类作用</h1><p><strong>1.内部类可以很好的实现隐藏</strong></p>
<p> <strong>一般的非内部类，是不允许有 private 与protected权限的，但内部类可以</strong></p>
<p><strong>2.内部类拥有外围类的所有元素的访问权限</strong></p>
<p><strong>3.可实现多重继承</strong></p>
<p><strong>4.可以避免修改接口而实现同一个类中两种同名方法的调用。</strong></p>
<p>如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类了。</p>
<h1 id="三十二、如何解析JSON"><a href="#三十二、如何解析JSON" class="headerlink" title="三十二、如何解析JSON"></a>三十二、如何解析JSON</h1><h1 id="三十三、不用中间变量交换两个数"><a href="#三十三、不用中间变量交换两个数" class="headerlink" title="三十三、不用中间变量交换两个数"></a>三十三、不用中间变量交换两个数</h1><p>a=a+b b=a-b a=a-b</p>
<p>a= a ^ b b = a ^ b a = a ^ b</p>
<h1 id="三十四、Java中对象的大小"><a href="#三十四、Java中对象的大小" class="headerlink" title="三十四、Java中对象的大小"></a>三十四、Java中对象的大小</h1><h2 id="34-1-Java对象结构"><a href="#34-1-Java对象结构" class="headerlink" title="34.1 Java对象结构"></a>34.1 Java对象结构</h2><p><img src="http://mycsdnblog.work/201919111010-0.png" alt></p>
<ol>
<li>Mark Word：存储对象运行时记录信息（<strong>存储对象的HashCode、分代年龄和锁标记位</strong>），占用内存大小与机器位数一样，即<strong>32位机占4字节，64位机占8字节</strong></li>
<li>元数据指针：指向描述类型的Klass对象（Java类的C++对等体）的指针，Klass对象包含了实例对象所属类型的元数据，因此该字段被称为元数据指针，JVM在运行时将频繁使用这个指针定位到位于方法区内的类型信息。<strong>占用内存大小与机器位数一样</strong>。</li>
<li>数组长度：数组对象特有，4个字节</li>
<li>实例数据：实例数据就是8大基本数据类型byte、short、int、long、float、double、char、boolean（对象类型也是由这8大基本数据类型复合而成），每种数据类型占多少字节就不一一例举了</li>
<li>填充：不定，<strong>HotSpot的对齐方式为8字节对齐，即一个对象必须为8字节的整数倍</strong>，因此如果最后前面的数据大小为17则填充7，前面的数据大小为18则填充6，以此类推</li>
</ol>
<p>为了保证效率，Java编译期在编译Java对象的时候，通过字段类型对Java对象的字段会进行排序，具体顺序如下表所示：</p>
<p><img src="http://mycsdnblog.work/201919111012-s.png" alt></p>
<p>元数据指针的大小。元数据指针是一个引用类型，因此正常来说64位机元数据指针应当为8字节，32位机元数据指针应当为4字节，<strong>但是HotSpot中有一项优化是对元数据类型指针进行压缩存储</strong>，使用JVM参数：</p>
<ul>
<li>-XX:+UseCompressedOops开启压缩</li>
<li>-XX:-UseCompressedOops关闭压缩</li>
</ul>
<p>HotSpot默认是前者，即开启元数据指针压缩，当开启压缩的时候，64位机上的元数据指针将占据4个字节的大小。换句话说就是<strong>当开启压缩的时候，64位机上的引用将占据4个字节，否则是正常的8字节</strong>。</p>
<h2 id="34-2-Java对象内存大小计算"><a href="#34-2-Java对象内存大小计算" class="headerlink" title="34.2 Java对象内存大小计算"></a>34.2 Java对象内存大小计算</h2><p>首先是Object对象的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 = 12字节，由于12字节不是8的倍数，因此填充4字节，对象Object占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，对象Object占据16字节内存</li>
</ol>
<p>接着是字符’a’的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 2字节char = 14字节，由于14字节不是8的倍数，因此填充2字节，字符’a’占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，字符’a’占据24字节内存</li>
</ol>
<p>接着是整型1的大小：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节int = 16字节，由于16字节正好是8的倍数，因此不需要填充字节，整型1占据16字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 4字节int = 20字节，由于20字节正好是8的倍数，因此填充4字节，整型1占据24字节内存</li>
</ol>
<p>接着是字符串”aaaaa”的大小，所有静态字段不需要管，只关注实例字段，String对象中实例字段有”char value[]”与”int hash”，由此可知：</p>
<ol>
<li>开启指针压缩时，8字节Mark Word + 4字节元数据指针 + 4字节引用 + 4字节int = 20字节，由于20字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据24字节内存</li>
<li>关闭指针压缩时，8字节Mark Word + 8字节元数据指针 + 8字节引用 + 4字节int = 28字节，由于28字节不是8的倍数，因此填充4字节，字符串”aaaaa”占据32字节内存</li>
</ol>
<p>最后是长度为1的char型数组的大小：</p>
<ol>
<li>开启指针压缩时，8字节的Mark Word + 4字节的元数据指针 + 4字节的数组大小引用 + 2字节char = 18字节，由于18字节不是8的倍数，因此填充6字节，长度为1的char型数组占据24字节内存</li>
<li>关闭指针压缩时，8字节的Mark Word + 8字节的元数据指针 + 8字节的数组大小引用 + 2字节char = 26字节，由于26字节不是8的倍数，因此填充6字节，长度为1的char型数组占据32字节内存</li>
</ol>
<h1 id="三十五、Class-forName-和ClassLoader-loadClass的区别"><a href="#三十五、Class-forName-和ClassLoader-loadClass的区别" class="headerlink" title="三十五、Class.forName()和ClassLoader.loadClass的区别"></a>三十五、Class.forName()和ClassLoader.loadClass的区别</h1><h2 id="35-1-Java类的装载过程"><a href="#35-1-Java类的装载过程" class="headerlink" title="35.1 Java类的装载过程"></a>35.1 Java类的装载过程</h2><p><img src="http://mycsdnblog.work/201919160937-r.png" alt></p>
<p>1.装载：通过类的全限定名获取二进制字节流，将二进制字节流转换成方法区中的运行时数据结构，在内存中生成Java.lang.class对象； </p>
<p>2.链接：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； </p>
<ul>
<li>校验：检查导入类或接口的二进制数据的正确性；（文件格式验证，元数据验证，字节码验证，符号引用验证） </li>
<li>准备：给类的静态变量分配并初始化存储空间； </li>
<li>解析：将常量池中的符号引用转成直接引用； </li>
</ul>
<p>3.初始化：激活类的静态变量的初始化Java代码和静态Java代码块，并初始化程序员设置的变量值。</p>
<h2 id="35-2-Class-forName-和ClassLoader-loadClass"><a href="#35-2-Class-forName-和ClassLoader-loadClass" class="headerlink" title="35.2 Class.forName()和ClassLoader.loadClass"></a>35.2 <strong>Class.forName()和ClassLoader.loadClass</strong></h2><p>Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);</p>
<p>第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。</p>
<p>一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。</p>
<p>ClassLoader.getSystemClassLoader().loadClass(className)方法，内部实际调用的方法是  ClassLoader.getSystemClassLoader().loadClass(className,false);</p>
<p>第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，</p>
<p>不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</p>
<h2 id="35-3-为什么数据库连接要使用Class-forName-className"><a href="#35-3-为什么数据库连接要使用Class-forName-className" class="headerlink" title="35.3 为什么数据库连接要使用Class.forName(className)"></a>35.3 为什么数据库连接要使用Class.forName(className)</h2><p>JDBC  Driver源码如下,因此使用Class.forName(classname)才能在反射回去类的时候执行static块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-4-Class-forName，Class-class，getClass-的区别"><a href="#35-4-Class-forName，Class-class，getClass-的区别" class="headerlink" title="35.4 Class.forName，Class.class，getClass()的区别"></a>35.4 Class.forName，Class.class，getClass()的区别</h2><p>Class.forName：会触发静态初始化</p>
<p>Class.class：将类装载进JVM中，不做初始化工作</p>
<p>getClass()：对类进行静态和非静态初始化</p>
<h1 id="三十六、序列化版本号serialVersionUID的作用"><a href="#三十六、序列化版本号serialVersionUID的作用" class="headerlink" title="三十六、序列化版本号serialVersionUID的作用"></a>三十六、序列化版本号serialVersionUID的作用</h1><p>Java中序列化，实现Serializable接口</p>
<p>serialVersionUID的主要作用有以下两个：</p>
<p>1、能够成功反序列化</p>
<p>2、版本控制</p>
<ul>
<li>在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 </li>
<li>当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置serialVersionUID，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。 </li>
</ul>
<h1 id="三十七、MVC和MVVM"><a href="#三十七、MVC和MVVM" class="headerlink" title="三十七、MVC和MVVM"></a>三十七、MVC和MVVM</h1><p>MVC，Model View Controller，是软件架构中最常见的一种框架，简单来说就是通过controller的控制去操作model层的数据，并且返回给view层展示。</p>
<p><img src="http://mycsdnblog.work/201919041924-a.png" alt></p>
<h1 id="三十八、Java中char可以表示一个汉字吗？"><a href="#三十八、Java中char可以表示一个汉字吗？" class="headerlink" title="三十八、Java中char可以表示一个汉字吗？"></a>三十八、Java中char可以表示一个汉字吗？</h1><p>在uft8编码下占三个字节；<br><strong>在GBK编码下占2个字节；</strong><br>但是如果 char表示英文字母：<br>在uft8编码下占一个字节；<br><strong>在GBK编码下还是占2个字节；</strong> </p>
<p><strong>所以char类型的值不管是英文还是中文都是统一两个字节！</strong> </p>
<h1 id="三十九、Java对象的生命周期"><a href="#三十九、Java对象的生命周期" class="headerlink" title="三十九、Java对象的生命周期"></a>三十九、Java对象的生命周期</h1><p>在Java中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li><p>创建阶段(Created)</p>
</li>
<li><p>应用阶段(In Use)</p>
</li>
<li><p>不可见阶段(Invisible)</p>
<p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。</p>
</li>
<li><p>不可达阶段(Unreachable)</p>
<p>对象处于不可达阶段是指该对象不再被任何强引用所持有</p>
<p>与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。</p>
</li>
<li><p>收集阶段(Collected)</p>
<p>当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。</p>
</li>
<li><p>终结阶段(Finalized)</p>
<p>当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。</p>
</li>
<li><p>对象空间重分配阶段(De-allocated)</p>
<p>垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。</p>
</li>
</ol>
<h1 id="四十、理解Java中的各种O"><a href="#四十、理解Java中的各种O" class="headerlink" title="四十、理解Java中的各种O"></a>四十、理解Java中的各种O</h1><p><strong>1、PO(persistant object) 持久对象</strong> </p>
<p>对应于DAO层中操作的对象</p>
<ul>
<li>有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录，多个记录可以用PO的集合。</li>
<li>在o/r 映射的时候出现的概念,如果没有o/r映射,就没有这个概念存在了。</li>
<li>PO中应该不包含任何对数据库的操作。</li>
</ul>
<p><strong>2、VO(value object) 值对象</strong> </p>
<p>对应View层，用于显示的Java Bean</p>
<ul>
<li><p>主要对应页面显示（web页面(jsp…)/swt、swing界面）的数据对象，所以它可以和表对应，也可以不（大部分情况是表所有字段集合的子集），这根据业务的需要。</p>
</li>
<li><p>与DTO的区别是：DTO用于无界面的web service传输中而VO用于界面的展示，可以把DTO转化为VO提供给前台。</p>
</li>
</ul>
<p><strong>3、DTO(Data Transfer Object)，数据传输对象</strong> </p>
<p>在应用程序不同tie(关系)之间传输的对象 </p>
<p>对应Controller层中，接收和返回的Java Bean。</p>
<ul>
<li>用在需要跨进程或远程传输时，它不应该包含业务逻辑。</li>
<li>比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。</li>
</ul>
<p><strong>4、BO(business object) 业务对象</strong> </p>
<p>对应Service中的Java Bean </p>
<ul>
<li><p>从业务模型的角度看,见UML元件领域模型中的领域对象.封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。</p>
</li>
<li><p>根据业务逻辑，将封装业务逻辑为一个对象，可以包括多个PO，通常需要将BO转化成PO，才能进行数据的持久化，反之，从DB中得到的PO，需要转化成BO才能在业务层使用。</p>
</li>
</ul>
<p>关于BO主要有三种概念</p>
<ul>
<li>只包含业务对象的属性</li>
<li>只包含业务方法</li>
<li>两者都包含</li>
</ul>
<p>在实际使用中，认为哪一种概念正确并不重要，关键是实际应用中适合自己项目的需要。</p>
<p><strong>5、DAO(data access object) 数据访问对象</strong><br>是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO,<br>提供数据库的CRUD操作…   </p>
<p><strong>6、POJO(plain ordinary java object) 简单无规则java对象</strong><br>纯的传统意义的java对象。就是说在一些Object/Relation<br>Mapping工具中，能够做到维护数据库表记录的persisent<br>object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java<br>Bean，只有属性字段及setter和getter方法！。 </p>
<p><img src="http://mycsdnblog.work/201919161441-u.png" alt></p>
<h1 id="四十一、Spring-Boot中的classpath"><a href="#四十一、Spring-Boot中的classpath" class="headerlink" title="四十一、Spring Boot中的classpath"></a>四十一、Spring Boot中的classpath</h1><p>springboot项目创建完成后，会生成该项目名称+iml后缀的文件。该文件位于项目的根目录下。<br>打开后，在name=”NewModuleRootManager”的component声明中，会有几个默认content声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/java"</span> <span class="attr">isTestSource</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/main/resources"</span> <span class="attr">type</span>=<span class="string">"java-resource"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">sourceFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/src/test/java"</span> <span class="attr">isTestSource</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">excludeFolder</span> <span class="attr">url</span>=<span class="string">"file://$MODULE_DIR$/target"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中sourceFolder 中声明的就是classpath，只是类型不同。对应的工程文件目录：</p>
<p><img src="http://mycsdnblog.work/201919171559-E.png" alt></p>
<p>其中蓝色的java目录：保存项目的java文件。<br> resources是项目的资源目录，里面通常包含static与templates目录<br> 绿色的test/java目录是编写的测试类的目录。</p>
<ul>
<li>工程编译后，会将src/main/java中的.java文件按照包文件结构编译成.class存入target/classes目录。</li>
<li>工程编译后，会将src/main/resources中的static、templates目录里的文件分别拷贝入classes/static 与classes/template 中。结构保持一致。</li>
<li>工程编译后，会将test/java 中的文件编译进classes/test-classes目录中。</li>
</ul>
<p><strong>可以根据项目需要，修改.iml文件的content，来添加不同的资源路径。</strong></p>
<h1 id="四十二、静态内部类的和普通内部类的区别"><a href="#四十二、静态内部类的和普通内部类的区别" class="headerlink" title="四十二、静态内部类的和普通内部类的区别"></a>四十二、静态内部类的和普通内部类的区别</h1><p>定义在一个类内部的类叫内部类，包含内部类的类称为外部类。内部类可以声明public、protected、private等访问限制，可以声明 为abstract的供其他内部类或外部类继承与扩展，或者声明为static、final的，也可以实现特定的接口。外部类按常规的类访问方式使用内部类，唯一的差别是<strong>外部类可以访问内部类的所有方法与属性，包括私有方法与属性</strong>。</p>
<h2 id="42-1-创建实例"><a href="#42-1-创建实例" class="headerlink" title="42.1 创建实例"></a>42.1 创建实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutClass.InnerClass innerClass = OutClass.getInstance().<span class="keyword">new</span> InnerClass();</span><br><span class="line"></span><br><span class="line">        OutClass.StaticInnerClass staticInnerClass = <span class="keyword">new</span> OutClass.StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-2-内部类中的this"><a href="#42-2-内部类中的this" class="headerlink" title="42.2 内部类中的this"></a>42.2 内部类中的this</h2><p> 内部类中的this与其他类一样是指的本身。创建内部类对象时，它会与创造它的外围对象有了某种联系，于是能访问外围类的所有成员，不需任何特殊条件，可理 解为内部类链接到外部类。 用外部类创建内部类对象时，此内部类对象会秘密的捕获一个指向外部类的引用，于是，可以通过这个引用来访问外围类的成员。</p>
<h2 id="42-3-外部类访问内部类"><a href="#42-3-外部类访问内部类" class="headerlink" title="42.3 外部类访问内部类"></a>42.3 外部类访问内部类</h2><p>内部类类似外部类的属性，因此访问内部类对象时总是需要一个创建好的外部类对象。内部类对象通过‘外部类名.this.xxx’的形式访问外部类的属性与方法。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 98050</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Time</span>: 2019-07-25 21:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Feature</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OutClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> OutClass instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> OutClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OutClass<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> OutClass();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        InnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"内部类初始化"</span>);</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        StaticInnerClass()&#123;</span><br><span class="line">            System.out.println(<span class="string">"静态内部类初始化"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-4-内部类向上转型"><a href="#42-4-内部类向上转型" class="headerlink" title="42.4 内部类向上转型"></a>42.4 内部类向上转型</h2><p>内部类也可以和普通类一样拥有向上转型的特性。将内部类向上转型为基类型，尤其是接口时，内部类就有了用武之地。如果内部类是private的，只可以被它的外部类访问，从而完全隐藏实现的细节。</p>
<h2 id="42-5-方法内的类"><a href="#42-5-方法内的类" class="headerlink" title="42.5 方法内的类"></a>42.5 方法内的类</h2><p>方法内创建的类（注意方法中也能定义类），不能加访问修饰符。另外，方法内部的类也不是在调用方法时才会创建的，它们一样也被事先编译了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MethodInnerClass</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-6-静态内部类"><a href="#42-6-静态内部类" class="headerlink" title="42.6 静态内部类"></a>42.6 静态内部类</h2><p>定义静态内部类：在定义内部类的时候，可以在其前面加上一个权限修饰符static。此时这个内部类就变为了静态内部类。</p>
<p>通常称为<strong>嵌套类</strong>，当内部类是static时，意味着：</p>
<p>   [1]<strong>要创建嵌套类的对象，并不需要其外围类的对象</strong>；</p>
<p>   [2]<strong>不能从嵌套类的对象中访问非静态的外围类对象</strong>（不能够从静态内部类的对象中访问外部类的非静态成员）；</p>
<p>嵌套类与普通的内部类还有一个区别：普通内部类的字段与方法，只能放在类的外部层次上，<strong>所以普通的内部类不能有static数据和static字段</strong>， 也不能包含嵌套类。但是在嵌套类里可以包含所有这些东西。<strong>也就是说，在非静态内部类中不可以声明静态成员，只有将某个内部类修饰为静态类，然后才能够在这 个类中定义静态的成员变量与成员方法。</strong></p>
<p>另外，在创建静态内部类时不需要将静态内部类的实例绑定在外部类的实例上。普通非静态内部类的 对象是依附在外部类对象之中的，要在一个外部类中定义一个静态的内部类，不需要利用关键字new来创建内部类的实例。静态类和方法只属于类本身，并不属于 该类的对象，更不属于其他外部类的对象。</p>
<h2 id="42-7-内部类标识符"><a href="#42-7-内部类标识符" class="headerlink" title="42.7 内部类标识符"></a>42.7 内部类标识符</h2><p>每个类会产生一个.class文件，文件名即为类名。同样，内部类也会产生这么一个.class文件，但是它的名称却不是内部类的类名，而是有着严格的限制：<strong>外围类的名字，加上$,再加上内部类名字</strong>。</p>
<h2 id="42-8-为什么使用内部类"><a href="#42-8-为什么使用内部类" class="headerlink" title="42.8 为什么使用内部类"></a>42.8 为什么使用内部类</h2><p><strong>内部类一般只为其外部类使用；</strong></p>
<p><strong>内部类提供了某种进入外部类的窗户；</strong></p>
<p><strong>也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。</strong></p>
<h1 id="四十三、接口的幂等性"><a href="#四十三、接口的幂等性" class="headerlink" title="四十三、接口的幂等性"></a>四十三、接口的幂等性</h1><p>同步锁</p>
<p>分布式锁</p>
<p>业务字段加唯一约束</p>
<p>令牌表+唯一约束</p>
<p>mysql的insert ignore或者on duplicate key update</p>
<p>共享锁+普通索引</p>
<p>利用MQ或者Redis扩展</p>
<p>使用redis去重</p>
<h1 id="四十四、Java自动类型转换"><a href="#四十四、Java自动类型转换" class="headerlink" title="四十四、Java自动类型转换"></a>四十四、Java自动类型转换</h1><p><img src="http://mycsdnblog.work/201919011617-G.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github+Node搭建个人博客</title>
    <url>/2020/02/17/Hexo+Github+Node%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<hr>
<h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>Hexo：    <a href="http://hexo.io" target="_blank" rel="noopener">http://hexo.io</a><br>Github:     <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a><br>Next：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>  </p>
<h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><blockquote>
<p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。<br>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，将前者称为站点配置文件， 后者称为主题配置文件。<br>注：修改站点配置文件后需重启网站，修改主题配置文件后直接刷新网页即可<br>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p>
</blockquote>
<h3 id="Hexo-GitHub搭建网站原理"><a href="#Hexo-GitHub搭建网站原理" class="headerlink" title="Hexo+GitHub搭建网站原理"></a>Hexo+GitHub搭建网站原理</h3><blockquote>
<p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
</blockquote>
<h3 id="基础Cmd命令"><a href="#基础Cmd命令" class="headerlink" title="基础Cmd命令"></a>基础Cmd命令</h3><p>cmd进入D:\blog目录<br>window+R进入cmd命令窗口，默认进去是C:user\zwb<br>进入D:\blog目录，此时需进入D盘，输入命令D:<br>输入命令cd D:\blog  （错误命令：直接输入cd D:blog）</p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo基于Node.js，Node.js下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> （安装Node.js会自动包含环境变量及npm的安装）<br>检测Node.js是否安装成功，在命令行中输入 node -v :<br>检测npm是否安装成功，在命令行中输入npm -v :  </p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>参考原文：<a href="https://blog.csdn.net/WX_JIN/article/details/51027783" target="_blank" rel="noopener">https://blog.csdn.net/WX_JIN/article/details/51027783</a><br>参考原文：<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a>  </p>
<p>在D盘新建文件夹D:\Blog，打开Cmd命令行，进入该文件夹<br>输入npm命令安装Hexo：npm install -g hexo-cli<br>左上角显示npm，表示在调用npm程序，npm命令未执行完，需耐心等待<br>输入命令初始化博客：hexo init blog<br>左上角显示hexo，表示在调用hexo程序，hexo命令未执行完，需耐心等待<br>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：  </p>
<h4 id="HEXO常用命令"><a href="#HEXO常用命令" class="headerlink" title="HEXO常用命令"></a>HEXO常用命令</h4><p>hexo server #Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s #静态模式<br>hexo server -p 5000 #更改端口<br>hexo server -i 192.168.1.1 #自定义 IP<br>hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令 </p>
<p>在本地查看效果<br>命令执行完后，D:\Blog下会出现Blog子目录，进入D:\Blog\blog目录，输入以下命令在本地查看效果<br>hexo g == hexo generate #生成<br>hexo s == hexo server #启动服务预览<br>浏览器输入地址访问：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a><br>也可以输入1条命令：hexo clean &amp;&amp; hexo g  &amp;&amp; hexo d   </p>
<h3 id="部署到远程GitHub"><a href="#部署到远程GitHub" class="headerlink" title="部署到远程GitHub"></a>部署到远程GitHub</h3><p>申请GitHub账号，下载Git客户端，配置SSH<br>安装部署插件插件：    npm install hexo-deployer-git –save<br>部署你本地的主题到github上 ，代码如下，每次修改本地主题，都需要执行以下代码<br>hexo g == hexo generate     #生成<br>hexo s == hexo server        #启动服务预览<br>hexo d == hexo deploy        #部署  </p>
<h4 id="更换为Next主题"><a href="#更换为Next主题" class="headerlink" title="更换为Next主题"></a>更换为Next主题</h4><p>参考原文：<a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a><br><a href="https://blog.csdn.net/qsdsn/article/details/77946677" target="_blank" rel="noopener">https://blog.csdn.net/qsdsn/article/details/77946677</a></p>
<h3 id="Next主题网站案例"><a href="#Next主题网站案例" class="headerlink" title="Next主题网站案例"></a>Next主题网站案例</h3><p>yilia主题：    <a href="www.lookk.cn/">www.lookk.cn/</a><br>next主题:        <a href="https://wolzq.com/" target="_blank" rel="noopener">https://wolzq.com/</a>  </p>
<h3 id="Next主题下载"><a href="#Next主题下载" class="headerlink" title="Next主题下载"></a>Next主题下载</h3><p>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>  themes/next（中间有个空格，指定下载到theme/next目录下）<br>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia </p>
<h3 id="Next主题配置入坑指南"><a href="#Next主题配置入坑指南" class="headerlink" title="Next主题配置入坑指南"></a>Next主题配置入坑指南</h3><p>入坑：FATAL can not read a block mapping entry<br>解决：_config.yml文件中配置格式为属性名+英文冒号+英文空格+属性值，我主题配置项少写了空格导致</p>
<p>入坑：”欢迎您扫一扫上面的微信公众号，订阅我的博客!“显示为中文乱码<br>解决：主题配置文件_config.yml原来的编码为ANSI，不支持中文，只需将配置文件_config.yml保存为UTF-8编码格式。  </p>
<h3 id="Next个性化设置"><a href="#Next个性化设置" class="headerlink" title="Next个性化设置"></a>Next个性化设置</h3><h4 id="GitHub图标"><a href="#GitHub图标" class="headerlink" title="GitHub图标"></a>GitHub图标</h4><p>右上角GitHub图标1：     <a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">http://tholman.com/github-corners/</a><br>右上角GitHub图标2：     <a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">https://github.blog/2008-12-19-github-ribbons/</a><br>挑选自己喜欢的样式复制代码，然后粘贴到themes/next/layout/_layout.swig文件中(放在<div class="headband"></div>的下面)</p>
<p>注意：  </p>
<ol>
<li>记得修改href为自己的github地址</li>
<li>可以在style样式自定义GitHub图标显示的位置</li>
</ol>
<h4 id="字数统计和阅读时长"><a href="#字数统计和阅读时长" class="headerlink" title="字数统计和阅读时长"></a>字数统计和阅读时长</h4><p> 安装字数统计插件：    npm i –save hexo-wordcount<br> 主题配置文件 _config.yml 中打开 wordcount 统计功能<br>打开/themes/next/layout/_macro/post.swig文件，进行如下修改</p>
]]></content>
  </entry>
  <entry>
    <title>Linux命令入门</title>
    <url>/2020/02/17/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>参考原文：<a href="https://man.linuxde.net/" target="_blank" rel="noopener">https://man.linuxde.net/</a><br>参考原文：<a href="https://www.linuxcool.com/" target="_blank" rel="noopener">https://www.linuxcool.com/</a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>格式：命令名称 [命令参数] [命令对象]，  命令参数可以使用长格式或短格式， 两者分别用–与-作为前缀。<br>长格式    man –help<br>短格式     man -h<br>Ctrl + C：终止命令执行<br>在命令末尾添加上一个&amp;符号，命令将进入系统后台来执行，不在屏幕上输出信息</p>
<h3 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a>上传和下载</h3><p>wget：用来从指定的URL下载文件<br>实例： wget  <a href="http://www.linuxde.net/testfile.zip" target="_blank" rel="noopener">http://www.linuxde.net/testfile.zip</a></p>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><ul>
<li>pwd：    显示当前目录  </li>
<li>cd：    进入指定目录   </li>
<li>ls：       显示当前目录文件  </li>
<li>mkdir：    创建目录或者文件  </li>
</ul>
<h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p>打包：把多个目录或文件变为一个文件（打包前后文件大小不变）<br>压缩：将一个大的文件通过一些压缩算法变成一个小文件。（压缩后文件变小）<br>tar  -x 解压缩  -c 创建新文件<br>压　缩：tar -jcv -f filename.tar.bz2  要被压缩的文件或目录名称<br>查　询：tar -jtv -f filename.tar.bz2<br>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录  </p>
<h3 id="字符和文件查找"><a href="#字符和文件查找" class="headerlink" title="字符和文件查找"></a>字符和文件查找</h3><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）<br>gerp：一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来<br>实例：ps -a  mysqld | gerp  </p>
<p>find：文件搜索工具，在指定目录下搜索文件<br>find /home -name “*.txt”     在/home目录下查找以.txt结尾的文件名  </p>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>w：    显示已经登陆系统的用户列表，并显示用户正在执行的指令<br>last：显示最近登录用户信息<br>su：    切换为其他用户，eg：su -test            // 切换为test用户<br>useradd：新增用户 ， eg：useradd zwb      // 新增zwb用户<br>sudo：以其他用户身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户</p>
<p>操作系统就好比一个网站，登录用户就好比网站的用户，网站有多个用户，类似地，操作系统也有多个用户，不同用户权限不同<br>多个用户可以同时登录同一网站，类似地，可以有多个用户同时登录操作系统</p>
<p>Linux 系统中用户信息存放在 /etc/passwd 文件中。<br>/etc/passwd 文件将每个用户的基本信息记录为文件中的一行，包括用户名，密码，用户ID，群组ID<br>系统中新建一个用户，新用户的详细信息就会被添加到这个文件中<br>用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码</p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>service：启动、停止、重新启动和关闭系统服务，显示所有系统服务的当前状态<br>格式：service  服务名  ，服务名：自动要控制的服务名，即/etc/init.d目录下的脚本文件名<br>service mysqld start   开启服务<br>service mysqld stop     关闭服务<br>service mysqld restart  重启服务<br>service mysqld status  查看服务运行状态<br>ps：用于报告当前系统的进程状态  </p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器环境搭建</title>
    <url>/2020/02/17/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>公网IP：        115.29.141.226<br>内网IP：        172.31.162.137<br>实例ID：        i-m5eikb8hczg76dr9g645<br>实例名称：    ZWB999WF  </p>
<h3 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h3><p>Xshell：      <a href="https://xshell.en.softonic.com/" target="_blank" rel="noopener">https://xshell.en.softonic.com/</a><br>Xftp：      <a href="https://www.netsarang.com/zh/all-downloads/" target="_blank" rel="noopener">https://www.netsarang.com/zh/all-downloads/</a><br>JDK：      <a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html</a><br>MySQL：  <a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/5.6.html#downloads</a><br>Tomcat：      <a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a>  </p>
<h3 id="下载JDK和MySQL的账号和密码"><a href="#下载JDK和MySQL的账号和密码" class="headerlink" title="下载JDK和MySQL的账号和密码"></a>下载JDK和MySQL的账号和密码</h3><p>账号：<a href="mailto:liwei@xiaostudy.com">liwei@xiaostudy.com</a><br>密码：OracleTest1234  </p>
<h3 id="（一）连接阿里云服务器"><a href="#（一）连接阿里云服务器" class="headerlink" title="（一）连接阿里云服务器"></a>（一）连接阿里云服务器</h3><ol>
<li>网页上的workbench连接</li>
<li>网页上的VNC连接</li>
<li>网页上的云命令cloud shell连接</li>
<li>第三方工具连接，如Xshell，Xftp，Putty等，本人采用的是第三方工具连接  </li>
</ol>
<p>Xshell结合Xftp访问云服务器<br>使用Xshell访问Linux系统的时候，经常需要上传和下载文件，文件传输软件Xftp可以和Xshell很好的结合在一起使用。我们在操作Linux服务器的时候都是先使用Xshell的，然后遇到需要上传或下载文件的时候，再打开Xftp。下面就一起来学习用Xshell关联Xftp传输文件。<br>参考原文：<a href="https://blog.csdn.net/longgeaisisi/article/details/78680180" target="_blank" rel="noopener">https://blog.csdn.net/longgeaisisi/article/details/78680180</a></p>
<h3 id="（二）下载配置JDk"><a href="#（二）下载配置JDk" class="headerlink" title="（二）下载配置JDk"></a>（二）下载配置JDk</h3><p>tar -zxvf jdk-8u231-linux-x64.tar.gz<br>vim /etc/profile      编辑配置文件<br>在配置文件后添加下面的内容(我的是直接安装在root目录，所以路径直接写root)<br>export JAVA_HOME=”/root/jdk1.8.0_231”<br>export PATH=”$JAVA_HOME/bin:$PATH”<br>source /etc/profile     刷新配置文件</p>
<h3 id="（三）下载配置Tomcat"><a href="#（三）下载配置Tomcat" class="headerlink" title="（三）下载配置Tomcat"></a>（三）下载配置Tomcat</h3><p>安装命令：tar -zxvf apache-tomcat-8.5.47.tar.gz<br>启动命令：cd apache-tomcat-8.5.47/bin/<br>    ./startup.sh   </p>
<h3 id="（四）下载配置MySQL"><a href="#（四）下载配置MySQL" class="headerlink" title="（四）下载配置MySQL"></a>（四）下载配置MySQL</h3><p>参考原文：<a href="https://www.cnblogs.com/thinkingandworkinghard/p/6711255.html" target="_blank" rel="noopener">https://www.cnblogs.com/thinkingandworkinghard/p/6711255.html</a><br>参考原文：<a href="https://blog.csdn.net/qq_40714770/article/details/84577548" target="_blank" rel="noopener">https://blog.csdn.net/qq_40714770/article/details/84577548</a></p>
<h3 id="安装配置mysql步骤"><a href="#安装配置mysql步骤" class="headerlink" title="安装配置mysql步骤"></a>安装配置mysql步骤</h3><ol>
<li>在Linux上安装mysql</li>
<li>登录mysql，设置root用户的密码</li>
<li>新增zwb用户，设置密码，授予远程访问mysql权限</li>
<li>数据库增删改查</li>
</ol>
<h3 id="在Linux上安装mysql方式"><a href="#在Linux上安装mysql方式" class="headerlink" title="在Linux上安装mysql方式"></a>在Linux上安装mysql方式</h3><ol>
<li>在线安装（yum -y install mysql-community-server  </li>
<li>源码手动编译安装</li>
<li>事先准备好mysql包并通过命令解压tar -xvf mysql-5.7.24-1.el6.x86_64.rpm-bundle.tar通过rpm -vih xx.rpm 依次安装安装</li>
</ol>
<hr>
<p>注：Linux上源码安装mysql需要熟悉yum命令，rpm命令，安装gc++和make编译器（太费时间，容易出错，不采用该方式）</p>
<p>登录mysql，设置root用户的密码<br>     初始登录root用户：      mysql -u root;   （此时root用户密码为空，直接回车）<br>     设置root用户密码：      mysqladmin -u root password 123; (123为密码，也可以写成:’123’或”123”) ；<br>     刷新权限：              flush privileges;<br>     再次登录root用户：      mysql -u root -p; （-u 后跟登入的用户名，-p 提示要密码登入）<br>     退出mysql：              quit或者exit  </p>
<hr>
<p>注：mysql中输入每条SQL命令后需要末尾加”；“（加分号）<br>       mysql中关键字不区分大小写，，列名表名区分大小写，这可在配置文件中修改（mysql的配置文件：my.cnf）<br>修改用户密码或设置权限后，需要使用flush privileges刷新权限后才生效<br>我真是个智障，在workBench中输完SQL命令应该点执行按钮，而不是敲回车  </p>
<p>新增zwb用户，设置密码，授予远程访问mysql权限<br>创建zwb用户，授予zwb权限，使其通过密码可以从任何主机上连接到mysql服务器，命令入下：<br>创建用户：create user ‘zwb’@’%’ identified by ‘@dlmu3709’;   (成功)<br>授予权限：grant select on 数据库.* to 用户名@登录主机 identified by “密码”<br>授予权限：grant select,insert,update,delete on <em>.</em> to zwb@”%” Identified by “123456”;<br>授予权限：grant all on <em>.</em> to ‘zwb’@’%’;<br>刷新权限：flush privileges;<br>配置阿里云安全组规则，开放3306端口  </p>
<h3 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a>数据库增删改查</h3><p>显示数据库：show databases；<br>选择数据库：use 数据库名;<br>显示数据表：show tables；<br>显示表结构：describe  表名；（显示数据库表的列名，列的属性）  </p>
<p>###（五）设置服务开机启动<br>       开启，关闭，重启，查看服务状态<br>格式：service 服务名  start || stop || restart || status<br>实例：</p>
<p>设置MySQL随系统开机启动<br>命令：systemctl enable mysqld<br>命令：systemctl daemon-reload  </p>
<p>关闭防火墙<br>关闭防火墙：sudo systemctl stop firewalld.service<br>关闭开机启动：sudo systemctl disable firewalld.service  </p>
<p>查看MySQL版本<br>登录mysql后输入命令：select version();<br>直接在linux输入命令 rpm -qa|grep mysql  </p>
]]></content>
      <categories>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法之链表系列[题型篇]</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/</url>
    <content><![CDATA[<h1 id="数据结构与算法之链表系列【题型篇】"><a href="#数据结构与算法之链表系列【题型篇】" class="headerlink" title="数据结构与算法之链表系列【题型篇】"></a>数据结构与算法之链表系列【题型篇】</h1><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E3%80%90%E9%A2%98%E5%9E%8B%E7%AF%87%E3%80%91%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png?raw=true" alt="æ°æ®ç»æä¸ç®æ³ä¹é¾è¡¨ç³»åãé¢åç¯ãæç»´å¯¼å¾.png"></p>
<br>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.png?raw=true" alt="æ°æ®ç»æä¸ç®æ³ä¹é¾è¡¨ç³»åç®å½.png"></p>
<br>

<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>如果你和小鹿一样，刚开始对链表的操作代码实现很懵的话，不妨按照小鹿经过一个月的时间对链表相关操作以及题型的整理总结，由浅入深进行适当的练习，我相信，当你真正的练习完这些题目，不但会让你失去链表对你心理上的困惑，而且对你学习其他数据结构有很大的信心和帮助！</p>
<br>

<h4 id="1、学习建议"><a href="#1、学习建议" class="headerlink" title="1、学习建议"></a>1、学习建议</h4><p>小鹿不建议你一口气去看完这篇所有的题目和练习，给自己制定一个小计划，我当初整理该题目的时候，每天都计划认真整理一到题目，把每道题分析透，这样才能达到最好的吸收。</p>
<br>

<h4 id="2、学习路径"><a href="#2、学习路径" class="headerlink" title="2、学习路径"></a>2、学习路径</h4><blockquote>
<p>本篇分为三个阶段，基础练习阶段、进阶练习阶段、加强练习阶段。</p>
</blockquote>
<p>1）基础练习阶段</p>
<p>首先进行第一个阶段之前，你已经对链表的基础知识能够熟练掌握，但是对于没有动手写过链表代码，那么你从第一阶段最基础的开始进行。确保每一个基础点要亲自动手用自己熟悉的语言写出来，虽然本篇中基本都是 javascript 代码实现的，但是算法思路是一成不变的，如果遇到困难可以自行百度或谷歌，也可以下方给我进行留言。</p>
<p>2）进阶练习阶段</p>
<p>如果你对上述的链表基本代码已经完全熟练掌握了，那么恭喜你可以进行下一个阶段，进阶阶段，这一阶段增加的难度就是链表的操作是对于实际问题来解决的，所以非常锻炼你对问题的分析能力和解决能力，也考验你对代码的全面性、鲁棒性。这一阶段非常的重要，下面的每道题我都做出了详细的分析。</p>
<p>3）加强练习阶段</p>
<p>如果上述的进阶练习阶段的题型你都了如指掌了，那么不妨我们实战一下，LeetCode 汇聚了很多面试的题型，所以我在上边整理了几个经典的题目，你可以尝试着解答它们，相关题目的代码以及解题思路我都整理好了。这一阶段的题目小鹿会在后期不断的更新，这些题目你能够完全掌握，链表对你来说小菜一碟了。</p>
<br>

<h2 id="一、链表基础练习（阶段一）"><a href="#一、链表基础练习（阶段一）" class="headerlink" title="一、链表基础练习（阶段一）"></a>一、链表基础练习（阶段一）</h2><blockquote>
<p>自己首相尝试着一个个攻破下方的链表中最基础的操作，相关代码我也整理好了（先自己尝试着去解决哦）。</p>
</blockquote>
<ul>
<li><p>单链表的插入、删除、查找操作（<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/SinglyLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>）。</p>
</li>
<li><p>循环链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/CircularLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p>
</li>
<li><p>双向链表的插入、删除、查找操作 (<a href="https://github.com/luxiangqiang/Data-Structure-Coding/blob/master/Link_List/javascript/DoubleLinkedList.md" target="_blank" rel="noopener">点击查看代码实现</a>)。</p>
</li>
</ul>
<br>

<h2 id="二、链表进阶练习（阶段二）"><a href="#二、链表进阶练习（阶段二）" class="headerlink" title="二、链表进阶练习（阶段二）"></a>二、链表进阶练习（阶段二）</h2><h3 id="1、单链表从尾到头打印"><a href="#1、单链表从尾到头打印" class="headerlink" title="1、单链表从尾到头打印"></a>1、单链表从尾到头打印</h3><blockquote>
<p>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。</p>
</blockquote>
<br>

<h4 id="1-1-问题分析与解决"><a href="#1-1-问题分析与解决" class="headerlink" title="1.1 问题分析与解决"></a>1.1 问题分析与解决</h4><h6 id="▉-问题分析"><a href="#▉-问题分析" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）看到题目第一想到的就是反转链表在打印输出，一种反转链表的方法，但是这种方法改变了原有的链表结构。</p>
<blockquote>
<p>缺点：使得链表的结构发生改变了。如果不改变链表结构应该怎么解决？</p>
</blockquote>
<p>2）从问题中可以得出，我们想要从尾到头打印链表，正常情况下是从头到尾打印的，我们就会想到最后的数据先打印，开始的数据最后打印，有种“先进后出”的特点，我们就能想到用“栈”这种结构，用栈来实现。</p>
<blockquote>
<p>缺点：代码不够简洁。</p>
<p>优点：鲁棒性好（在不确定的情况下，程序仍然可以正确的执行）。</p>
</blockquote>
<p>3）提到栈这种数据结构，我们就会想到“递归”的实现就是用栈这种数据结构实现的。既然栈能实现，那么递归也能实现。</p>
<blockquote>
<p>缺点：如果链表很长，递归深度很深，导致堆栈溢出。</p>
<p>优点：代码简洁、明了。</p>
</blockquote>
<br>

<h6 id="▉-算法思路"><a href="#▉-算法思路" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><blockquote>
<p>得出以下几种实现方式：</p>
<ul>
<li>反转链表法</li>
<li>栈实现</li>
<li>递归实现</li>
</ul>
</blockquote>
<p>1）反转链表实现：</p>
<p>从尾到头输出链表的内容，一般的思路就是将链表反转过来，然后从头到尾输出数据。</p>
<p>2）栈实现:</p>
<p>从头到尾遍历单链表，将数据存储按照顺序存储到栈中。然后遍历整个栈，打印输出数据。</p>
<p>3）递归实现：</p>
<p>可以通过递归的方式来实现单链表从尾到头依次输出，递归过程涉及到“递”和“归”，反转链表输出数据，正式利用了循环“递”的过程，所以数据先从头部输出，那么递归采用的是“归”的过程来输出内容，输出当前结点先要输出当前节点的下一节点。</p>
<br>

<h6 id="▉-测试用例"><a href="#▉-测试用例" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><blockquote>
<p>在写代码之前，要想好测试用例才能写出健全、鲁棒性的代码，也是为了考虑到边界情况，往往也是整个程序最致命的地方，如果考虑不全面，就会出现 bug，导致程序崩溃。</p>
</blockquote>
<p>测试用例：</p>
<p>1）输入空链表；</p>
<p>2）输入的链表只有一个结点；</p>
<p>3）输入的链表有多个结点。</p>
<h6 id="▉-代码实现：反转链表法"><a href="#▉-代码实现：反转链表法" class="headerlink" title="▉ 代码实现：反转链表法"></a>▉ 代码实现：反转链表法</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 功能：单链表反转</span></span><br><span class="line">    <span class="comment">// 步骤:</span></span><br><span class="line">    <span class="comment">// 1、定义三个指针(pre=null/next/current)</span></span><br><span class="line">    <span class="comment">// 2、判断链表是否可反转(头节点是否为空、是否有第二个结点)</span></span><br><span class="line">    <span class="comment">// 3、尾指针指向第一个结点的 next</span></span><br><span class="line">    <span class="comment">// 4、尾指针向前移动</span></span><br><span class="line">    <span class="comment">// 5、当前指针(current)向后移动</span></span><br><span class="line">    <span class="comment">// 6、将 head 指向单转好的结点</span></span><br><span class="line">    reverseList = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//声明三个指针</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head; <span class="comment">//当前指针指向头节点</span></span><br><span class="line">        <span class="keyword">let</span> pre = <span class="literal">null</span>;<span class="comment">//尾指针</span></span><br><span class="line">        <span class="keyword">let</span> next;<span class="comment">//指向当前指针的下一个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断单链表是否符合反转的条件(一个结点以上)？</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span> || <span class="keyword">this</span>.head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始反转</span></span><br><span class="line">        <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = pre;</span><br><span class="line">            pre = current;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.head = pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码实现：循环栈"><a href="#▉-代码实现：循环栈" class="headerlink" title="▉ 代码实现：循环栈"></a>▉ 代码实现：循环栈</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法三：栈实现</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">currentNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">//遍历链表，将数据入栈</span></span><br><span class="line">    <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(currentNode.data);</span><br><span class="line">        currentNode = currentNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历栈，数据出栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码实现：递归"><a href="#▉-代码实现：递归" class="headerlink" title="▉ 代码实现：递归"></a>▉ 代码实现：递归</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断是否为空链表</span></span><br><span class="line"><span class="comment">// 2、终止条件（下一结点为空）</span></span><br><span class="line"><span class="comment">// 3、递归打印下一结点信息</span></span><br><span class="line"><span class="keyword">const</span> tailToHeadOutput = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 判断是否空链表</span></span><br><span class="line">	<span class="keyword">if</span>(head !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断下一结点是否为空</span></span><br><span class="line">	    <span class="keyword">if</span>(head.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 下一结点不为空，先输出下一结点</span></span><br><span class="line">	        tailToHeadOutput(head.next)</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">console</span>.log(head.data);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"空链表"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析"><a href="#▉-性能分析" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><p>反转链表实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(1)。不需要额外的栈存储空间，空间复杂度为 O(1)。</li>
</ul>
<p>循环栈实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li>
</ul>
<p>递归实现：</p>
<ul>
<li>时间复杂度：O(n)。需要遍历整个链表，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(n)。需要额外的栈存储空间，空间复杂度为 O(n)。</li>
</ul>
<br>

<h4 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-考察内容"><a href="#▉-考察内容" class="headerlink" title="▉ 考察内容"></a>▉ 考察内容</h6><p>1）对单链表的基本操作。</p>
<p>2）代码的鲁棒性。</p>
<p>3）循环、递归、栈的灵活运用。</p>
<br>

<h6 id="▉-扩展思考：循环和递归"><a href="#▉-扩展思考：循环和递归" class="headerlink" title="▉ 扩展思考：循环和递归"></a>▉ 扩展思考：循环和递归</h6><p><strong>适用条件：</strong>如果需要进行多次计算相同的问题，将采用循环或递归的方式。</p>
<p><strong>递归的优点：</strong>代码简洁。</p>
<p><strong>递归的缺点：</strong></p>
<p>1）堆栈溢出：函数调用自身，函数的临时变量是压栈的操作，当函数执行完，栈才清空，如果递归的规模过大，在函数内部一直执行函数的自身调用，临时变量一直压栈，系统栈或虚拟机栈内存小，导致堆栈溢出。</p>
<p>2）重复计算：递归会出现很多的重复计算问题，重复计算对程序的性能有很大影响，导致消耗时间成指数增长，但是可以通过散列表的方式解决。</p>
<p>3）高空间复杂度：递归的每次函数调用都要涉及到在内存开辟空间，压栈、出栈等操作，即耗时又耗费空间，导致递归的效率并不如循环的效率。</p>
<p><strong>扩展：</strong></p>
<p>1）递归—栈：递归的本质是栈，通常用栈循环解决的问题适合于递归。</p>
<p>2）递归-动态规划：动态规划解决问题经常用递归的思路分析问题。关于递归重复计算问题，我们通常使用自下而上的解决思路（动态规划）来解决递归重复计算的问题。</p>
<p>※ 具体看这篇之前写的 8000 字的完整章节：<a href="https://github.com/luxiangqiang/Blog/blob/master/articel/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97.md" target="_blank" rel="noopener">数据结构与算法之递归系列</a></p>
<br>

<h6 id="▉-注意事项："><a href="#▉-注意事项：" class="headerlink" title="▉ 注意事项："></a>▉ 注意事项：</h6><p>1）涉及到循环解决的问题，可以想一想能不能使用递归来解决。</p>
<p>2）用递归解决一定要铭记递归的缺点带来的性能问题。</p>
<p>3）递归解决的问题，能不能用动态规划来解决，使得性能更高。</p>
<p>4）用到栈这种数据结构，想一想递归是否可以实现呢。</p>
<br>

<h3 id="2、删除链表结点"><a href="#2、删除链表结点" class="headerlink" title="2、删除链表结点"></a>2、删除链表结点</h3><blockquote>
<p>题目：在 O（1）的时间复杂度内删除链表节点。</p>
<p>给定单向链表的头指针和一个节点指针，定义一个函数在 O（1）时间内删除该节点。</p>
</blockquote>
<br>

<h4 id="2-1-问题分析与解决"><a href="#2-1-问题分析与解决" class="headerlink" title="2.1 问题分析与解决"></a>2.1 问题分析与解决</h4><h6 id="▉-问题分析-1"><a href="#▉-问题分析-1" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）想必看到单链表删除节点的题，第一想到的就是删除链表结点需要以 O（n）时间复杂度遍历链表找到该结点的前结点，然后以 O（1）时间复杂度进行删除，时间复杂度为O（n）。而题目中的确实整体要求时间复杂度为 O（1）。</p>
<p>2）怎么才能达到 O（1）的时间复杂度删除链表？如果不遍历不就可以了？如果直接删除的时间复杂度为 O（1），前提是我们需要知道前结点才能做到。我们就会想怎么做到不用遍历数据才能获取到前结点呢？而且必须保证时间复杂度为 O（1）。</p>
<p>3）但是必须让自己多想一步就是如果删除的结点是尾结点怎么操作，如果删除的链表结点只有一个结点，即是尾结点又是头结点怎么办？</p>
<br>

<h6 id="▉-算法思路-1"><a href="#▉-算法思路-1" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>得出以下几种实现方式：</p>
<ul>
<li>交换结点法</li>
</ul>
<p>1）这一有种技巧很难想到，就是我把当前结点的数据与下一结点的数据进行交换，删除下一结点不就可以达到时间复杂度为O（1）了吗。而且我们知道当前结点就是下一结点的前节点，perfect。</p>
<p>2）针对以上两种特殊情况，如果是尾结点，没有下一结点，我们就从头遍历链表删除节点；如果即是尾结点又是头结点，那么删除头结点，并置于 null。</p>
<br>

<h6 id="▉-测试用例-1"><a href="#▉-测试用例-1" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1)  输入空链表；</p>
<p>2）在多个结点链表中删除中间结点；</p>
<p>3）在多个链表中删除头结点；</p>
<p>4）在多个链表总删除尾结点；</p>
<p>5）在只有一个结点链表中删除唯一结点；</p>
<h6 id="▉-代码实现"><a href="#▉-代码实现" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点(核心代码)</span></span><br><span class="line">    deleteNode = <span class="function"><span class="params">node</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前查找的结点是否为 null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 1、查找删除的结点</span></span><br><span class="line">        <span class="keyword">let</span> d_node = <span class="keyword">this</span>.findByValue(<span class="built_in">parseInt</span>(node.data))</span><br><span class="line">        <span class="comment">// 2、判断该结点是否为尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(d_node.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 重新遍历链表</span></span><br><span class="line">            <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">while</span>(current.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                p = current;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 尾结点置为 null</span></span><br><span class="line">            p.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 3、将删除结点的值与下一结点交换</span></span><br><span class="line">            d_node.data = d_node.next.data;</span><br><span class="line">            <span class="comment">// 4、删除下一结点</span></span><br><span class="line">            d_node.next = d_node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试 </span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">1</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">sortedList1.insert(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">sortedList1.insert(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'------------------------------删除指定结点----------------------------'</span>)</span><br><span class="line"><span class="keyword">let</span> dnode = <span class="keyword">new</span> Node(<span class="string">'1'</span>)</span><br><span class="line">sortedList1.deleteNode(dnode)</span><br><span class="line">sortedList1.print();</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-1"><a href="#▉-性能分析-1" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li><p>时间复杂度：O（1）。经过上述的方法，删除一个链表的结点，除了删除一个链表的尾结点之外，其他删除节点的时间复杂度为 O（1），获取删除的结点的前一结点，时间复杂度为 O（1），删除节点的时间复杂度为 O（1）。只有删除尾结点才需要遍历整个链表，但大部分删除节点是 O（1）的。使用分析时间复杂度的一个方法摊还分析，将删除节点的时间复杂度平均分到其他大部分情况下，所以平均时间复杂度为 O（1）。</p>
</li>
<li><p>空间复杂度：O（1）。不需要额外的内存空间。</p>
</li>
</ul>
<br>

<h4 id="2-2-小结-1"><a href="#2-2-小结-1" class="headerlink" title="2.2 小结"></a>2.2 小结</h4><h6 id="▉-内容考察"><a href="#▉-内容考察" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的删除基本操作。</p>
<p>2）对问题的有创新思维的解决能力：能不能将复杂问题的根源用另一种思维去优化。</p>
<p>3）问题考虑的全面性：考虑到问题出现的各种特殊情况，以及边界问题。</p>
<br>

<h3 id="3、链表中的倒数第-K-个结点"><a href="#3、链表中的倒数第-K-个结点" class="headerlink" title="3、链表中的倒数第 K 个结点"></a>3、链表中的倒数第 K 个结点</h3><blockquote>
<p>题目：输入一个链表，输出该链表中倒数第 K 个节点。为符合大多数人的习惯，从 1 开始计数，即链表的尾结点是倒数第一个节点。</p>
</blockquote>
<br>

<h4 id="3-1-问题分析与解决"><a href="#3-1-问题分析与解决" class="headerlink" title="3.1 问题分析与解决"></a>3.1 问题分析与解决</h4><h6 id="▉-问题分析-2"><a href="#▉-问题分析-2" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）看到这个题的第一想法就是从链表头遍历到链表尾部，然后尾部倒数 k 个数，因为是单链表，所以倒数并不能实现，想法行不通。</p>
<p>2）那我们只能将思路转移到头结点开始，怎么才能从头结点开始遍历到倒数第 k 个结点呢？大体我们可以得出至少需要遍历两次链表。</p>
<p>3）上述能不能再优化呢？遍历一次链表就可以完成查找？</p>
<br>

<h6 id="▉-算法思路-2"><a href="#▉-算法思路-2" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>得出以下几种实现方式：</p>
<ul>
<li>两次遍历法</li>
<li>一次遍历法</li>
</ul>
<p>前提条件：</p>
<p>1）<strong>不要忘记判断单链表是否为环型结构</strong></p>
<p>两次遍历法：</p>
<p>1）有一个规律就是链表的长度 n 减去 k 加 1 就是倒数第 k 个数据。所以需要遍历链表得到链表的长度，然后再遍历两次找到链表的倒数第 k 个数据。整个过程需要遍历两遍链表。</p>
<p>一次遍历法：</p>
<p>1）那我们就用到双指针，第一个指针指向第一个结点，第二个指针指向 k - 1 个结点，同时向前移动，直到第二个节点指向尾结点位置，第一个节点就指向了倒数第 k 结点。遍历一遍链表就完成查找。</p>
<br>

<h6 id="▉-测试用例-2"><a href="#▉-测试用例-2" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）k 的取值范围（0 &lt; k &lt; n）;输入不在范围内的数据。</p>
<p>2）输入空链表。</p>
<p>3）查找倒数第 k 结点为头结点/尾结点。    </p>
<br>

<h6 id="▉-代码实现-1"><a href="#▉-代码实现-1" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测单链表是否为环</span></span><br><span class="line">    checkCircle = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否为空链表</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.head == <span class="literal">null</span>) <span class="keyword">return</span> fast;</span><br><span class="line">        <span class="comment">// 定义快慢指针</span></span><br><span class="line">        <span class="keyword">let</span> fast = <span class="keyword">this</span>.head.next;</span><br><span class="line">        <span class="keyword">let</span> low = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="comment">//进行循环判断(当前 fast 结点/fast 移动两步后的结点是否为 null)</span></span><br><span class="line">        <span class="keyword">while</span>(fast !== <span class="literal">null</span> &amp;&amp; fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// fast 指针向前移动两步</span></span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// low 指针向前移动一步</span></span><br><span class="line">            low = low.next;</span><br><span class="line">            <span class="comment">// 如果为环，总有一天会相遇</span></span><br><span class="line">            <span class="keyword">if</span>(fast === low) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找倒数第 k 结点</span></span><br><span class="line">    findByIndexFromEnd = <span class="function"><span class="params">k</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//判断 k 是否大于0</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'k 的大小不在搜索范围内'</span>;</span><br><span class="line">        <span class="comment">// 检测是否为环</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkCircle()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 定义两个指针进行遍历</span></span><br><span class="line">        <span class="keyword">let</span> current = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">let</span> fast = current;</span><br><span class="line">        <span class="keyword">let</span> low = current;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= k - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// k 的大小超出链表大小的范围</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">'k 的大小超出链表的范围'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// low 和 fast 指针同时移动</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            low = low.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回倒数第 k 结点</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.insert(<span class="string">'1'</span>,<span class="string">'head'</span>);</span><br><span class="line"><span class="comment">// list.insert('2','1');</span></span><br><span class="line"><span class="comment">// list.insert('3','2');</span></span><br><span class="line"><span class="comment">// list.insert('4','3');</span></span><br><span class="line"><span class="comment">// list.insert('5','4');</span></span><br><span class="line"><span class="comment">// list.insert('6','5');</span></span><br><span class="line">list.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'-------------------查找倒数第 k 结点----------------'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(list.findByIndexFromEnd(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-2"><a href="#▉-性能分析-2" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><p>两次遍历法：</p>
<ul>
<li>时间复杂度：O（k*n）。当 k 趋近于 n 时，最坏时间复杂度为 O（n^2）。</li>
<li>空间复杂度：O（1）。不需要额外的内存空间。</li>
</ul>
<p>一次遍历法：</p>
<ul>
<li>时间复杂度：O（n）。只需要遍历一次单链表，所以时间复杂度为O（n）。</li>
<li>空间复杂度：O（1）。不需要额外的内存空间。</li>
</ul>
<br>

<h4 id="3-2-小结"><a href="#3-2-小结" class="headerlink" title="3.2 小结"></a>3.2 小结</h4><h6 id="▉-内容考察-1"><a href="#▉-内容考察-1" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的基本操作。</p>
<p>2）代码的全面性、鲁棒性。</p>
<br>

<h6 id="▉-注意事项"><a href="#▉-注意事项" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）当我们用一个指针不能解决时，想一想两个指针能否解决？</p>
<br>

<h6 id="▉-相关题目"><a href="#▉-相关题目" class="headerlink" title="▉ 相关题目"></a>▉ 相关题目</h6><p>1）求中间结点</p>
<p>2）求倒数第 k 个结点</p>
<p>3）检测环的存在</p>
<br>

<h3 id="4、反转链表"><a href="#4、反转链表" class="headerlink" title="4、反转链表"></a>4、反转链表</h3><blockquote>
<p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转链表的头结点。</p>
</blockquote>
<br>

<h4 id="4-1-问题分析与解决"><a href="#4-1-问题分析与解决" class="headerlink" title="4.1 问题分析与解决"></a>4.1 问题分析与解决</h4><h6 id="▉-问题分析-3"><a href="#▉-问题分析-3" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）反转链表的我们第一能够想到的方法就是最常用的方法，声明三个指针，把头结点变为尾结点，然后下一结点拼接到尾结点的头部，一次类推。说白了就是就是直接将链表指针反转就可以实现反转链表。</p>
<br>

<h6 id="▉-算法思路-3"><a href="#▉-算法思路-3" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p>1）定义三个指针，分别为 Pnext、pre、current，current 存储当前结点， pre 指向反转好的结点的头结点，Pnext 存储下一结点信息。</p>
<p>2）判断当前结点是否可以反转（是否为空链表或链表大于 1 个结点）?</p>
<p><strong>步骤：</strong></p>
<p>1）Pnext 指针存储下一结点 。</p>
<p>2）当前结点的 next 结点是否为 null (为 null 的话当前结点就是最后的一个结点)，如果为 null，将当前节点赋值为 head 头指针（断裂处）。</p>
<p>3）将 pre 指针指向的结点赋值当前节点 current 的下一结点 next。</p>
<p>4）然后让 pre 指针指向当前节点 current。</p>
<p>5）current 继续遍历, 当前节点指向 current 指向 Pnext。</p>
<p><strong>递归法（重点分析）：</strong></p>
<p>1）先确定终止条件：当下一结点为  null  时，返回当前节点；</p>
<p>2）判断当前的链表是否为  null；</p>
<p>3）递归找到尾结点，将其存储为头结点。</p>
<p>4）此时递归的层次是第二层递归，所以要设置为头结点的下一结点就是当前第二层结点，并且将第二节点的下一结点设置为 bull。</p>
<br>

<h6 id="▉-测试用例-3"><a href="#▉-测试用例-3" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）链表是空链表。</p>
<p>2）当前链表的长度小于等于 1。</p>
<p>3）输入长度大于 1 的链表。</p>
<br>

<h6 id="▉-代码实现-2"><a href="#▉-代码实现-2" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前链表是否为空链表</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义三个指针</span></span><br><span class="line">    <span class="keyword">let</span> [current,prev,next] = [head,<span class="literal">null</span>,<span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(current !== <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//1、存储下一结点</span></span><br><span class="line">        next = current.next;</span><br><span class="line">        <span class="keyword">if</span>(next == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = current;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-递归法"><a href="#▉-递归法" class="headerlink" title="▉ 递归法"></a>▉ 递归法</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">head</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//如果链表为空或者链表中只有一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//先反转后面的链表，走到链表的末端结点</span></span><br><span class="line">        <span class="keyword">let</span> newhead = reverseList(head.next);</span><br><span class="line">        <span class="comment">//再将当前节点设置为后面节点的后续节点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-3"><a href="#▉-性能分析-3" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li>时间复杂度：O(n)。只需遍历整个链表就可以完成反转，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(1)。只需要常量级的空间，空间复杂度为 O(1)。</li>
</ul>
<br>

<h4 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h4><h6 id="▉-内容考察-2"><a href="#▉-内容考察-2" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对单链表的基本操作。</p>
<p>2）对指针操作顺序的逻辑性考察。</p>
<p>3）考察思维的全面性以及代码的鲁棒性。</p>
<br>

<h6 id="▉-注意事项-1"><a href="#▉-注意事项-1" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）边界条件。</p>
<p>2）写代码之前想好测试用例，写完代码一一验证测试用例的正确性。</p>
<br>

<h3 id="5、合并两个有序链表"><a href="#5、合并两个有序链表" class="headerlink" title="5、合并两个有序链表"></a>5、合并两个有序链表</h3><blockquote>
<p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
</blockquote>
<br>

<h4 id="5-1-问题分析与解决"><a href="#5-1-问题分析与解决" class="headerlink" title="5.1 问题分析与解决"></a>5.1 问题分析与解决</h4><h6 id="▉-问题分析-4"><a href="#▉-问题分析-4" class="headerlink" title="▉ 问题分析"></a>▉ 问题分析</h6><p>1）合并两个链表，经常犯的错误就是没有弄清除指针的指向，导致链表合并的时候断裂以及代码全面性考虑的不全，也就是代码的鲁棒性存在问题。</p>
<p>2）递归。每次都要比较两个结点大小，是否可以使用递归来解决呢？</p>
<br>

<h6 id="▉-算法思路-4"><a href="#▉-算法思路-4" class="headerlink" title="▉ 算法思路"></a>▉ 算法思路</h6><p><strong>一般解决法：</strong></p>
<p>1）合并两个链表，首先需要两个指针，分别指向两个链表。</p>
<p>2）比较两个指针指向结点元素的大小，小的结点添加到新链表，然后指针向后移动继续比较。</p>
<p>3）直到其中一个链表没有结点了，另一个链表存在结点，将剩余的结点加入到新链表的尾部，完成合并。</p>
<p><strong>递归法：（满足递归的三个条件）</strong></p>
<p>比较当前结点大小先比较下一结点的大小。</p>
<p>1）结点之间的比较可以分的子问题为每个节点的比较。</p>
<p>2）终止条件：其中一个链表结点为 null。</p>
<p>3）子问题和总问题具有相同的解决思路。</p>
<br>

<h6 id="▉-测试用例-4"><a href="#▉-测试用例-4" class="headerlink" title="▉ 测试用例"></a>▉ 测试用例</h6><p>1）输入两个空链表。</p>
<p>2）其中一个链表为空链表。</p>
<p>3）输入两个完整的链表。</p>
<br>

<h6 id="▉-代码实现-3"><a href="#▉-代码实现-3" class="headerlink" title="▉ 代码实现"></a>▉ 代码实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能:两个有序链表的合并</span></span><br><span class="line"><span class="comment">// 步骤:</span></span><br><span class="line"><span class="comment">// 1、判断两个链表是否为 null,并将链表赋予临时变量</span></span><br><span class="line"><span class="comment">// 2、声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line"><span class="comment">// 3、两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line"><span class="comment">// 4、将链表剩余数据添加到合并链表后边</span></span><br><span class="line"><span class="keyword">const</span> mergeSortList = <span class="function">(<span class="params">listA,listB</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(listA === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(listB === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> a = listA;</span><br><span class="line">    <span class="keyword">let</span> b = listB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明合并链表,通过 currentNode 指向当前结点</span></span><br><span class="line">    <span class="keyword">let</span> resultList = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个链表比较大小,数值小的添加到合并链表中,合并链表进行指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">        resultList = a</span><br><span class="line">        a = a.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resultList = b</span><br><span class="line">        b = b.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> currentNode = resultList;</span><br><span class="line">    <span class="keyword">while</span> (a !== <span class="literal">null</span> &amp;&amp; b !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.data &lt; b.data) &#123;</span><br><span class="line">            currentNode.next = a</span><br><span class="line">            a = a.next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentNode.next = b</span><br><span class="line">            b = b.next</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode = currentNode.next</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表剩余数据添加到合并链表后边 </span></span><br><span class="line">    <span class="keyword">if</span>(a !== <span class="literal">null</span>)&#123;</span><br><span class="line">        currentNode.next = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        currentNode.next = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回合并链表</span></span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-递归实现"><a href="#▉-递归实现" class="headerlink" title="▉ 递归实现"></a>▉ 递归实现</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeTwoLists(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-代码测试"><a href="#▉-代码测试" class="headerlink" title="▉ 代码测试"></a>▉ 代码测试</h6><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">'head'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据 value 查找结点</span></span><br><span class="line">    findByValue = <span class="function">(<span class="params">value</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span> &amp;&amp; currentNode.data !== value)&#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该结点是否找到</span></span><br><span class="line">        <span class="built_in">console</span>.log(currentNode)</span><br><span class="line">        <span class="keyword">return</span> currentNode === <span class="literal">null</span> ? <span class="number">-1</span> : currentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入元素(指定元素向后插入)</span></span><br><span class="line">    insert = <span class="function">(<span class="params">value,element</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//先查找该元素</span></span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.findByValue(element);</span><br><span class="line">        <span class="comment">//如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span>(currentNode == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"未找到插入位置!"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.next = currentNode.next;</span><br><span class="line">        currentNode.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有结点</span></span><br><span class="line">    print = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.head</span><br><span class="line">        <span class="comment">//如果结点不为空</span></span><br><span class="line">        <span class="keyword">while</span>(currentNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(currentNode.data)</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并两个链表</span></span><br><span class="line"><span class="keyword">var</span> mergeSortList = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断数值大小递归</span></span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">        result = l1;</span><br><span class="line">        result.next = mergeSortList(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = l2;</span><br><span class="line">        result.next = mergeSortList(l2.next,l1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">sortedList1 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList1.insert(<span class="number">9</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">8</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">7</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.insert(<span class="number">6</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList1.print();</span><br><span class="line">sortedList2 = <span class="keyword">new</span> LinkedList()</span><br><span class="line">sortedList2.insert(<span class="number">21</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">20</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">19</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.insert(<span class="number">18</span>, <span class="string">'head'</span>)</span><br><span class="line">sortedList2.print();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----------------合并两个有序的链表----------------'</span>)</span><br><span class="line"><span class="keyword">let</span> resultList = mergeSortList(sortedList1.head.next,sortedList2.head.next)</span><br><span class="line"><span class="keyword">while</span> (resultList !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resultList.date);</span><br><span class="line">    resultList = resultList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h6 id="▉-性能分析-4"><a href="#▉-性能分析-4" class="headerlink" title="▉ 性能分析"></a>▉ 性能分析</h6><ul>
<li>时间复杂度：O（n）。n 为较短的链表的长度。</li>
<li>空间复杂度：O（n+m）。需要额外的 n+m(两个链表长度之和) 大小的空间来存储合并的结点。</li>
</ul>
<br>

<h4 id="5-2-小结"><a href="#5-2-小结" class="headerlink" title="5.2 小结"></a>5.2 小结</h4><h6 id="▉-内容考察-3"><a href="#▉-内容考察-3" class="headerlink" title="▉ 内容考察"></a>▉ 内容考察</h6><p>1）对链表的基本操作。</p>
<p>2）写代码考虑问题的全面性和鲁棒性。</p>
<br>

<h6 id="▉-注意事项-2"><a href="#▉-注意事项-2" class="headerlink" title="▉ 注意事项"></a>▉ 注意事项</h6><p>1）递归实现，注意递归解决问题的三个缺点。</p>
<ul>
<li>堆栈溢出</li>
<li>重复数据</li>
<li>高空间复杂度</li>
</ul>
<br>

<h2 id="三、LeetCode-加强练习阶段（阶段三）"><a href="#三、LeetCode-加强练习阶段（阶段三）" class="headerlink" title="三、LeetCode 加强练习阶段（阶段三）"></a>三、LeetCode 加强练习阶段（阶段三）</h2><blockquote>
<p>如果你对基本的链表操作已经掌握，想进一步提高对链表熟练度的操作，可以练习一下 LeetCode 题目。每道题我都做了详细的解析，如：问题分析、算法思路、代码实现、考查内容等，有关链表的相关题目会不断更新……</p>
</blockquote>
<ul>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表 I</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle.md" target="_blank" rel="noopener">题目解析</a> )</li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/LinkedListCycle2.md" target="_blank" rel="noopener">题目解析</a> )</li>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a> (<a href="https://github.com/luxiangqiang/JS-LeetCode/blob/master/MergekSortedLists.md" target="_blank" rel="noopener">题目解析</a> )</li>
</ul>
<br>

<h2 id="四、链表总结"><a href="#四、链表总结" class="headerlink" title="四、链表总结"></a>四、链表总结</h2><blockquote>
<p>做了大量有关链表的题型之后，对链表的操作做一个总结和复盘，对链表有一个整体的把握和重新的认识。</p>
</blockquote>
<br>

<h4 id="1、结构上"><a href="#1、结构上" class="headerlink" title="1、结构上"></a>1、结构上</h4><p>① 存储链表的内存空间是不连续的，所有需要使用指针将这些零碎内存空间连接起来，导致需要通过指针来进行操作，这也是为什么链表中大多数都是关于指针的操作的原因。</p>
<p>② 链表在结构上有两个特殊的地方就是链表头和链表尾，很多操作都要对链表头和链表尾进行特殊处理，所以我们可以借助哨兵思想（在链表头添加一个哨兵），这样带头的链表可以简化问题的解决。</p>
<br>

<h4 id="2、操作上"><a href="#2、操作上" class="headerlink" title="2、操作上"></a>2、操作上</h4><p>① 递归：链表中的很多操作都是可以用递归来进行解决的，因为链表的每个结点都有着相同的结构，再加上解决的问题可以分解为子问题进行解决。所以在链表中递归编程技巧还是非常常用的。如：从尾到头打印链表、合并两个有序链表、反转链表等。</p>
<p>② 双指针：链表中大部分都是进行指针操作，链表属于线性表结构（形如一条线的结构），很多问题可以使用双指针来解决，也是非常常用到的。如：查找倒数第K 结点、求链表的中间结点等。</p>
<br>

<h4 id="3、性能上"><a href="#3、性能上" class="headerlink" title="3、性能上"></a>3、性能上</h4><p>① 链表正是因为存储空间不连续，对 CPU 缓存不友好，随时访问只能从头遍历链表，时间复杂度为 O（n），但是链表的这种结构也有个好处就是。可以动态的申请内存空间，不需要提前申请。</p>
<p>② 指针的存储是需要额外的内存空间的，如果存储的数据远大于存储指针的内存空间，可以进行忽略。</p>
<hr>

<p><strong>作者：</strong>小鹿</p>
<p><strong>座右铭：</strong>追求平淡不平凡，一生追求做一个不甘平凡的码农!</p>
<p><strong>本文首发于 Github ，转载请说明出处：</strong><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之链表系列[题型篇].md" target="_blank" rel="noopener">https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之链表系列[题型篇].md</a></p>
<p><strong>个人公众号：「一个不甘平凡的码农」。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之二叉树系列[题型篇]</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%5B%E9%A2%98%E5%9E%8B%E7%AF%87%5D/</url>
    <content><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>不知道你有没有这种困惑，虽然刷了很多算法题，当我去面试的时候，面试官让你手写一个算法，可能你对此算法很熟悉，知道实现思路，但是总是不知道该在什么地方写，而且很多边界条件想不全面，一紧张，代码写的乱七八糟。如果遇到没有做过的算法题，思路也不知道从何寻找，那么这篇文章就主要为你解决这几个问题。</p>
<p>《剑指 offer》是准备数据结构与算法面试的一本好书，里边很多面试手写算法很多的注意的问题，但是基本都是用 C++ 实现的，书中每章节的分类都是按照性能和消耗以及手写代码的注意的几大点进行了分类，针对每个不同的点，进行数据结构与算法的混合实现。</p>
<p>二遍刷题，发现了还可以根据自身情况进行整理和分类。全部代码是用 JS 书写，都经过 Leetcode 标准测试（小部分Leetcode 没有的题目），对所有的算法题的特点进行总结分类，手写算法中，如何考虑到全部的边界条件；如果快速多种思路解决，如何将思路快速的转化为代码，这是这一篇重点分享的地方。</p>
<p>二叉树题目共有 11 题，我把这 11 题书中对实现方法和思路有详细的讲解，但是对于个人来说，以后遇到陌生的二叉树的题目怎么进行解决，通过对 11 个题的分析、整理，得出以下几个步骤，首先先来看这 11 个二叉树经典算法题。</p>
<p><strong>PS：</strong>如果你已经做过这几道题，而且能够顺利的手写出来，不妨滑到最底部，希望最后的二叉树思路、测试用例以及代码编写的总结对你在面试中有所帮助（这篇文章精华所在）。</p>
<h3 id="一、面试题7：重建二叉树"><a href="#一、面试题7：重建二叉树" class="headerlink" title="一、面试题7：重建二叉树"></a>一、面试题7：重建二叉树</h3><blockquote>
<p>已知前序遍历为{1,2,4,7,3,5,6,8}，中序遍历为{4,7,2,1,5,3,8,6}，它的二叉树是怎么样的？</p>
</blockquote>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a>1、思路</h4><p>根据前、中序遍历的特点，（根左右、左根右），先根据前序遍历确定根节点，然后在中序遍历知道该根节点的左右树的数量，反推出前序遍历中左子树的结点有哪些。根据该思路进行递归即可完成二叉树的重建。</p>
<h4 id="2、测试用例"><a href="#2、测试用例" class="headerlink" title="2、测试用例"></a>2、测试用例</h4><ul>
<li><p>完全二叉树、非完全二叉树 —— 普通测试。</p>
</li>
<li><p>只有左子节点二叉树，只有右子节点、只有一个结点的二叉树 —— 特殊二叉树测试。</p>
</li>
<li><p>空树、前序和中序不匹配 —— 输入测试。</p>
</li>
</ul>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span><span class="comment">// 定义结点</span></span><br><span class="line"> <span class="number">2</span><span class="comment">// class TreeNode&#123;</span></span><br><span class="line"> <span class="number">3</span><span class="comment">//     constructor(data)&#123;</span></span><br><span class="line"> <span class="number">4</span><span class="comment">//         this.data = data;</span></span><br><span class="line"> <span class="number">5</span><span class="comment">//         this.left = null;</span></span><br><span class="line"> <span class="number">6</span><span class="comment">//         this.right = null;</span></span><br><span class="line"> <span class="number">7</span><span class="comment">//     &#125; </span></span><br><span class="line"> <span class="number">8</span><span class="comment">// &#125;</span></span><br><span class="line"> <span class="number">9</span></span><br><span class="line"><span class="number">10</span><span class="comment">// 参数：前序遍历数组 ~ 中序遍历数组</span></span><br><span class="line"><span class="number">11</span><span class="keyword">const</span> reConstructBinaryTree = <span class="function">(<span class="params">pre, vin</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="number">12</span>    <span class="comment">// 判断前序数组和中序数组是否为空</span></span><br><span class="line"><span class="number">13</span>    <span class="keyword">if</span>(!pre || pre.length === <span class="number">0</span> || !vin || vin.length === <span class="number">0</span>)&#123;</span><br><span class="line"><span class="number">14</span>        <span class="keyword">return</span>;</span><br><span class="line"><span class="number">15</span>    &#125;</span><br><span class="line"><span class="number">16</span>    <span class="comment">// 新建二叉树的根节点</span></span><br><span class="line"><span class="number">17</span>    <span class="keyword">var</span> treeNode = &#123;</span><br><span class="line"><span class="number">18</span>        val: pre[<span class="number">0</span>]</span><br><span class="line"><span class="number">19</span>    &#125;</span><br><span class="line"><span class="number">20</span>    <span class="comment">// 查找中序遍历中的根节点</span></span><br><span class="line"><span class="number">21</span>    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pre.length; i++) &#123;</span><br><span class="line"><span class="number">22</span>        <span class="keyword">if</span> (vin[i] === pre[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="number">23</span>            <span class="comment">// 将左子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">24</span>            treeNode.left = reConstructBinaryTree(pre.slice(<span class="number">1</span>, i+<span class="number">1</span>), vin.slice(<span class="number">0</span>, i));</span><br><span class="line"><span class="number">25</span>            <span class="comment">// 将右子树的前中序遍历分割开</span></span><br><span class="line"><span class="number">26</span>            treeNode.right = reConstructBinaryTree(pre.slice(i+<span class="number">1</span>),vin.slice(i+<span class="number">1</span>));</span><br><span class="line"><span class="number">27</span>        &#125;</span><br><span class="line"><span class="number">28</span>    &#125;</span><br><span class="line"><span class="number">29</span>    <span class="comment">// 返回该根节点</span></span><br><span class="line"><span class="number">30</span>    <span class="keyword">return</span> treeNode;</span><br><span class="line"><span class="number">31</span>&#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span><span class="keyword">let</span> pre = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>];</span><br><span class="line"><span class="number">34</span><span class="keyword">let</span> vin = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>];</span><br><span class="line"><span class="number">35</span><span class="built_in">console</span>.log(reConstructBinaryTree(pre,vin));</span><br></pre></td></tr></table></figure>



<h3 id="二、面试题8：二叉树的下一节点"><a href="#二、面试题8：二叉树的下一节点" class="headerlink" title="二、面试题8：二叉树的下一节点"></a>二、<strong>面试题8：二叉树的下一节点</strong></h3><blockquote>
<p>给定一个二叉树的节点，如何找出中序遍历的下一节点。有两个指向左右子树的指针，还有一个指向父节点的指针。</p>
</blockquote>
<h4 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h4><p>求中序遍历的下一节点，就要分各种情况（明确中序遍历下一结点在二叉树中的位置有哪些），然后对某种情况详细分析。</p>
<p>下一结点可能存在的情况：</p>
<ul>
<li>有右子节点<ul>
<li>右子节点有无左子节点<ul>
<li>无 —— 右子节点就是当前结点下一节</li>
<li>有 —— 递归寻找右子节点的左子节点就是下一节点</li>
</ul>
</li>
</ul>
</li>
<li>无右子节点<ul>
<li>无父节点 —— 无下一结点</li>
<li>有父节点<ul>
<li>当前结点作为父节点的左子节点 —— 下一结点为父节点</li>
<li>当前结点作为父节点的右子节点 —— 向父节点递归寻找作为左子节点的结点就是下一节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、测试用例"><a href="#二、测试用例" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通测试 —— 完全二叉树、非完全二叉树</li>
<li>特殊测试 —— 只要左子节点的二叉树、只有右子节点的二叉树、只有一个结点</li>
<li>输入测试 —— 空节点</li>
</ul>
<h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getNextNode = <span class="function">(<span class="params">pNode</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断该结点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(pNode == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前结点有右子树且左子树</span></span><br><span class="line">    <span class="keyword">if</span>(pNode.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">        pNode = pNode.right;</span><br><span class="line">        <span class="comment">// 判断右子树是否有左子树</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 判断当前结点是否存在父节点(如果为空,没有下一结点)</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next !== <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode == pNode.next.left)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有下一结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三、面试题26：树的子结构"><a href="#三、面试题26：树的子结构" class="headerlink" title="三、面试题26：树的子结构"></a>三、面试题26：树的子结构</h3><blockquote>
<p>输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。</p>
</blockquote>
<h4 id="一、思路-1"><a href="#一、思路-1" class="headerlink" title="一、思路"></a>一、思路</h4><p>通过判断两棵树的根节点否相同，如果相同，则递归判断树剩余的结点是否相同。如果不相同，则递归树的左右子节点进行对比找到相同的根节点。</p>
<h4 id="二、测试用例-1"><a href="#二、测试用例-1" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>是子结构、不是子结构 —— 普通测试。</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试。</li>
<li>空树 —— 输入测试。</li>
</ul>
<h4 id="三、代码实现-1"><a href="#三、代码实现-1" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TreeConstrutor = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断输入是否为 null</span></span><br><span class="line">    <span class="comment">// nodeA 为 null 不会有子结构</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 如果 nodeB 为 null,代表所有子结构比较完成</span></span><br><span class="line">    <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点相同，则进行子结构全部的验证,返回验证的结果</span></span><br><span class="line">    <span class="keyword">if</span>(nodeA.data === nodeB.data)&#123;</span><br><span class="line">       result = match(nodeA, nodeB)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果根节点不相同，继续递归遍历查找相同的根节点</span></span><br><span class="line">    <span class="keyword">return</span> TreeConstrutor(nodeA.left, nodeB) || TreeConstrutor(nodeA.right, nodeB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配根节点相同的子结构</span></span><br><span class="line"><span class="keyword">const</span> match = <span class="function">(<span class="params">nodeA, nodeB</span>)=&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(nodeA == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(nodeB == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 判断匹配的当前结点是否相同</span></span><br><span class="line">     <span class="keyword">if</span>(nodeA.data == nodeB.data)&#123;</span><br><span class="line">         <span class="comment">// 递归匹配其他子节点</span></span><br><span class="line">    	<span class="keyword">return</span> match(nodeA.left, nodeB.left) &amp;&amp; match(nodeA.right, nodeB.right);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不相同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四、面试题27：二叉树的镜像"><a href="#四、面试题27：二叉树的镜像" class="headerlink" title="四、面试题27：二叉树的镜像"></a>四、<strong>面试题27：二叉树的镜像</strong></h3><blockquote>
<p>请完成一个函数，如果一个二叉树，该函数输出它的镜像。</p>
</blockquote>
<h4 id="一、思路-2"><a href="#一、思路-2" class="headerlink" title="一、思路"></a>一、思路</h4><p>根节点的左右子节点相互交换，继续递归遍历，将子节点的左右结点进行交换，知道遇到叶子节点。</p>
<h4 id="二、测试用例-2"><a href="#二、测试用例-2" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>普通二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码实现-2"><a href="#三、代码实现-2" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insert = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     	<span class="keyword">return</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行结点交换</span></span><br><span class="line">    Let tempNode = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = tempNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历剩余的子节点</span></span><br><span class="line">    insert(root.left);</span><br><span class="line">    insert(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五、面试题28：对称二叉树"><a href="#五、面试题28：对称二叉树" class="headerlink" title="五、面试题28：对称二叉树"></a>五、<strong>面试题28：对称二叉树</strong></h3><h4 id="一、思路-3"><a href="#一、思路-3" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、首先，观察一个对称的二叉树有什么特点？</p>
<ul>
<li>结构上：在结构上实对称的，某一节点的左子节点和某一节点的右子节点对称。</li>
<li>规律上：我们如果进行前序遍历（根、左、右），然后对前序遍历进行改进（根、右、左），如果是对称的二叉树，他们的遍历结果是相同的。</li>
</ul>
<p>2、考虑其他情况</p>
<ul>
<li>结点数量不对称</li>
<li>结点值不对称</li>
</ul>
<h4 id="二、测试用例-3"><a href="#二、测试用例-3" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li><p>对称二叉树、不对称二叉树（结点数量不对称、结点结构不对称） —— 普通测试</p>
</li>
<li><p>所有结点值都相同的二叉树 —— 特殊测试</p>
</li>
<li><p>空二叉树 —— 输入测试</p>
</li>
</ul>
<h4 id="三、代码编写"><a href="#三、代码编写" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function">(<span class="params">root</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断二叉树是否为 null —— 输入测试，                                                     	  if(root == null)&#123;</span></span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断输入的二叉树,从根节点开始判断是否是对称二叉树</span></span><br><span class="line">	<span class="keyword">var</span> Symmetric = <span class="function">(<span class="params">lNode, rNode</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 判断左右结点是否都为 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 判断其中一个为 null 另一个不是 null</span></span><br><span class="line">        <span class="keyword">if</span>(lNode == <span class="literal">null</span> &amp;&amp; rNode !== <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(lNode !== <span class="literal">null</span> &amp;&amp; rNode == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// 判断两个结点的值是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(lNode.val !== rNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相同，继续递归判断其他的结点</span></span><br><span class="line">        <span class="keyword">return</span> Symmetric(lNode.left,rNode.right) &amp;&amp; Symmetric(lNode.right,rNode.left)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Symmetric(root.left,root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="六、面试题32：从上到下打印二叉树"><a href="#六、面试题32：从上到下打印二叉树" class="headerlink" title="六、面试题32：从上到下打印二叉树"></a>六、面试题32：从上到下打印二叉树</h3><blockquote>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。（按层遍历二叉树）</p>
</blockquote>
<h4 id="一、思路-4"><a href="#一、思路-4" class="headerlink" title="一、思路"></a>一、思路</h4><p>从根节点开始按层遍历打印结点（自左往右），下一层的遍历是上一层的字节点，但是我们发现想要获取到上层结点的子节点时，上层的父节点已经遍历过去可，想要在获取到，必须存储父节点。然后下层遍历的时候，自左往右取出父节点，依次打印子节点。</p>
<p>上方的解题思路中父节点的存储和遍历让我们想到一个熟悉的数据结构，对了，“先进先出”的思想，那就是队列。在遍历上一层结点的时候，先打印结点值，然后判断是够存在左右子树，如果存在，将给结点入队，直到该层的结点全部遍历完成。然后队列出队，分别打印结点，循环此步骤。</p>
<h4 id="二、测试用例-4"><a href="#二、测试用例-4" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左、右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-1"><a href="#三、代码编写-1" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：树的根节点。</li>
<li>判断是否为空。</li>
<li>打印结点值,判断该结点是否存在子节点，如果存在就入队。</li>
<li>出队，打印结点</li>
<li>循环上述步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = []; <span class="comment">// 存放遍历的结果</span></span><br><span class="line"> 	<span class="comment">// 判断根节点是否为 null</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> [];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 声明一个队列</span></span><br><span class="line">   <span class="keyword">let</span> queue = [];</span><br><span class="line">   queue.push(root)</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 出队，打印结结点、判断是否存在子节点</span></span><br><span class="line">   <span class="keyword">while</span>(queue.length !== <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">let</span> temp = [];             <span class="comment">// 存储每层的结点</span></span><br><span class="line">       <span class="keyword">let</span> len = queue.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len;j++)&#123;</span><br><span class="line">           <span class="comment">// 出队</span></span><br><span class="line">           <span class="keyword">let</span> tempNode = queue.shift(); </span><br><span class="line">           <span class="comment">// 存储结点值</span></span><br><span class="line">           temp.push(tempNode.val)		  </span><br><span class="line">           <span class="comment">// 判断出队的根节点是否有子节点</span></span><br><span class="line">           <span class="keyword">if</span>(tempVal.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(tempVal.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">              queue.push(tempVal.left)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//存储每层的遍历的结点值</span></span><br><span class="line">       result.push(temp);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回结果集</span></span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="七、面试题33：二叉树的后序遍历序列"><a href="#七、面试题33：二叉树的后序遍历序列" class="headerlink" title="七、面试题33：二叉树的后序遍历序列"></a>七、<strong>面试题33：二叉树的后序遍历序列</strong></h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后续遍历。如果是返回 true，如果不是返回 false。假设输入的任意两个数字互不相同。</p>
<h4 id="一、思路-5"><a href="#一、思路-5" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>根据后续遍历的规律和二叉树具备的特点</strong>，可以找到的规律就是（左、右、根）序列的最后一个数为根节点，又根据二叉树的特点，左子节点小于根节点，右子节点大于根节点，分离出左右子节点，根据上边的规律，<strong>递归</strong>剩下的序列。</p>
<h4 id="二、测试用例-5"><a href="#二、测试用例-5" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、不完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-2"><a href="#三、代码编写-2" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：数组</li>
<li>判断数组是否为空</li>
<li>取数组的最后一个元素作为对比的根节点</li>
<li>根据根节点值的大小分割数组（分割数组的同时判断是否都满足小于根节点的要求）</li>
<li>判断分割数组是否是空</li>
<li>递归上方的步骤</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isPostorder = <span class="function">(<span class="params">arr</span>)=&gt;</span>&#123;</span><br><span class="line">  	<span class="comment">// 判断数组是否为 null</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取数组最后一个数字为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = arr[arr.length - <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索小于根节点的值,并记录该结点的下标(除根节点外)</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; rootVal)&#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 搜索大于根节点的值（除根节点外）</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j &lt; arr.length - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rootVal &gt; arr[j])&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归判断左子节点的值（先判断左子节点是够有值），默认返回 true</span></span><br><span class="line">     <span class="keyword">let</span> left = <span class="literal">true</span></span><br><span class="line">     <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         left = isPostorder(arr.slice(<span class="number">0</span>, i))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果右子树不为空，判断右子树为二叉搜索树</span></span><br><span class="line">    <span class="keyword">let</span> right = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; arr.length - <span class="number">1</span>)&#123;</span><br><span class="line">        right = isPostorder(arr.slice(i,arr.length - <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (left &amp;&amp; right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="八、面试34：二叉树和为某一值路径"><a href="#八、面试34：二叉树和为某一值路径" class="headerlink" title="八、面试34：二叉树和为某一值路径"></a>八、<strong>面试34：二叉树和为某一值路径</strong></h3><blockquote>
<p> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输出整数的所有路径。从树的根节点开始往下一直到叶子节点所经过的节点形成一条路径。</p>
</blockquote>
<h4 id="一、思路-6"><a href="#一、思路-6" class="headerlink" title="一、思路"></a>一、思路</h4><p><strong>1、找规律：</strong>需要遍历树的所有结点：我们会想到前、中、后遍历</p>
<pre><code>:  需要存储遍历过的路径（节点值）：我们想到用数组存储</code></pre><p><strong>2、算法思想：</strong>前序遍历（根、左、右）的特点，从根到叶子节点，会从树自左向右依次遍历二叉树，所有可能的路径都会遍历到，所以使用前序遍历更佳。</p>
<p>每遍历一个结点就将其累加，然后判断累加的值是否等于目标值且子节点为叶子节点。如果是，则打印输出该路径；如果不是，则回退到上一父节点，此时数组中的数据结点进行删除，然后不断的遍历下一子节点，递归。</p>
<p><strong>3、综上所述，</strong>存储结点路径的时候，涉及到累加结点和删除节点，我们可以将其抽象成入栈和出栈。然后遍历二叉树的所有路径可以用到递归的过程，让出栈和入栈与递归的状态达成一致，这到题就不难了。</p>
<h4 id="二、测试用例-6"><a href="#二、测试用例-6" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树（有一条路径满足、有多条路径满足、都不满足）—— <strong>普通测试</strong>。</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个结点的二叉树 —— <strong>特殊测试</strong>。</li>
<li>空二叉树、输入负数 —— <strong>输入测试</strong>。</li>
</ul>
<h4 id="三、代码编写-3"><a href="#三、代码编写-3" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>参数：二叉树、目标值</li>
<li>判断二叉树是否为空和目标是是否是负数</li>
<li>开始进行递归遍历二叉树进行查找满足条件的路径<ul>
<li>将当前递归的根节点进行累加</li>
<li>同时该结点入栈</li>
<li></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> treeSum = <span class="function">(<span class="params">root, targetSum</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 判断输入的二叉树和整数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span> || targetSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始进行递归遍历二叉树进行查找满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> result = [];    <span class="comment">// 存放最后满足条件的路径</span></span><br><span class="line">    <span class="keyword">let</span> pathStack = []; <span class="comment">// 储存当前路径的栈</span></span><br><span class="line">    <span class="keyword">let</span> currentSum = <span class="number">0</span>; <span class="comment">// 当前累加的结果值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 进行路径查找</span></span><br><span class="line">    FindPath(root, targetSum, currentSum, pathStack, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FindPath = <span class="function">(<span class="params">root, targetSum, currentSum, pathStack, result</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="comment">// 将当前跟根节点进行累加</span></span><br><span class="line">    	currentSum = currentSum + root.val;</span><br><span class="line">    	</span><br><span class="line">      <span class="comment">// 存储栈中</span></span><br><span class="line">      pathStack.push(root.val);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 判断目标值是否相等且是否为叶子节点</span></span><br><span class="line">    	<span class="keyword">if</span>(currentSum == targetSum &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">// 打印路径</span></span><br><span class="line">          result.push(pathStack.slice(<span class="number">0</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 如果左子节点不为空</span></span><br><span class="line">      <span class="keyword">if</span>(root.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.left, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前结点还有右子树，继续遍历</span></span><br><span class="line">      <span class="keyword">if</span>(root.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">          FindPath(root.right, targetSum, currentSum, pathStack, result);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 该路径遍历到叶子节点，还没有满足条件，则退回到父节点，进行下一结点的累加判断</span></span><br><span class="line">      pathStack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h4><ul>
<li><p>当问题能够用递归去解决的时候，首先找到递归的点，比如二叉树的中的每个节点就是递归的点。</p>
</li>
<li><p>当使用递归解决满足条件的问题时，直接每层递归进行判断，如果满足条件就处理，否则，递归自动跳过 if 判断。</p>
</li>
</ul>
<h3 id="九、面试题37：序列化二叉树"><a href="#九、面试题37：序列化二叉树" class="headerlink" title="九、面试题37：序列化二叉树"></a>九、<strong>面试题37：序列化二叉树</strong></h3><p>请实现两个函数，分别用来序列化二叉树和反序列化二叉树。</p>
<h4 id="一、思路-7"><a href="#一、思路-7" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、序列化：遍历二叉树，遇到叶子节点，将其转化为 $ 表示。</p>
<p>2、反序列化：根据前序遍历的特点（根、左、右），进行二叉树的还原。</p>
<h4 id="二、测试用例-7"><a href="#二、测试用例-7" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个节点 —— 特殊测试</li>
<li>空数组、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-4"><a href="#三、代码编写-4" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><ul>
<li>序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [];</span><br><span class="line"><span class="keyword">var</span> serialize = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        result.push(<span class="string">'$'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    result.push(root.val)</span><br><span class="line">    serialize(root.left)</span><br><span class="line">    serialize(root.right)</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">serialize(symmetricalTree);</span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化二叉树</span></span><br><span class="line"><span class="keyword">var</span> deserialize = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈队判断</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> val = arr.shift();</span><br><span class="line">    <span class="keyword">if</span>(val !== <span class="string">'$'</span>)&#123;</span><br><span class="line">        node = &#123;</span><br><span class="line">            val: val</span><br><span class="line">        &#125;;</span><br><span class="line">        node.left = deserialize(arr);</span><br><span class="line">        node.right = deserialize(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'8,6,5,$,$,7,$,$,6,7,$,$,5,$,$'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(deserialize(str.split(<span class="string">','</span>)));</span><br></pre></td></tr></table></figure>



<h3 id="十、面试题54：二叉树的第-K-大节点"><a href="#十、面试题54：二叉树的第-K-大节点" class="headerlink" title="十、面试题54：二叉树的第 K 大节点"></a>十、<strong>面试题54：二叉树的第 K 大节点</strong></h3><blockquote>
<p>给定一棵二叉搜索树，请找出其中的第 K 大节点。</p>
</blockquote>
<h4 id="一、思路-8"><a href="#一、思路-8" class="headerlink" title="一、思路"></a>一、思路</h4><p>要想找到第 K 大结点必要要知道排序，二叉树的前、中、后遍历中的中序遍历就是从小到大排序。然后遍历的同时计数找到第 K 大节点。</p>
<h4 id="二、测试用例-8"><a href="#二、测试用例-8" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树 —— 特殊测试</li>
<li>K 的范围、空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-5"><a href="#三、代码编写-5" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求二叉树中第 K 大节点</span></span><br><span class="line"><span class="keyword">var</span> kthTallest = <span class="function"><span class="keyword">function</span>(<span class="params">root, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  <span class="keyword">const</span> inorder = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">      inorder(root.left);</span><br><span class="line">      res.push(root.val);</span><br><span class="line">      inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用</span></span><br><span class="line">  inorder(root);</span><br><span class="line">  <span class="keyword">return</span> res[res.length - k]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="十一、面试题55：二叉树的深度"><a href="#十一、面试题55：二叉树的深度" class="headerlink" title="十一、面试题55：二叉树的深度"></a>十一、<strong>面试题55：二叉树的深度</strong></h3><p>  输入一棵二叉树的根节点，求该树的深度。从根节点到叶子节点依次经过的节点（包含根、叶子节点）形成树的一条路径，最长路径的长度树的深度。</p>
<h4 id="一、思路-9"><a href="#一、思路-9" class="headerlink" title="一、思路"></a>一、思路</h4><p>1、思路一：按层遍历，对按层遍历的算法进行改进，每遍历一次层进行加一。</p>
<p>2、思路二：寻找最长路径，借助遍历最长路径的设计思路记性改进。只需记录两个子树最深的结点为主。</p>
<h4 id="二、测试用例-9"><a href="#二、测试用例-9" class="headerlink" title="二、测试用例"></a>二、测试用例</h4><ul>
<li>完全二叉树、非完全二叉树 —— 普通测试</li>
<li>只有左子节点、只有右子节点、只有一个结点二叉树 ——  特殊测试</li>
<li>空树 —— 输入测试</li>
</ul>
<h4 id="三、代码编写-6"><a href="#三、代码编写-6" class="headerlink" title="三、代码编写"></a>三、代码编写</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果根节点为 null </span></span><br><span class="line">    <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 递归左子树</span></span><br><span class="line">    <span class="keyword">let</span> depthLeft  = maxDepth(root.left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归右子树</span></span><br><span class="line">    <span class="keyword">let</span> depthRight  = maxDepth(root.right);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将子问题合并求总问题</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(depthLeft,depthRight) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="一、解题思路总结"><a href="#一、解题思路总结" class="headerlink" title="一、解题思路总结"></a>一、解题思路总结</h3><h4 id="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"><a href="#1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。" class="headerlink" title="1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。"></a>1、根据树前（根左右）、中（左根右）、后（左右根）序遍历的规律来解决问题。</h4><blockquote>
<p>通过二叉树的遍历来找到规律，从而找到解题思路。</p>
</blockquote>
<ul>
<li><p>重建二叉树</p>
<p>根据前、中序遍历，找到二叉树的根节点和左右子树的规律，然后递归构建二叉树。</p>
</li>
<li><p>二叉树的下一节点</p>
<p>根据中序遍历，找出包含任何节点的一下节点的所有可能情况，然后根据情况分别进行判断。</p>
</li>
<li><p>二叉树的后续遍历序列</p>
<p>通过中序遍历找到打印二叉树结点的规律，可以判断此后续遍历是否为二叉树。</p>
</li>
<li><p>二叉树和为某一值的路径</p>
<p>选择二叉树的遍历，对每个节点进行存储判断，然后根据二叉树叶子节点的特点，进行对问题的解决。</p>
</li>
<li><p>二叉树的第 K 大结点</p>
<p>中序遍历的结果是从小到大，然后倒数找到第 K 大数据。</p>
</li>
<li><p>序列化二叉树</p>
<p>遍历二叉树，遇到 null 转化为特殊符号。</p>
</li>
</ul>
<h4 id="2、根据树的结构寻找规律来解决问题"><a href="#2、根据树的结构寻找规律来解决问题" class="headerlink" title="2、根据树的结构寻找规律来解决问题"></a>2、根据树的结构寻找规律来解决问题</h4><blockquote>
<p>通过二叉树的特点：左子节点小于父节点、右子节点大于父节点、树的节点可以进行递归等，以上特点又是更好的帮我们解决思路。</p>
</blockquote>
<ul>
<li><p>树的子结构</p>
<p>根据子结构和主体树的特点，对其树的结构进行分析，可以找到解题的思路。</p>
</li>
<li><p>镜像二叉树</p>
<p>观察镜像二叉树的左右子节点交换特点，可以找到解题思路。</p>
</li>
<li><p>对称二叉树</p>
<p>观察对称二叉树有什么特点，在结构上和遍历上寻找特点和规律，可以找到解题思路。</p>
</li>
<li><p>按层遍历二叉树</p>
<p>根据二叉树每层节点的结构关系（父子关系），可以进行每层遍历，通过上层找到下层的遍历结点。</p>
</li>
<li><p>反序列化二叉树</p>
<p>根据遍历的规律和二叉树的规律，将遍历结果生成一棵二叉树。</p>
</li>
</ul>
<h3 id="二、测试用例-10"><a href="#二、测试用例-10" class="headerlink" title="二、测试用例"></a>二、测试用例</h3><p>通过以上题目中，我将测试用例分为三大种，测试代码的时候，在这三大种进行想就可以了。</p>
<ul>
<li><strong>普通测试</strong></li>
<li><strong>特殊测试</strong></li>
<li><strong>输入测试</strong></li>
</ul>
<h4 id="1、普通测试"><a href="#1、普通测试" class="headerlink" title="1、普通测试"></a>1、普通测试</h4><p>普通测试从两个方面去想，第一个方面就是问题的本身，比如对称二叉树的判断，普通测试就是分别输入一个对称二叉树和非对称二叉树进行测试。第二个方面就是问题本身没有什么可以找到的测试，比如按层遍历二叉树，它的普通测试就是分别输入完全二叉树（普通二叉树也可以），非完全二叉树进行测试。</p>
<h4 id="2、特殊测试"><a href="#2、特殊测试" class="headerlink" title="2、特殊测试"></a>2、特殊测试</h4><p>特殊测试强调的是树的特殊性，特殊的二叉树就那么几个，比如：只有左子节点的二叉树、只有右子节点的二叉树、只有一个节点的二叉树、没有结点的二叉树。</p>
<h4 id="3、输入测试"><a href="#3、输入测试" class="headerlink" title="3、输入测试"></a>3、输入测试</h4><p>输入测试，顾名思义，要对用户输入的参数进行判断，比如，你输入一棵树，要判断是否为空。再比如，求最大 K 结点，对 K 的取值范围进行判断。</p>
<h3 id="三、代码编写-7"><a href="#三、代码编写-7" class="headerlink" title="三、代码编写"></a>三、代码编写</h3><p>将二叉树的解题思路转化为代码除了熟练最基本的二叉树的增、删、改、查之外，最重要的就是二叉树的递归，因为二叉树的结构决定了用递归解决二叉树问题更加简便。但是递归的书写并不仅简单，因为它有递和归的过程，大脑并不能更好的去处理这些，可以去看之前总结递归的文章《<a href="https://github.com/luxiangqiang/Blog/blob/master/articel/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97.md" target="_blank" rel="noopener">数据结构与算法之递归系列</a>》。</p>
<p>书写二叉树递归问题有一点特别重要，不要尝试的去想那个递归的过程，而是先去寻找到递归的终止条件，然后对每次递归的结果进行判断，然后让他递归去吧，再次强调千万别去思考过程。</p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法之递归系列</title>
    <url>/2020/02/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97/</url>
    <content><![CDATA[<h1 id="数据结构与算法之递归系列"><a href="#数据结构与算法之递归系列" class="headerlink" title="数据结构与算法之递归系列"></a>数据结构与算法之递归系列</h1><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E5%AF%BC%E5%9B%BE.jpg" alt></p>
<br>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97%E7%9B%AE%E5%BD%95.png" alt></p>
<br>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几个月之前就想写这样一篇文章分享给大家，由于自己有心而力不足，没有把真正的学到的东西沉淀下来，所以一直在不断的自学。可能是因为在一所三流大学，资源也比较少，只能自己在网搜索相关资料，在互联网上遇到了一些朋友的帮助下去深入理解，然后自己抽出大量时间做题总结、归纳，才会把已有的知识概念所被自己吸收和理解，形成了自己的技术思想体系。</p>
<p>然后自己又用了一个星期的时间去整理、分类，才有了这篇 8000 字有关递归知识的分享，希望能够帮助正在学习递归的小伙伴们。而且有了这篇文章的支撑和动力，往后还会写出关于数据结构与算法一些难懂的概念简单化。如果文章中有错误的地方，希望大家指正，能够为他人分享出更有质量的内容！</p>
<br>

<h2 id="为什么要写这篇递归文章"><a href="#为什么要写这篇递归文章" class="headerlink" title="为什么要写这篇递归文章"></a>为什么要写这篇递归文章</h2><p>看了很多关于递归的文章，也总结了很多递归的文章，也看了多篇文章下方读者的评论。有的读者评论到文章清晰易懂，有的却喷作者写的存在很多错误，埋怨作者写出来很垃圾，还不如不写。我想从理性的角度说一下，创作者写文章的最初好意是能够帮助别人对此知识点有进一步的了解，并不代表一定能够满足每个人的要求。</p>
<p>另一方面，每篇文章的作者可能理解的不够透彻，很多地方可能存在许多错误，包括理解上的错误，笔误等，这也是写文章的第二个目的，能够让别人挑出自己文章中的不足，能够达到与别人共同进步的目的，一举两得，两全其美。</p>
<p>接下来分享的文章是关于递归的，这篇文章不单单分享递归的一切，我觉得更重要的是向每位读者传递一个思想。思想？对的，没错！这篇文章不能说包含递归的边边角角，但是通过自己的理论上的学习和实践，有了自己的一套递归思想。</p>
<p>什么问题该用递归，什么问题用递归简洁，什么问题就不能使用递归解决，以及对于特定的问题用递归解决的陷阱，能不能进一步对递归进行二次优化，这些都是今天小鹿分享的内容。</p>
<br>

<h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><blockquote>
<p>递归，顾名思义，有递有归才叫递归，有递无归，有归无递那叫 “耍流氓” 。</p>
</blockquote>
<br>

<h2 id="为什么要学习递归？"><a href="#为什么要学习递归？" class="headerlink" title="为什么要学习递归？"></a>为什么要学习递归？</h2><p>我们学习一门技术也好，编程语言也好，首先学习之前我们知道它将能给我们带来什么，能帮助我们解决什么样的问题，这也是激励我们去学习它的动力所在。</p>
<p>从数组到链表、散列表，再到基本算法等，直到遇到递归之后，感觉非常的难理解。我相信每个人都有这种感觉，一开始觉得非常难，经历了九九八十一难之后，还是没有弄懂递归里边的猫腻，然后就自然而然的跳过了。</p>
<p>后来我就开始刷了一个月的 LeetCode 题，发现递归在数据结构与算法中有着一席之地，统治着江山。大部分的题都可以用递归去解决，如：二叉树的遍历、回溯算法、0-1 背包问题、深度优先遍历、回溯算法等等，我整理了至少二三十到关于递归的题，才发现递归的重要性，所以不得不重新深入递归学习，所有有了今天这篇文章。</p>
<br>

<h2 id="怎么理解递归的过程？"><a href="#怎么理解递归的过程？" class="headerlink" title="怎么理解递归的过程？"></a>怎么理解递归的过程？</h2><blockquote>
<p>上方我对递归“耍流氓”式的定义并不能让你准确的理解递归是什么，那么我们就来活生生的举个生活中的例子。</p>
</blockquote>
<br>

<h4 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h4><blockquote>
<p>比如你和小鹿我一样，在大学里喜欢插队打饭（作为一个三好学生，我怎么能干这种事呢？哈哈），那么队伍后边的同学本数着自己前边还有 5 个同学就改轮到自己了，由于前边同学不断的插队，这时他发现，怎么觉得自己离着打饭的窗口越来越远呢？这时如果他想知道自己在队队列中的的第几个（前提是前边不再有人插队），用递归思想来解决，我们怎么做呢？</p>
</blockquote>
<br>

<h4 id="2、“递”"><a href="#2、“递”" class="headerlink" title="2、“递”"></a>2、“递”</h4><blockquote>
<p>于是他问前边的同学是第几位，前边的同学也不只到呀，于是前边的同学问他前边的同学是第几位，直到前边第二个同学问到第一个正在打饭的同学是队伍的第几个（有点小尴尬）。打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？<strong>这个过程其实是就是一个递归中“递”的过程</strong>。</p>
</blockquote>
<br>

<h4 id="3、“归”"><a href="#3、“归”" class="headerlink" title="3、“归”"></a>3、“归”</h4><blockquote>
<p>然后前边打饭的第二个同学不耐烦的又告诉第三个同学，我是第二个，没看单我前边有个家伙正在打饭吗？然后第三个传给第四个，以后往后传，直到那位逐渐远离窗口的同学的前一个人告诉他是第几个之后，他知道了自己目前在队伍中的第几个位置。<strong>这个过程我们可以理解为递归中“归”的过程</strong>。</p>
</blockquote>
<br>

<h4 id="4、终止条件"><a href="#4、终止条件" class="headerlink" title="4、终止条件"></a>4、终止条件</h4><blockquote>
<p>“打饭的同学不耐烦的说，没看到我是第一个正在打饭吗？”，在递归中，我们称为<strong>终止条件</strong>。</p>
</blockquote>
<br>

<h4 id="5、怎么理解递归？"><a href="#5、怎么理解递归？" class="headerlink" title="5、怎么理解递归？"></a>5、怎么理解递归？</h4><blockquote>
<p>1）问题虽然是层层递归的分析，但是用程序表示的时候，不要层层的在大脑中调用递归代码去想，这样可能会使你完全陷入到 “递” 的过程中去，“归” 的时候，归不出来了，这些都是我们交给计算机干的事情。</p>
<p>2）那我们在写程序的时候怎么理解递归呢？我们只找问题之间存在的关系，<strong>屏蔽掉递归的细节</strong>，具体看（五）分析。</p>
</blockquote>
<br>

<h2 id="满足递归的三个条件"><a href="#满足递归的三个条件" class="headerlink" title="满足递归的三个条件"></a>满足递归的三个条件</h2><blockquote>
<p>通过上方的例子，我们可以很容易的总结出满足递归的三个条件。</p>
</blockquote>
<br>

<h4 id="1、一个问题能不能分解成多个子问题来解决"><a href="#1、一个问题能不能分解成多个子问题来解决" class="headerlink" title="1、一个问题能不能分解成多个子问题来解决"></a>1、一个问题能不能分解成多个子问题来解决</h4><blockquote>
<p>想知道自己在队伍中的位置，将其问题分解为“每个人所处队伍中的位置”这样的多个子问题。</p>
</blockquote>
<br>

<h4 id="2、该问题是否和子问题的解决思路相同"><a href="#2、该问题是否和子问题的解决思路相同" class="headerlink" title="2、该问题是否和子问题的解决思路相同"></a>2、该问题是否和子问题的解决思路相同</h4><blockquote>
<p>想要知道自己当前的位置，就要问前边人所处的位置。那么前边人想要知道自己所处的位置，就要知道他前边人的位置。所以说，该问题和子问题的解决思路相同，满足第二个条件。</p>
</blockquote>
<br>

<h4 id="3、该问题是否有终止条件"><a href="#3、该问题是否有终止条件" class="headerlink" title="3、该问题是否有终止条件"></a>3、该问题是否有终止条件</h4><blockquote>
<p>第一个正在打饭的同学说自己是队伍中的第一人，这就是所谓的终止条件，找到终止条件之后就开始进行“归”的过程。</p>
</blockquote>
<br>

<h2 id="怎么编写递归代码？"><a href="#怎么编写递归代码？" class="headerlink" title="怎么编写递归代码？"></a>怎么编写递归代码？</h2><blockquote>
<p>如果你对递归有了一定的了解，上边的例子对你来说小菜一碟，下边还有更大的难度来进行挑战。那么问题分析清楚了，怎么根据问题编写出递归代码来呢？</p>
</blockquote>
<br>

<h4 id="1、写出递推公式"><a href="#1、写出递推公式" class="headerlink" title="1、写出递推公式"></a>1、写出递推公式</h4><blockquote>
<p>写递归公式最重要的一点就是找到该问题和子问题的关系，怎么找到之间存在的关系呢？这里我要强调注意的一点就是不要让大脑试图去想层层的递归过程，毕竟大脑的思考方式是顺势思考的（一开始学习递归总是把自己绕绕进去，归的时候，就完全乱套的）。那怎么找到每个子问题之间存在的某种关系呢？</p>
</blockquote>
<p>我们只想其中一层（第一层关系），以上述为例，如果我想知道当前队伍的位置，所以我要之前前一个人的位置，然后 <code>+1</code> 就是我的位置了。对于他在什么位置，我丝毫不用关系，而是让递归去解决他的位置。我们可以写出递推公式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f(n) 代表当前我在队伍中的位置</span></span><br><span class="line"><span class="comment">// f(n-1) 代表我前边那个人的位置</span></span><br><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>※ 注意：</strong>这个式子的含义就是 <code>f(n)</code> 求当前 n 这个人的位置， <code>f(n-1) + 1</code> 代表的就是前一个人的位置 <code>+ 1</code> 就是 <code>n</code> 的位置。</p>
</blockquote>
<br>

<h4 id="2、找到终止条件"><a href="#2、找到终止条件" class="headerlink" title="2、找到终止条件"></a>2、找到终止条件</h4><blockquote>
<p>递推公式我们很轻松的写出来了，但是没有终止条件的递推公式会永远的执行下去的，所以我们要有一个终止条件终止程序的运行。那么怎么找到终止条件呢？</p>
</blockquote>
<p>所谓的终止条件就是已知的条件，比如上述的排队打饭的例子中，第一个人正在窗口打饭，他的前边是没有人的，所以他是第一个。第一个人的位置为 1，我们应该怎么表示呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>※ 注意：</strong>有的问题终止条件不止一个哦，比如：斐波那契数列。具体问题具体分析。</p>
</blockquote>
<br>

<h4 id="3、转换递归代码"><a href="#3、转换递归代码" class="headerlink" title="3、转换递归代码"></a>3、转换递归代码</h4><blockquote>
<p>递推公式和终止条件我们分析出来了，那么将递推公式转化为递归代码非常容易了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="递归的分类"><a href="#递归的分类" class="headerlink" title="递归的分类"></a>递归的分类</h2><blockquote>
<p>通过做大量的题，根据递归解决不同的问题，引申出来的几种解决和思考的方式。之所以将其分类，是为了能够更好的理解递归在不同的问题下起着什么作用，如：每层递归之间存在的关系、计算，以及递归枚举所有情况和面临选择性问题的递归。虽然分为了几类，但是递归的本质是一成不变的。</p>
</blockquote>
<br>

<h4 id="分类一：递归计算型"><a href="#分类一：递归计算型" class="headerlink" title="分类一：递归计算型"></a>分类一：递归计算型</h4><blockquote>
<p>将哪一类用递归解决的问题作为计算型呢？我简单总结了为两点，<strong>层层计算和并列计算</strong>。</p>
</blockquote>
<br>

<h5 id="1、层层计算"><a href="#1、层层计算" class="headerlink" title="1、层层计算"></a>1、层层计算</h5><blockquote>
<p>层层计算，顾名思义，能够用递归解决的问题都可以分为多个子问题，我们把每个子问题可以抽象成一层，子问题之间的关系可以表示为层与层之间的关系。我们通过层与层之间的计算关系用递推公式表达出来做计算，经过层层的递归，最终得到结果值。</p>
</blockquote>
<br>

<p><strong>▉ 例子：</strong></p>
<blockquote>
<p>我们再那上方排队打饭的例子来说明，我们的子问题已经分析出来了，就是我想知道当前在队伍中的位置，就是去问我前边人的位置加一就是我当前队伍的位置，这为一层。而前边这个人想知道当前自己的位置，需要用同样的解决思路，作为另一层。</p>
</blockquote>
<p>层与层之间的关系是什么（我当前队伍中的位置与前边人的位置存在什么样的关系）？这时你会说，当前是 <code>+1</code>。这个大部分人都很容易找出，既然关系确定了，然后通过递推公式很容易写出递归代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f(n) 为我所在的当前层</span></span><br><span class="line"><span class="comment">// f(n-1) 为我前边的人所在的当前层</span></span><br><span class="line"><span class="comment">// + 1 是层与层之间的计算关系</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结：</strong></p>
<blockquote>
<p>我将以上一类递归问题命名为「递归计算型」的「层层计算类型」。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>求年龄的问题也是层层计算类型的问题，自己尝试分析一下（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p>
<p><strong>问题一：</strong>有 5 个人坐在一起，问第 5 个人多少岁，他说比第 4 个人大 2 岁。问第 4 个人多少岁，他说比第 3 个人大2岁。问第 3 人多少岁，他说比第 2个 人大 2 岁。问第2个人多少岁，他说比第 1 个人大 2 岁。最后问第 1 个人，他说他是 10 岁。编写程序，当输入第几个人时求出其对应的年龄。</p>
<p><strong>问题二：</strong>单链表从尾到头一次输出结点值，用递归实现。</p>
</blockquote>
<br>

<h5 id="2、并列计算"><a href="#2、并列计算" class="headerlink" title="2、并列计算"></a>2、并列计算</h5><blockquote>
<p>并列计算，顾名思义，问题的解决方式是通过递归的并列计算来得到结果的。层与层之间并没有一定的计算关系，而只是简单的改变输入的参数值。</p>
</blockquote>
<br>

<p><strong>▉ 例子：</strong></p>
<blockquote>
<p>最经典的题型就是<strong>斐波那契数列</strong>。观察这样一组数据 0、 1、1、2、3、5、8、13、21、34…，去除第一个和第二个数据外，其余的数据等于前两个数据之和（如：<code>2 = 1 + 1</code>，<code>8 = 3 + 5</code>，<code>34 = 21 + 13</code>）。你可以尝试着根据「满足递归的三个条件」以及「怎么写出递归代码」的步骤自己动手动脑亲自分析一下。</p>
</blockquote>
<p>我也在这里稍微做一个分析。</p>
<p>1）第一步：首先判断能不能将问题分解为多个子问题，上边我也分析过了，除了第一个和第二个数据，其他数据是前两个数据之和。那么前两个数据怎么知道呢？同样的解决方式，是他们前两个数之和。</p>
<p>2）第二步：找到终止条件，如果不断的找到前两个数之和，直到最前边三个数据 <code>0、1、1</code> 。如果递归求第一个 1 时，前边的数据不够，所以这也是我们找到的终止条件。</p>
<p>3）第三步：既然我们终止条件和关系找到了，递推公式也就不难写出 <code>f(n) = f(n-1) + f(n-2)</code>（n 为要求的第几个数字的值）。</p>
<p>4）转化为递归代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结：</strong></p>
<blockquote>
<p>我将上方的问题总结为并列计算型。也可以归属为层层计算的一种，只不过是 + 1 改成了加一个 f 函数自身的递归（说白了，递归的结果也是一个确切的数值）。之所谓并列计算 <code>f(n-1)</code> 和 <code>f(n-2)</code> 互不打扰，各自递归计算各的值。最后我们将其计算的结果值相加是我们最想要的结果。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>青蛙跳台阶的问题也是一种并列计算的一种，自己尝试着根据上边的思路分析一下，实践出真知（一定要自己尝试的去想，动手编码，才能进一步领悟到递归技巧）。</p>
<p><strong>问题：</strong></p>
<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上2 级。求该青蛙跳上一个n 级的台阶总共有多少种跳法。</p>
</blockquote>
<br>

<h4 id="分类二：递归枚举型"><a href="#分类二：递归枚举型" class="headerlink" title="分类二：递归枚举型"></a>分类二：递归枚举型</h4><blockquote>
<p>递归枚举型最多的应用就是回溯算法，枚举出所有可能的情况，怎么枚举所有情况呢？通过递归编程技巧进行枚举。那什么是回溯算法？比如走迷宫，从入口走到出口，如果遇到死胡同，需要回退，退回上一个路口，然后走另一岔路口，重复上述方式，直到找到出口。</p>
</blockquote>
<p>回溯算法最经典的问题又深度优先遍历、八皇后问题等，应用非常广泛，下边以八皇后问题为例子，展开分析，其他利用递归枚举型的回溯算法就很简单了。</p>
<br>

<h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><blockquote>
<p>在 8 X 8 的网格中，放入八个皇后（棋子），满足的条件是，任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，问有多少种摆放方式？</p>
</blockquote>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E6%AD%A3%E7%A1%AE.png" alt></p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98error.png" alt></p>
<p><strong>▉ 问题分析：</strong></p>
<blockquote>
<p>要想满足任意两个皇后（棋子）都不能处于同一行、同一列或同一斜线上，需要一一枚举皇后（棋子）的所有摆放情况，然后设定条件，筛选出满足条件的情况。</p>
</blockquote>
<br>

<p><strong>▉ 算法思路：</strong></p>
<blockquote>
<p>我们把问题分析清楚了之后，怎么通过递归实现回溯算法枚举八个皇后（棋子）出现的所有情况呢？</p>
<p>1）我们在 8 X 8 的网格中，先将第一枚皇后（棋子）摆放到第一行的第一列的位置（也就是坐标: (0,0)）。</p>
<p>2）然后我们在第二行安置第二个皇后（棋子），先放到第一列的位置，然后判断同一行、同一列、同一斜线是否存在另一个皇后？如果存在，则该位置不合适，然后放到下一列的位置，然后在判断是否满足我们设定的条件。</p>
<p>3）第二个皇后（棋子）找到合适的位置之后，然后在第三行放置第三枚棋子，依次将八个皇后放到合适的位置。</p>
<p>4）这只是一种可能，因为我设定的第一个皇后是固定位置的，在网格坐标的（0,0） 位置，那么怎么枚举所有的情况呢？然后我们不断的改变第一个皇后位置，第二个皇后位置…… ，就可以枚举出所有的情况。如果你和我一样，看了这个题之后，如果还有点懵懵懂懂，那么直接分析代码吧。</p>
</blockquote>
<br>

<p><strong>▉ 代码实现：</strong></p>
<blockquote>
<p>虽然是用 <code>javascript</code> 实现的代码，相信学过编程的小伙伴基本的代码逻辑都可以看懂。根据上方总结的递归分析满足的三个条件以及怎么写出递归代码的步骤，一步步来分析八皇后问题。</p>
</blockquote>
<br>

<p><strong>1、将问题分解为多个子问题</strong></p>
<blockquote>
<p>在上述的代码分析和算法思路分析中，我们可以大体知道怎么分解该问题了，枚举出八个皇后（棋子）所有的满足情况可以分解为，先寻找每一种满足的情况这种子问题。比如，每个子问题的算法思路就是上方列出的四个步骤。</p>
</blockquote>
<br>

<p><strong>2、找出终止条件</strong></p>
<blockquote>
<p>当遍历到第八行的时候，递归结束。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 打印第 n 种满足的情况</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>3、写出递推公式</strong></p>
<blockquote>
<p><code>isOkCulomn()</code> 函数判断找到的该位置是否满足条件（不能处于同一行、同一列或同一斜线上）。如果满足条件，我们返回 <code>true</code>，进入 <code>if</code> 判断，<code>row</code>行数加一传入进行递归下一行的皇后位置。直至递归遇到终止条件位置，<code>column ++</code>，将第一行的皇后放到下一位置，进行继续递归，枚举出所有可能的摆放情况。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一列的判断</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">    <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">    <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">        <span class="comment">// 保存皇后的位置</span></span><br><span class="line">        result[row] = column;</span><br><span class="line">        <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">        cal8queens(row + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 左上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 右上角列的位置</span></span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p><strong>4、转换为递归代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 变量</span></span><br><span class="line"><span class="comment">// result 为数组，下标为行，数组中存储的是每一行中皇后的存储的列的位置。</span></span><br><span class="line"><span class="comment">// row 行  </span></span><br><span class="line"><span class="comment">// column 列</span></span><br><span class="line"><span class="comment">// n 计数满足条件的多少种</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> cal8queens = <span class="function">(<span class="params">row</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(row === <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; column++)&#123;</span><br><span class="line">        <span class="comment">// 判断当前的列位置是否合适</span></span><br><span class="line">        <span class="keyword">if</span>(isOkCulomn(row,column))&#123;</span><br><span class="line">            <span class="comment">// 保存皇后的位置</span></span><br><span class="line">            result[row] = column;</span><br><span class="line">            <span class="comment">// 对下一行寻找数据</span></span><br><span class="line">            cal8queens(row + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此循环结束后,继续遍历下一种情况,就会形成一种枚举所有可能性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前列是否合适</span></span><br><span class="line"><span class="keyword">const</span> isOkCulomn = <span class="function">(<span class="params">row,column</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 设置左上角</span></span><br><span class="line">    <span class="keyword">let</span> leftcolumn = column - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> rightcolumn = column + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 判断当前格子正上方是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(result[i] === column) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格子左上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === leftcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前格式右上角是否有重复</span></span><br><span class="line">        <span class="keyword">if</span>(leftcolumn &lt; <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === rightcolumn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续遍历</span></span><br><span class="line">        leftcolumn --;</span><br><span class="line">        rightcolumn ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归打印所有情况</span></span><br><span class="line"><span class="keyword">const</span> print = <span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result[i] === j)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'Q'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'*'</span> + <span class="string">' '</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">cal8queens(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(n)</span><br></pre></td></tr></table></figure>

<br>

<p><strong>▉ 总结</strong></p>
<blockquote>
<p>上述八皇后的问题就是用递归来枚举所有情况，然后再从中设置条件，只筛选满足条件的选项。上述代码建议多看几遍，亲自动手实践一下。一开始解决八皇后问题，我自己看了好长时间才明白的，以及递归如何发挥技巧作用的。</p>
</blockquote>
<br>

<p><strong>▉ 举一反三：</strong></p>
<blockquote>
<p>如果你想练练手，可以自己实现图的深度优先遍历，这个理解起来并不难，可以自己动手尝试着写一写，我把代码传到我的 <code>Github</code> 上了。</p>
</blockquote>
<br>

<h4 id="分类三：递归选择型"><a href="#分类三：递归选择型" class="headerlink" title="分类三：递归选择型"></a>分类三：递归选择型</h4><blockquote>
<p>所谓的递归选择型，每个子问题都要面临选择，求最优解的情况。有的小伙伴会说，求最优解动态规划最适合，对的，没错，但是递归通过选择型「枚举所有情况」，设置条件，求得问题的最优解也是可以实现的，所有我呢将其这一类问题归为递归选择型问题，它也是一个回溯算法。</p>
</blockquote>
<br>

<h5 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0 -1 背包问题"></a>0 -1 背包问题</h5><blockquote>
<p><code>0 - 1</code> 背包问题，了解过的小伙伴也是很熟悉的了。其实这个问题也属于回溯算法的一种，废话不多说，直接上问题。有一个背包，背包总的承载重量是 <code>Wkg</code>。现在我们有 <code>n</code> 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p>
</blockquote>
<br>

<p><strong>▉ 问题分析：</strong></p>
<blockquote>
<p>如果你对该问题看懵了，没关系，我们一点点的分析。假如每个物品我们有两种状态，总的装法就有 <code>2^n</code>种，怎么才能不重复的穷举这些可能呢？</p>
</blockquote>
<br>

<p><strong>▉ 算法思路：</strong></p>
<blockquote>
<p>我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。</p>
</blockquote>
<br>

<p>▉ <strong>代码实现：</strong></p>
<blockquote>
<p>这里有个技巧就是设置了条件，自动筛选掉不满足条件的情况，提高了程序的执行效率。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存储背包中承受的最大重量</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line"><span class="comment">// i: 对第 i 个物品做出选择</span></span><br><span class="line"><span class="comment">// currentw: 当前背包的总重量</span></span><br><span class="line"><span class="comment">// goods：数组，存储每个物品的质量</span></span><br><span class="line"><span class="comment">// n: 物品的数量</span></span><br><span class="line"><span class="comment">// weight: 背包应承受的重量</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">i, currentw, goods, n, weight</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(currentw === weight || i === n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentw &gt; max)&#123;</span><br><span class="line">            <span class="comment">// 保存满足条件的最大值</span></span><br><span class="line">            max = currentw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择跳过当前物品不装入背包</span></span><br><span class="line">    f(i+<span class="number">1</span>, currentw, goods, n, weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前物品装入背包</span></span><br><span class="line">    <span class="comment">// 判断当前物品装入背包之前是否超过背包的重量,如果已经超过当前背包重量，就不要就继续装了</span></span><br><span class="line">    <span class="keyword">if</span>(currentw + goods[i] &lt;= weight)&#123;</span><br><span class="line">        f(i+<span class="number">1</span> ,currentw + goods[i], goods, n, weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">f(<span class="number">0</span>,<span class="number">0</span>,a,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></table></figure>

<br>

<h2 id="递归的缺点"><a href="#递归的缺点" class="headerlink" title="递归的缺点"></a>递归的缺点</h2><blockquote>
<p>虽然递归的使用非常的简洁，但是也有很多缺点，也是我们在使用中需要额外注意的地方和优化的地方。</p>
</blockquote>
<br>

<h4 id="1、递归警惕堆栈溢出"><a href="#1、递归警惕堆栈溢出" class="headerlink" title="1、递归警惕堆栈溢出"></a>1、递归警惕堆栈溢出</h4><blockquote>
<p>你可能会问，递归和系统中的堆栈有什么关联？不要急，听我慢慢细说。</p>
</blockquote>
<br>

<h5 id="▉-理解堆栈溢出"><a href="#▉-理解堆栈溢出" class="headerlink" title="▉ 理解堆栈溢出"></a>▉ 理解堆栈溢出</h5><blockquote>
<p>1）递归的本质就是重复调用本身的过程，本身是什么？当然是一个函数，那好，函数中有参数以及一些局部的声明的变量，相信很多小伙伴只会用函数，而不知道函数中的变量是怎么存储的吧。没关系，等你听我分析完，你就会了。</p>
<p>2）函数中变量是存储到系统中的栈中的，栈数据结构的特点就是先进后出，后进先出。一个函数中的变量的使用情况就是随函数的声明周期变化的。当我们执行一个函数时，该函数的变量就会一直不断的压入栈中，当函数执行完毕销毁的时候，栈内的元素依次出栈。还是不懂，没关系，看下方示意图。</p>
<p>3）我们理解了上述过程之后，回到递归上来，我们的递归调用是在函数里调用自身，且当前函数并没有销毁，因为当前函数在执行自身层层递归进去了，所以递归的过程，函数中的变量一直不断的压栈，由于我们系统栈或虚拟机栈空间是非常小的，当栈压满之后，再压时，就会导致堆栈溢出。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E5%87%BD%E6%95%B0%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88.png" alt></p>
<h5 id="▉-解决办法"><a href="#▉-解决办法" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote>
<p>那么遇到这种情况，我们怎么解决呢？</p>
</blockquote>
<p>通常我们设置递归深度，简单的理解就是，如果递归超过我们设置的深度，我们就退出，不再递归下去。还是那排队打饭的例子，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示递归深度变量</span></span><br><span class="line"><span class="keyword">let</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	depth++；</span><br><span class="line">    <span class="comment">// 如果超过递归深度，抛出错误</span></span><br><span class="line">	<span class="keyword">if</span>(depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> <span class="string">'error'</span>;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) retun <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">	<span class="keyword">return</span> f(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、递归警惕重复元素"><a href="#2、递归警惕重复元素" class="headerlink" title="2、递归警惕重复元素"></a>2、递归警惕重复元素</h4><blockquote>
<p>有些递归问题中，存在重复计算问题，比如求斐波那契数列，我们画一下递归树如下图，我们会发现有很多重复递归计算的值，重复计算会导致程序的时间复杂度很高，而且是指数级别的，导致我们的程序效率低下。</p>
</blockquote>
<p>如下图递归树中，求斐波那契数列 <code>f(5)</code>的值，需要多次递归求 <code>f(3)</code> 和 <code>f(2)</code> 的值。</p>
<p><img src="https://github.com/luxiangqiang/Blog/blob/master/images/%E9%80%92%E5%BD%92%E6%A0%91%E9%87%8D%E5%A4%8D.png" alt></p>
<h5 id="▉-解决办法-1"><a href="#▉-解决办法-1" class="headerlink" title="▉ 解决办法"></a>▉ 解决办法</h5><blockquote>
<p>重复计算问题，我们应该怎么解决？有的小伙伴想到了，我们把已经计算过的值保存起来，每次递归计算之前先检查一下保存的数据有没有该数据，如果有，我们拿出来直接用。如果没有，我们计算出来保存起来。一般我们用散列表来保存。（所谓的散列表就是键值对的形式，如 map ）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列改进后</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果散列表中存在当前计算的值，就直接返回，不再进行递归计算</span></span><br><span class="line">    <span class="keyword">if</span>(map.has(n))&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递推公式</span></span><br><span class="line">    <span class="keyword">let</span> num = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 将当前的值保存到散列表中</span></span><br><span class="line">    map.set(n,num)</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3、递归高空间复杂度"><a href="#3、递归高空间复杂度" class="headerlink" title="3、递归高空间复杂度"></a>3、递归高空间复杂度</h4><blockquote>
<p>因为递归时函数的变量的存储需要额外的栈空间，当递归深度很深时，需要额外的内存占空间就会很多，所以递归有非常高的空间复杂度。</p>
</blockquote>
<p>比如：<code>f(n) = f(n-1)+1</code> ，空间复杂度并不是 <code>O(1)</code>，而是 <code>O(n)</code> 。</p>
<br>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>我们一起对递归做一个简单的总结吧，如果你还是没有完全明白，没关系，多看几遍，说实话，我这个人比较笨，前期看递归还不知道看了几十遍才想明白，吃饭想，睡觉之前想，相信最后总会想明白的。</p>
</blockquote>
<h4 id="1、满足递归的三个条件"><a href="#1、满足递归的三个条件" class="headerlink" title="1、满足递归的三个条件"></a>1、满足递归的三个条件</h4><ul>
<li>一个问题能不能分解成多个子问题来解决；</li>
<li>该问题是否和子问题的解决思路相同；</li>
<li>该问题是否有终止条件。</li>
</ul>
<h4 id="2、怎么写出递归代码"><a href="#2、怎么写出递归代码" class="headerlink" title="2、怎么写出递归代码"></a>2、怎么写出递归代码</h4><ul>
<li>寻找递归终止条件；</li>
<li>写出递推公式；</li>
<li>转化成递归代码。</li>
</ul>
<h4 id="3、怎么理解递归？"><a href="#3、怎么理解递归？" class="headerlink" title="3、怎么理解递归？"></a>3、怎么理解递归？</h4><blockquote>
<p>不要用大脑去想每一层递归的实现，记住这是计算机应该做的事情，我们要做的就是弄懂递归之间的关系，从而屏蔽掉层层递归的细节。</p>
</blockquote>
<h4 id="4、递归的缺点"><a href="#4、递归的缺点" class="headerlink" title="4、递归的缺点"></a>4、递归的缺点</h4><ul>
<li>递归警惕堆栈溢出</li>
<li>递归警惕重复计算</li>
<li>递归的高空间复杂度</li>
</ul>
<br>

<h2 id="最后想说的话"><a href="#最后想说的话" class="headerlink" title="最后想说的话"></a>最后想说的话</h2><p>最后可能说的比较打鸡血，很多人一遇到递归就会崩溃掉，比如我，哈哈。无论以后遇到什么困难，不要对它们产生恐惧，而是当做一种挑战，当你经过长时间的战斗，突破层层困难，最后突破挑战的时候，你会感激曾经的自己当初困难面前没有放弃。这一点我深有感触，有时候对于难题感到很无助，虽然自己没有在一所好的大学，没有好的资源，更没有人去专心的指导你，但是我一直相信这都是老天给我发出的挑战书，我会继续努力，写出更多高质量的文章。</p>
<p><strong>如果觉得本文对你有帮助，点个赞，我希望能够让更多处在递归困惑的人看到，谢谢各位支持！</strong>下一篇我打算出一篇完整关于链表的文章，终极目标：将数据结构与算法每个知识点写成一系列的文章。</p>
<hr>
**作者：**小鹿

<p><strong>座右铭：</strong>追求平淡不平凡，一生追求做一个不甘平凡的码农!</p>
<p><strong>本文首发于 Github ，转载请说明出处：</strong><a href="https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之递归系列.md" target="_blank" rel="noopener">https://github.com/luxiangqiang/Blog/blob/master/articel/数据结构与算法系列/数据结构与算法之递归系列.md</a></p>
<p><strong>个人公众号：一个不甘平凡的码农。</strong></p>
<h3 id="其他链接："><a href="#其他链接：" class="headerlink" title="其他链接："></a>其他链接：</h3><h4 id="1、LeetCode-30-道经典题详细解析"><a href="#1、LeetCode-30-道经典题详细解析" class="headerlink" title="1、LeetCode 30 道经典题详细解析"></a><a href="https://github.com/luxiangqiang/JS-LeetCode" target="_blank" rel="noopener">1、LeetCode 30 道经典题详细解析</a></h4><h4 id="2、Github：入门必会的基本数据结构与算法代码剖析"><a href="#2、Github：入门必会的基本数据结构与算法代码剖析" class="headerlink" title="2、Github：入门必会的基本数据结构与算法代码剖析"></a><a href="https://github.com/luxiangqiang/Data-Structure-Coding" target="_blank" rel="noopener">2、Github：入门必会的基本数据结构与算法代码剖析</a></h4><h4 id="3、Github：公众号留言小程序开源项目"><a href="#3、Github：公众号留言小程序开源项目" class="headerlink" title="3、Github：公众号留言小程序开源项目"></a><a href="https://github.com/luxiangqiang/WeiXin_MessageApplet" target="_blank" rel="noopener">3、Github：公众号留言小程序开源项目</a></h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号开发Bug调试记录</title>
    <url>/2020/02/15/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91Bug%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="公众号基本信息："><a href="#公众号基本信息：" class="headerlink" title="公众号基本信息："></a>公众号基本信息：</h3><p>公众号名称：         大连拓扑伟业<br>公众号appId：        wxb6c7348e50d2d85b<br>公众号AppSecre：     38087a07eea5992e85cdc4172d3750ad   </p>
<h6 id="记录时间：2019-12-03-15-06"><a href="#记录时间：2019-12-03-15-06" class="headerlink" title="记录时间：2019/12/03 15:06"></a>记录时间：2019/12/03 15:06</h6><hr>
<p>==bug出错描述：==</p>
<ol>
<li>扫码绑定未能加载出二维码</li>
<li>加载出二维码微信扫码后无反应</li>
<li>出错解决办法：</li>
<li>F12查看调用接口是否正确</li>
<li>服务器上相关网站的配置是否正确：</li>
<li>heuwx.topedusoft.com：appsetting.json，</li>
<li>heuwxapi.topedusoft.com：web.config，db.config，</li>
<li>heuweb.topedusoft.com：web.config，global.js，custom.js</li>
<li>网络过慢，重启IIS或重启远程服务器（本次扫码后无反应，重启服务器后好使）</li>
</ol>
<h6 id="记录时间：2019-12-04-16-00"><a href="#记录时间：2019-12-04-16-00" class="headerlink" title="记录时间：2019/12/04 16:00"></a>记录时间：2019/12/04 16:00</h6><hr>
<p>==海事局问题：==</p>
<ol>
<li>文章点赞一直显示已评过，同时需要有接口返回是否已评过</li>
<li>评论留言的点赞和点踩一直显示已评过，同时需要有接口返回是否已评过</li>
<li>置顶，最新接口是否有？全部是按时间排的？？最新也是按照时间排的？？两者有什么区别？？</li>
<li>微信一个公众号两个网址，得另外配一个微信网站？配完网站之后，在manage网站里配才可以公众号菜单</li>
<li>开始扫码绑定，绑定成功之后才可以获取头像和昵称</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>剑指Offer题解</title>
    <url>/2020/02/15/1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库知识</title>
    <url>/2020/02/15/1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/02/14/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>name</title>
    <url>/2020/02/14/name/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java从入门到精通</title>
    <url>/2019/04/16/Java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
    <content><![CDATA[<p>###使用后台管理修改文章</p>
<p>字段解释：<br>这边title指的是文章的标题。<br>data指的是文章的创建时间，文章的排序规则也是根据这个字段来的，时间越后，排序越靠前。<br>tags指的是这个文章所对应的标签。<br>categories指的是文章所对应的分类。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
